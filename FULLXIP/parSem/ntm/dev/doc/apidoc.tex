%% This LaTeX-file was created by <ait> Mon Oct 30 10:55:12 2000
%% LyX 1.0 (C) 1995-1999 by Matthias Ettrich and the LyX Team

%% Do not edit this file unless you know what you are doing.
\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{alltt}

\makeatletter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\providecommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\@}

\makeatother

\def\XCFSM{Xerox C Finite-State Library }

\newcommand{\file}[1]{{\tt #1}}
\newcommand{\func}[1]{{\tt #1}}
\newcommand{\type}[1]{{\tt #1}}
\newcommand{\var}[1]{{\tt #1}}
\newcommand{\scode}[1]{{\tt #1}}
\newcommand{\code}[1]{\vspace{0.4cm} \hspace{0.5cm}{\tt #1}}

\begin{document}


\title{NTM API Programer's Guide}


\author{Salah A\"{i}t-Mokhtar\\ ParSem Group, XRCE}
%\date{\today}

\maketitle

\section{Overview}

NTM is a utility that can tokenize an input text into simple or compound words and lookup those words in lexical FSTs. For more details on NTM, see the NTM User's Guide. In order to use the NTM API in an application, a programer has to:

\begin{enumerate}


\item Include the header file \file{ntm.h}.
\item
Declare an \type{NtmContext} variable. It is a complex and large structure containing all the data needed for the NTM algorithm : flags, FS networks to apply, internal buffers and memory heaps, etc. You will use the NtmContext structure as a parameter for all the NTM API functions. For more details, see section~\ref{NTMcontext}.

\item
Initialize the CFSM context/functions (CFSM is the Xerox C library for Finite-State machines) using \func{ntmCfsmInit()}. This should be done once in the application.

\item
Initialize the NtmContext structure using function \func{ntmInit()} (see section~\ref{NTMcontextInit}).

\item
Set the strategies to use for analysis (couples of normalizing and lexical transducers). Check that no error has occurred using \func{ntmError()}. See section ~\ref{NTMstrategies}.

\item
Set the input text to be processed (a filestream or a char string). See section ~\ref{NTMinput}.

\item
Read analyzed tokens from the input text, using \func{ntmReadTokens()}. After each call to \func{ntmReadTokens()}, check if no error has occurred (using \func{ntmError()}) and if EOF has not been reached (\func{ntmIsEofToken()}). See section ~\ref{NTMreadTokens}.

The main function, \func{ntmReadTokens()}, returns a pointer to an {\tt NtmToken} structure that is described in section ~\ref{NtmToken}.

\item
Once the client application has finished using NTM, it can release the CFSM internal data using \func{ntmCfsmRelease()}. 

\end{enumerate}


\section{The NTM functions}

\subsection{Declaration of the NTM context}
\label{NTMcontext}

Before any call to the NTM functions, you need to declare an NtmContext structure either as a static variable:

\code{NtmContext ct;}

and then use its address (i.e. \&ct) as a parameter to the NTM functions, or as a dynamic variable:

\code{NtmContext {*}ct;}

\code{ct = (NtmContext {*}) malloc(sizeof(NtmContext));} \\

In case of multithreading, each thread must have its own instance of the NTM
context.

\subsection{Initialization of the NTM context}
\label{NTMcontextInit}



The following function initializes the NTM context:
\begin{itemize}
\item
\code{void ntmInit(NtmContext{*} ct);}\\
\end{itemize}
\func{ntmInit()} also sets the ntm default parameters (e.g. default definition fo the space/separator classes).

\func{ntmInit()} is a critical function and must be protected against parallel calls.


\subsection{Assign the ntm strategies}
\label{NTMstrategies}

\begin{itemize}


\item
\code{void ntmLoadStrategy(NtmContext{*} c, char{*} normfile, char{*} lexfile);}\\
Loads one strategy (i.e. a normalizing FST and a lexical FST) from the filesystem and adds it to the NtmContext \var{ct}. \var{normfile} is the pathname of the normalizing FST file, and \var{lexfile} is the pathname of the lexical FST.

\item
\code{void ntmLoadScript(NtmContext{*} ct, char {*}filename);}\\
Loads all the strategies (and potentially the space/separator class definitions) from an ntm script file (see the NTM User's Guide) and adds them to the NtmContext \var{ct}. \var{filename} is the pathname to the script file.

%\item
%\code{void ntmAddStrategy(NtmContext{*} c, NETptr normnet, NETptr lexnet);}\\
%Adds a strategy using couples of networks (normalizing FST, lexical FST). \type{NETptr} is defined in \XCFSM and refers to a pointer on an FST in memory. \var{normnet} is the name of the normalizing FST, and \var{normnet} is the name of the lexical FST. This function assumes the FSTs have been loaded using \func{ntmLoadAndPrepareNets()}.

%\item
%\code{void ntmLoadAndPrepareNets(NtmContext {*}ct, NtmNetStruct {*}nets, int netsNb);}\\
%Loads and prepares networks to be added as strategies into an NTM context.

\item
\code{void ntmResetStrategies(NtmContext{*} ct);}\\
Removes the current strategies of the NtmContext \var{ct}, but does not change current input position.

\end{itemize}





\subsection{Assign the input text}
\label{NTMinput}

\begin{itemize}

\item
\code{void ntmSetInputTextStream(NtmContext{*} ct, FILE{*} stream);}  \\
Sets a file stream as the input in the NtmContext \var{ct}. Assumes that the file character encoding is on one byte.

\item
\code{void ntmSetInputTextString(NtmContext{*} ct, unsigned char{*} s);}  \\
Sets a string of characters \var{s} (that ends with 0) as the input in the NtmContext \var{ct}. Assumes that the character encoding is on one byte.

\item
\code{void ntmSetInputUTF8Stream(NtmContext{*} ct, FILE{*} stream);}  \\
Sets a file stream as the input in the NtmContext \var{ct}. Assumes that the file character encoding is UTF8.

\item
\code{void ntmSetInputUTF8String(NtmContext{*} ct, unsigned char{*} s);}  \\
Sets a string of characters \var{s} (that ends with 0) as the input in the NtmContext \var{ct}. Assumes that the character encoding is UTF8.

\item
\code{void ntmClearInputObject(NtmContext* ct);}  \\
Clears the input object previously allocated by one of the preceding 4 functions.

\end{itemize}

\subsection{Check for errors and warnings}

\begin{itemize}

\item
\code{int ntmError(NtmContext{*} ct);} \\
Returns 1 if an NTM error occurred, 0 otherwise.

\item
\code{int ntmWarning(NtmContext{*} ct);}  \\
Returns 1 if an NTM warning occurred, 0 otherwise.

\item
\code{char {*}ntmMessage(NtmContext{*} ct);} \\
Returns the message of the last error or warning as a static char string (no
need to free it, do not change its content).

\end{itemize}


\subsection{Reading and analyzing tokens}
\label{NTMreadTokens}


\begin{itemize}

\item
\code{NtmToken{*} ntmReadTokens(NtmContext{*} ct);}  \\
This is the main API function. It reads a token using the NTM context \var{ct}. This function returns NULL when it fails, or a pointer to an NtmToken structure when it succeeds. See section \ref{NtmToken} for details about the token structure.

\end{itemize}

\subsection{Check if it is an unknown token}

\begin{itemize}
\item
\code{int ntmIsUnknownToken(NtmToken{*} t);} \\
Returns 1 if token \var{t} was not recognized (unknown token, i.e. not defined in the lexical FSTs), 0 otherwise.
\end{itemize}


\subsection{Check for end of text}

\begin{itemize}

\item
\code{int ntmIsEofToken(NtmToken{*} t);} \\
Returns 1 if token \var{t} indicates the end of the input text, 0 otherwise.

\end{itemize}

\subsection{Printing result}
\label{NTMprint}

\begin{itemize}

\item
\code{int ntmPrintTokens(NtmContext{*} ct, NtmToken{*} token, char {*}s, int maxlg);} \\
Prints the NtmToken structure pointed by \var{token} into a string of character \var{s} with length \var{maxlg}. Returns the number of printed chars. This function depends on the context \var{ct} and should be invoked before any new call to \code{ntmReadTokens(NtmContext{*} ct)}.
Details on the NtmToken structure can be found in section \ref{NtmToken}.

\item
\code{int ntmSnprintIdSeq(char {*}s, int maxlg, id\_type {*}idseq);} \\
Prints the \type{id\_type} sequence \var{idseq} into the string \var{s} with length \var{maxlg}. Returns the number of printed chars. \\
Thus, this function translates an \type{id\_type} sequence into a regular C string.
This function depends on the context \var{ct} and should be invoked before any new call to \code{ntmReadTokens(NtmContext{*} ct)}.
Details on \type{id\_type} sequences can be found in section \ref{NtmToken}.

\end{itemize}


\section{The NtmToken structure}
\label{NtmToken}

The NtmToken type is a structured type that defines a recognized token. Its useful fields are described below:


\begin{center}

\begin{tabular}{|r|p{6cm}|}
\hline

{\bf NtmToken} fields ({\it type} and {\tt name})  &  Description  \\ \hline \hline

\it long int \tt initpos   &  Initial position (offset), in terms of characters (ISO or  UTF8), of this token in the input text. \\ \hline

\it short int \tt inputLength  &  Length of this token in terms of characters \\\hline

\it long int \tt initBytepos  &  Initial position (offset), in terms of bytes, of this token in the input text. \\ \hline
\it short int \tt inputByteLength  & Length of this token in bytes. \\ \hline

\it unsigned char \tt strategy &  The number of the strategy that led to the recognition this token (as defined in the ntm script file). \\ \hline
\it unsigned short \tt entryNb : 8    &   The number of lexical entries found for this token (max. value is 255). \\ \hline
%\it ntmbit \tt weight : 6 & \\ \hline
%\it ntmbit \tt ignore : 1 &  \\ \hline
%\it ntmbit \tt tambig : 1 &  \\ \hline
\it struct  NtmEntry * \tt entrySeq  &  A pointer to the sequence of lexical entries for this token.  \\ \hline
%\it struct  NtmToken * \tt longerToken;   &   ptr to longer token with same initpos  \\ \hline
%\it struct  NtmToken * \tt shorterToken;   &   ptr to shorter token with same initpos  \\ \hline
%\it struct  NtmToken * \tt previousToken;   &   ptr to previous token   \\ \hline
%\it struct  NtmToken * \tt nextToken;   &   ptr to next following token   \\ \hline

\end{tabular}
\end{center}

\vspace{1cm}

Each read token is given one or more readings (or ntm entries) (depending on the FSTs that are used for analysis). A reading is of type {\it NtmEntry}. Even when a read token is unknown from the FSTs, it is given a default reading.

The readings are given by {\tt entrySeq}, which is a pointer to a contiguous sequence of NtmEntries (the number of readings is given by {\tt entryNb}). The type {\it NtmEntry} defines three attributes, as shown below:\\


\begin{center}

\begin{tabular}{|r|p{6cm}|}
\hline

{\bf NtmEntry} fields ({\it type} and {\tt name})  &  Description  \\ \hline \hline

\it id\_type * \tt normform  &  A pointer on the normalized form    \\ \hline
\it id\_type * \tt lemma    &   A pointer on the lemma of this entry  \\ \hline
\it id\_type * \tt features   & A pointer on  the (lexical) features of this entry \\\hline 

\end{tabular}

\end{center}


\vspace{1cm}

The normalized form of the token is the form that is obtained after applying the normalizing FST on the input characters and that leads to the recognition of the token in the lexical FST. The lemma is the canonical form, as it is defined in the lexical FST. Each of these three elements is a pointer on a sequence of \type{id\_type} symbols.

\type{id\_type} is the internal CFSM type for symbols (simple character symbols, or multi-char symbols for the representation of lexical features). An \type{id\_type*} sequence always ends with the CFSM predefined constant \var{ID\_NO\_SYMBOL}. In order to translate an \type{id\_type*} sequence into a regular C string, see section \ref{NTMprint}. 

%\section{Compiling and linking}

%In order to compile and link an NTM client program, add to the include pathes the directory where the ntm headers (mainly \file{ntm.h}) are installed, and to the linking pathes the directory where the NTM library is installed (\file{libntm.a}). Link with \scode{-lntm}.



\section{An example}


\begin{verbatim}

#include <stdarg.h>
#ifdef _WINDOWS
#include <stdlib.h>
#endif

#include "ntm.h"


/* This is an example of a client program that uses the NTM API
   to read tokens from an input text and to lookup the tokens
   in lexical FSTs
   Please read the API documentation
***********************************************************/

int main(int argn, char **argv) {

    static NtmContext ct;
    long initpos = 0, strategy_ind=0;
    NtmToken *token=NULL, *t=NULL;
    char sout[5002];
    FILE *textStream;

    // Initialize the CSFM context/functions
    ntmCfsmInit();

    // Initialize the NTM context ct
    ntmInit(&ct);

    // set the indice option (otherwise ntm won't get the token indices)
    ntmSetPrintIndices(&ct, TRUE);

    // Now, load the (normalizing and lexical) FSTs that will be used for analysis
    // in the NTM context ct
    // assuming the FSTs are declared in the NTM script file 'ntmscript'
    ntmLoadScript(&ct, "ntmscript");

    // Check if there was an error while reading the NTM script
    if (ntmError(&ct)) {
        fprintf(stderr, "\n%s\n\n", ntmMessage(&ct));
        exit(1);
    }        

    // Now open file "input.txt"
    textStream = fopen( "input.txt", "r");
    if (textStream == NULL) {
        fprintf(stderr, "Unable to read text from '%s'\n\n", "input.txt");
        exit(1);
    }

    // and set its stream as the input (text) object in the NTM context ct
    ntmSetInputTextStream(&ct, textStream);


    // Start reading and analyzing tokens from the input text

    token = ntmReadTokens(&ct);
    // while no error and the end of text is not reached
    while ( !ntmError(&ct) && !ntmIsEofToken(token) ) {
      // if there is a warning, print the message on stderr
      if (ntmWarning(&ct)) {
         fprintf(stderr, "\n####%s\n", ntmMessage(&ct));
         ntmResetWarning(&ct);
      }
      // print the token analysis on the string 'sout'
      ntmPrintTokens(&ct, token, sout, 5000);
      // and then print the string 'sout' on stdout
      fputs(sout, stdout);
      
      // read next token
      token = ntmReadTokens(&ct);
    }

    // if an error occurred, print the error message
    if (ntmError(&ct)) {
      fprintf(stderr, "\n%s\n\n", ntmMessage(&ct));
    }


    // Free the allocated input object
    ntmClearInputObject(&ct);

    fclose(textStream);

    // release the CFSM context
    ntmCfsmRelease();

    return 0;
}






\end{verbatim}



\end{document}
