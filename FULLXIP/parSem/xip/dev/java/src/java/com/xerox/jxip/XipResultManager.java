/*
 *  Xerox Research Centre Europe - Grenoble Laboratory
 *  Copyright (C) 2004 - 2009 Xerox Corporation
 *  All Rights Reserved
 *
 */
package com.xerox.jxip;

import java.io.File;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.Hashtable;
import java.util.Vector;

/**
 * The purpose of this class is to build XipResult. The result of a parse can be
 * returned as a XipResult object. This object contains a vector of XipUnit
 * objects. Each XipUnit object corresponds to the analysis of a given sentence.
 * A XipUnit, in turn, is composed of the root of the chunking tree (a XipNode
 * object) and a vector of dependencies (a XipDependency object). Each XipNode
 * object contains a set of features, stored as a vector of XipFeature objects.
 * Each XipDependency is composed of a dependency name, a vector of XipNode
 * objects, and a set of XipFeature objects.
 *
 * If the node is a non-lexical node (such as an NP or a VP), then the surface
 * field stores the label of that node, while the lemma vector remains empty. If
 * a node is a lexical node, then the surface field stores the surface form of
 * that lexeme, while the lemma vector stores all other possible reading for
 * that lexeme. For non-lexical nodes, the list of all the daughters of a node
 * is accessible through the daughters vector. Thus, you can explore the
 * complete chunk tree using the root field of a XipUnit object as a starting
 * point and scanning the daughter nodes.
 *
 * A dependency is a relation that links together nodes in the chunk tree. A
 * dependency has a name, such as subject or object, and is associated with a
 * set of features that are stored in a vector of XipFeature objects. The nodes
 * that are linked together by a dependency are gathered in a vector of XipNode
 * objects, each corresponding to a specific node in the chunk tree.
 *
 * Each node is associated with features. A feature expresses a property of the
 * node, such as part of speech, singular and plural, and so on. A feature
 * consists of a name and a value pair. For example, gender is a feature with
 * the possible values of fem, masc, and neutral.
 *
 * @author grondeau @created April 8, 2005
 */
public class XipResultManager {

    private XipResult xipResult;
    private XipUnit xipUnit;
    private XipNode xipNode;
    private XipLeaf xipLeaf;
    private XipDependency xipDependency;
    // the file name of the parsed file
    private String fileName;
    // the string generated by "print" in the xipRules
    String xipOutput;
	String xipJSonOutput;
    // key = nodeIndex, value = XipNode
    private Hashtable<Long, XipNode> xipNodes;
    // vector of XipUnit
    private Vector<XipUnit> xipUnits;
    // vector of XipLeaves
    private Vector<XipLeaf> leaves;
    // vector of XipDependency
    private Vector<XipDependency> dependencies;
    // vector of XipFeature for a XipDependency
    private Vector<XipFeature> dependencyFeatures;
    // vector of XipFeature for a XipNode
    private Vector<XipFeature> nodeFeatures;
    //Object instance where callBack will be invoke
    private Object objectInstance;
    // call back used by xipResultBuilderFromString,xipResultBuilderFromTextFile, xipResultBuilderFromXmlFile
    private String callBack;
    // call back used by xipResultBuilderFromXmlFile
    private String xmlCallBack;
    private long sentenceNb;

    /**
     * Constructor for the XipResultManager object
     */
    public XipResultManager() {
        fileName = null;
        sentenceNb = 0L;
    }

    /**
     * build the java XipResult (string parsing)
     *
     * @param gHandler a grammar handler
     * @param inputStr the string to parse
     * @return 0 if Ok , 1 if error
     * @throws java.lang.Exception
     */
    public synchronized int buildXipResult(int gHandler, String inputStr) throws Exception {
        return xipResultBuilderFromString(gHandler, inputStr, null, null);
    }

    /**
     * build the java XipResult (file parsing)
     *
     * @param gHandler a grammar handler
     * @param fileName the full file name to parse
     * @return 0 if Ok , 1 if error
     * @throws java.lang.Exception
     */
    public synchronized int buildXipResultFromFile(int gHandler, String fileName) throws Exception {
        this.fileName = JXip.duplicateString(fileName);
        return xipResultBuilderFromTextFile(gHandler, this.fileName, null, null);
    }

    /**
     * call buildXipResultFromXmlFile (...., depth =2)
     *
     * @param gHandler a grammar handler
     * @param fileName the full file name to parse
     * @return 0 if Ok , 1 if error
     * @throws java.lang.Exception
     */
    public synchronized int buildXipResultFromXmlFile(int gHandler, String fileName)
            throws Exception {
        return buildXipResultFromXmlFile(gHandler, fileName, 2);
    }

    /**
     * build the java XipResult from (XML file parsing)
     *
     * @param gHandler a grammar handler
     * @param fileName the full file name to parse
     * @param depth must be 0 or 2 (full or partial xml parsing)
     * @return 0 if Ok , 1 if error
     * @throws java.lang.Exception
     */
    public synchronized int buildXipResultFromXmlFile(int gHandler, String fileName,
            int depth) throws Exception {
        this.fileName = JXip.duplicateString(fileName);
        return xipResultBuilderFromXmlFile(gHandler, fileName, null, null, null, depth);
    }

    /**
     * @param gHandler a grammar handler
     * @param inputStr the string to parse
     * @param objInst the object instance of the callBack. If null, no callback
     * will be invoked
     * @param cb the callback method invoked after the analyze of one sentence
     * @return 
     * @throws java.lang.Exception
     */
    public synchronized int xipResultBuilderFromString(int gHandler, String inputStr,
            Object objInst, String cb) throws Exception {
        objectInstance = objInst;
        callBack = cb;
        sentenceNb = 0L;
        return xipResultBuilderImplementation(1, gHandler, inputStr, cb, null, 0);
    }

    /**
     * @param gHandler a grammar handler
     * @param textFileName the full file name to parse (text file)
     * @param objInst the object instance of the callBack. If null, no callback
     * will be invoked
     * @param cb the callback method invoked after the analyze of one sentence
     * @return
     * @throws java.lang.Exception
     */
    public synchronized int xipResultBuilderFromTextFile(int gHandler, String textFileName,
            Object objInst, String cb) throws Exception {
        if (!((new File(textFileName)).exists())) {
            throw new XipException("textFileName does not exist: " + textFileName);
        } else {
            objectInstance = objInst;
            callBack = cb;
            fileName = JXip.duplicateString(textFileName);
            sentenceNb = 0L;
            return xipResultBuilderImplementation(2, gHandler, fileName, cb, null, 0);
        }
    }

    /**
     * call xipResultBuilderFromXmlFile( .... , depth = 2)
     *
     * @param gHandler a grammar handler
     * @param xmlFileName the full file name to parse (XML file)
     * @param objInst the object instance of the callBack. If null, no callback
     * will be invoked
     * @param cb the callback method invoked after the analyze of one sentence
     * @param xmlCb the callback method invoked after the each xml tag take in
     * account by the xip parser
     * @return
     * @throws java.lang.Exception
     */
    public synchronized int xipResultBuilderFromXmlFile(int gHandler,
            String xmlFileName, Object objInst, String cb, String xmlCb)
            throws Exception {
        return xipResultBuilderFromXmlFile(gHandler, xmlFileName, objInst, cb, xmlCb, 2);
    }

    /**
     * @param gHandler a grammar handler
     * @param xmlFileName the full file name to parse (XML file)
     * @param objInst the object instance of the callBack. If null, no callback
     * will be invoked
     * @param cb the callback method invoked after the analyze of one sentence
     * @param xmlCb the callback method invoked after the each xml tag take in
     * account by the xip parser
     * @param depth must 0 or 2. (full or partial xml parsing)
     * @return
     * @throws java.lang.Exception
     */
    public synchronized int xipResultBuilderFromXmlFile(int gHandler,
            String xmlFileName, Object objInst, String cb,
            String xmlCb, int depth) throws Exception {
        if (!((new File(xmlFileName)).exists())) {
            throw new XipException("xmlFileName does not exist");
        }
        objectInstance = objInst;
        callBack = cb;
        xmlCallBack = xmlCb;
        fileName = JXip.duplicateString(xmlFileName);
        sentenceNb = 0L;
        return xipResultBuilderImplementation(3, gHandler, fileName, cb, xmlCb, depth);
    }

    /**
     * Gets the XipResult
     *
     * @return The XipResult
     */
    public synchronized XipResult getXipResult() {
        //System.out.println("getXipResult");
        return xipResult;
    }

    /**
     * Gets the string generated by "print" in the xipRules
     *
     * @return The output
     */
    public synchronized String getXipOutput() {
        return xipOutput;
    }

    /**
     * Initialization between each sentence
     */
    private void initBetweenSentence() {
        //System.out.println("+++++++++++++++++++++++++++++++initBetweenSentence");
        xipResult = null;
        xipUnit = null;
        xipNode = null;
        xipLeaf = null;
        xipDependency = null;
        xipOutput = "";
        xipNodes = new Hashtable<Long, XipNode>();
        leaves = new Vector<XipLeaf>();
        dependencies = new Vector<XipDependency>();
        dependencyFeatures = new Vector<XipFeature>();
        nodeFeatures = new Vector<XipFeature>();
        sentenceNb++;
    }

    //------------------------------------------------------------------------
    private native void keepNativeXipResultImplementation() throws Exception;

    /**
     * do not destroy the current c++ XipResult
     *
     * @exception Exception
     */
    public synchronized void keepNativeXipResult() throws Exception {
        keepNativeXipResultImplementation();
    }

    //----------------------------------------------------------------------------------------------
    private native void destroyNativeXipResultImplementation(int gHandler)
            throws Exception;

    /**
     * destroy the current c++ XipResult
     *
     * @param gHandler
     * @exception Exception
     */
    public synchronized void destroyNativeXipResult(int gHandler)
            throws Exception {
        destroyNativeXipResultImplementation(gHandler);
    }
    //-------------------------- native method ----------------------------------

    /**
     * @param inputType
     * @param gHandler
     * @param param
     * @param callBack
     * @param xmlCallBack
     * @return
     */
    private native int xipResultBuilderImplementation(int inputType, int gHandler,
            String param, String callBack, String xmlCallBack, int xmlDepth);

    //----------- callBack method (from native C++ code: JXipResultManagerImpl.cxx)
    /**
     * Initialization before building each XipResult
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::xipResultInit()
     */
    private void xipResultInitCB() {
        //System.out.println("XipResultManager::xipResultInit()");
        xipUnits = new Vector<XipUnit>();
    }

    /**
     * Initialization before each sentence
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::sentenceInit()
     */
    private void sentenceInitCB() {
        //System.out.println("XipResultManager::sentenceInitCB()");
        initBetweenSentence();
    }

    /**
     * Sets the motherNode attribute of the XipResultManager object
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::addMotherAndDaughtersToXipNode()
     *
     * @param nodeIndex The index of the node to update
     * @param motherNodeIndex the index of its mother node
     */
    private void setMotherNodeCB(long nodeIndex, long motherNodeIndex) {
        XipNode node = xipNodes.get(new Long(nodeIndex));
        XipNode mother = xipNodes.get(new Long(motherNodeIndex));
        //System.out.println("XipResultManager::setMotherNode() node="
        // + node.getCategory() + " mother=" + mother.getCategory());
        node.setMother(mother);
    }

    /**
     * Sets the daughterNode attribute of the XipResultManager object
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::addMotherAndDaughtersToXipNode()
     *
     * @param nodeIndex The index of the node to update
     * @param daughterNodeIndex the index of one of its daughter node
     */
    private void setDaughterNodeCB(long nodeIndex, long daughterNodeIndex) {
        XipNode node = xipNodes.get(new Long(nodeIndex));
        XipNode daughter = xipNodes.get(new Long(daughterNodeIndex));
        //System.out.println("XipResultManager::setDaughterNode() node = "
        // + node.getCategory() + " daughter = " + daughter.getCategory());
        node.addDaughter(daughter);
    }

    /**
     * Sets a dependencyNode to a XipNode
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::createJavaDependencies()
     *
     * @param nodeIndex The XipNode
     * @param dependencyNodeIndex The index of the XipDependency
     */
    private void setDependencyNodeCB(long nodeIndex, long dependencyNodeIndex) {
        XipNode node = xipNodes.get(new Long(nodeIndex));
        XipDependency dependency = dependencies.get((int) dependencyNodeIndex);
        //System.out.println("XipResultManager::setDependencyNode() node = "
        // + node.getCategory() + " dependency = " + dependency.getName());
        node.addDependency(dependency);
    }

    /**
     * Create XipNode
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::createJavaXipNode()
     *
     * @param category
     * @param left
     * @param right
     * @param index
     */
    private void createXipNodeCB(String category, String infos, long left, long right,
            long index, long gramNodeId, String fileName,
            long leftChar, long rightChar) {
        //System.out.println("XipResultManager::createXipNode()");
        //String mes = "XipResultManager::createXipNode() category=" + category;
        //mes += " left=" + left + " right=" + right + " index=" + index + " fileName=" + fileName ;
        //System.out.println(mes);
        nodeFeatures = new Vector<XipFeature>();
        xipNode = new XipNode(category, infos, left, right, index, gramNodeId,
                fileName, sentenceNb, leftChar, rightChar);
        xipNodes.put(new Long(index), xipNode);
    }

    /**
     * create XipLeaf
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::createJavaXipNode()
     *
     * @param category
     * @param surface
     * @param lemma
     * @param initialfeatures
     * @param left
     * @param right
     * @param index
     */
    private void createXipLeafCB(String category, String infos, String surface, String lemma, String initialfeatures,
            long left, long right, long index, long gramNodeId,
            String fileName, long leftChar, long rightChar) {
        //System.out.println("XipResultManager::createXipLeaf()");
        //String mes = "XipResultManager::createXipLeaf() category=" + category + " surface=" + surface;
        //mes += " lemma=" + lemma + initialfeatures + " left=" + left;
        //mes += " right=" + right + " index=" + index + " fileName=" + fileName;
        //System.out.println(mes);
        nodeFeatures = new Vector<XipFeature>();
        xipLeaf = new XipLeaf(category, infos,  surface, lemma, initialfeatures,
                left, right, index, gramNodeId, fileName,
                sentenceNb, leftChar, rightChar);
        xipNodes.put(new Long(index), xipLeaf);
        leaves.add(xipLeaf);
    }

    /**
     * add a XipFeature to the vector of XipFeature (for the current XipNode or
     * XipLeaf object)
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::createJavaXipNode()
     *
     * @param name feature name
     * @param value feature value
     * @param isLeaf true if it is a XipLeaf, false otherwise
     * @param index
     */
    private void createNodeFeatureCB(String name, String value, boolean isLeaf, long index) {
        //System.out.println("XipResultManager::createNodeFeature() name ="
        // + name + " value =" + value + " isLeaf=" + isLeaf);
        XipFeature xipFeature = new XipFeature(name, value, index);
        nodeFeatures.add(xipFeature);
        if (isLeaf) {
            xipLeaf.setFeatures(nodeFeatures);
        } else {
            xipNode.setFeatures(nodeFeatures);
        }
    }

    /**
     * Create a XipDependecy
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::createJavaDependencies()
     *
     * @param name XipDependency name
     * @param index
     */
    private void createDependencyCB(String name, long index) {
        //System.out.println("XipResultManager::createDependency() name =" + name);
        dependencyFeatures = new Vector<XipFeature>();
        xipDependency = new XipDependency(name, index);
        dependencies.add(xipDependency);
    }

    /**
     * Sets the parameterDependency attribute of the current XipDependency
     * object
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::createJavaDependencies()
     *
     * @param nodeIndex The index of XipNode used as parameterDependency
     */
    private void setParameterDependencyCB(long nodeIndex) {
        //System.out.println("XipResultManager::setParameterDependencyCB() index =" + nodeIndex);
        XipNode node = xipNodes.get(new Long(nodeIndex));
        (xipDependency.getParameters()).add(node);
    }

    /**
     * add a XipFeature to the vector of XipFeature (for the current
     * XipDependency object)
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::createJavaDependencies()
     *
     * @param value Feature value
     * @param name
     * @param index
     */
    private void createDependencyFeatureCB(String name, String value, long index) {
        //System.out.println("XipResultManager::createDependencyFeature() name =" + name + " value =" + value);
        XipFeature xipFeature = new XipFeature(name, value, index);
        dependencyFeatures.add(xipFeature);
        xipDependency.setFeatures(dependencyFeatures);
    }

    /**
     * Create XipUnit
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::createJavaXipUnit()
     *
     * @param rootIndex index of the root node
     * @param language
     */
    private void createXipUnitCB(long rootIndex, String language) throws XipException {
        //System.out.println("XipResultManager::createXipUnit() rootIndex=" +
        //        rootIndex + " xipNodes=" + xipNodes.size() + " " + xipNodes);
        XipNode rootNode = xipNodes.get(new Long(rootIndex));
        if (rootNode == null) {
            XipException xipException = new XipException("XipResultManager::createXipUnitCB() error NO ROOT NODE");
            throw xipException;
        }
        xipUnit = new XipUnit(rootNode, leaves, dependencies, language, sentenceNb);
        xipUnits.add(xipUnit);
    }

    /**
     * create XipResult
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::createJavaXipResult()
     */
    private void createXipResultCB() {
        //System.out.println("XipResultManager::createXipResult()");
        xipResult = new XipResult(xipUnits, fileName);
    }

    /**
     * Sets the string generated by "print" in the xipRules
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::xipResultBuilderImplementation()
     *
     * @param out The new xipOutput value
     */
    private void setOutputCB(String out) {
        //System.out.println("XipResultManager::setOutput() output = " + out);
        xipOutput = out;
    }

    /**
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::implCallBack()
     *
     *
     * @exception Exception
     */
    private void jCallBackCB() throws Exception {
        //System.out.println("XipResultManager::jCallBack()");
        jCallBackCom(callBack);
    }

    /**
     *
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::implCallBackXml()
     *
     * @exception Exception
     */
    private void jCallBackXmlCB() throws Exception {
        //System.out.println("XipResultManager::jCallBackXml()");
        jCallBackCom(xmlCallBack);
    }

    @SuppressWarnings({"unchecked", "unchecked"})
    private Method getMethod(Class thisClass, String callBack)
            throws ClassNotFoundException, NoSuchMethodException {
        //System.out.println("getMethod: className=" + thisClass);
        Method thisMethod = null;
        // we assume that called methods have no argument
        Class[] params = {};
        try {
            thisMethod = thisClass.getDeclaredMethod(callBack, params);
        } catch (java.lang.NoSuchMethodException ex) {
            // look for it in the upper classes
            Type type = thisClass.getGenericSuperclass();
            if (type != null) {
                return getMethod((Class) type, callBack);
            } else {
                throw new java.lang.NoSuchMethodException(callBack);
            }
        }
        return thisMethod;
    }

    /**
     *
     *
     * @param callBack
     * @exception Exception
     */
    @SuppressWarnings({"unchecked", "unchecked", "unchecked"})
    private void jCallBackCom(String callBack) throws Exception {
        try {
            Object[] paramsObj = {};
            // get the Class
            Class thisClass = Class.forName(objectInstance.getClass().getName());
            // get the Method
            Method thisMethod = getMethod(thisClass, callBack);
            // call the method
            thisMethod.invoke(objectInstance, paramsObj);
        } catch (Exception ex) {
            System.out.println("Exception:" + ex);
        }
    }
    private Hashtable<String, String> xmlTagInfo = null;

    /**
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::implCallBackXml()
     */
    private void setXmlTagInfoCB(String propertyName, String propertyValue) {
        //System.out.println("setXmlTagInfoCB:  " + propertyName + " = " + propertyValue);
        xmlTagInfo.put(propertyName, propertyValue);
    }


	 /**
     * Return the content of xipJSonOuput.
     * Can be used in the context of a JSON output
     * @return 
     */
    public String getJSonStringCB() {
        return xipJSonOutput;
    }

	 /**
     * set the content of xipJSonOuput.
     * Can be used in the context of a JSON output
     */
    private void setJSonStringCB(String jsonstr) {
        xipJSonOutput=jsonstr;
    }

    /**
     * This callback method is called by the C++ method
     * JXipResultManagerImpl::implCallBackXml()
     */
    private void clearXmlTagInfoCB() {
        //System.out.println("clearXmlTagInfoCB");
        xmlTagInfo = new Hashtable<String, String>();
    }

    /**
     *
     * @return
     */
    public Hashtable<String, String> getXmlTagInfo() {
        //System.out.println("getXmlTagInfo: " + xmlTagInfo.toString());
        return xmlTagInfo;
    }
    //--------------------------end of callBack method ----------------------
    //----------------------------- tests ------------------------------
    private int count = 0;

    /**
     * Test
     *
     * @param args
     */
    private void test1(String[] args) throws Exception {
        count = 1;
        if (args.length != 2) {
            System.out.println("Two parameters are required: the fullpath "
                    + "of the grm file, and the string to parse");
            System.exit(-1);
        }
        System.out.println("JXip::main() Loading grammar file: " + args[0]);
        System.out.println("Xip::main() parsing the string = " + args[1]);
        // create a JXIP object to load the dynamic library in the VM
        JXip jxip = new JXip();
        int gHandler = jxip.XipGrmFile(args[0], 0, true);
        long displayMode = Const.DISPLAY_TREE;
        int col = 80;
        jxip.XipSetDisplayMode(gHandler, displayMode, col);
        //jxip.XipSetDisplayMode(gHandler, Const.UTF8_INPUT, col);
        String res0 = jxip.parseString(gHandler, args[1], Const.XML_NONE, (char) 1);
        System.out.println("\nXip::main() resultat after parsing = " + res0);

        //int res = xipResultManager.buildXipResult(gHandler, args[1]);
        int res = xipResultManager.buildXipResultFromFile(gHandler, args[1]);
        if (res != 0) {
            System.out.println("XipResultManager::main() buildXipResult ERROR");
            System.exit(-1);
        }
        String out = xipResultManager.getXipOutput();
        System.out.println("\n---- the output ----\n" + out);
        XipResult xipRes = xipResultManager.getXipResult();
        boolean withFeature = true;
        String str = xipRes.toString(withFeature);
        System.out.println("\n ---- the xipResult ----\n" + str);
        String str1 = xipRes.getSentenceString();
        System.out.println("\n ---- the sentence ----\n" + str1);
    }

    /**
     *
     */
    private void myCB() {
        try {
            //System.out.println("\n ---------------------- myCB " + count++ + " ---------------------------\n");
            //System.out.println(count++);
            //String out = xipResultManager.getXipOutput();
            //System.out.println("\n---- the output ----\n" + out);
            XipResult xipRes = xipResultManager.getXipResult();
            boolean withFeature = false;
            String str = xipRes.toString(withFeature);
            //System.out.println("\n ---- the xipResult ----\n" + str);
            String str1 = xipRes.getSentenceString();
            //System.out.println("\n ---- the sentence ----\n" + str1);
        } catch (Exception ex) {
            System.out.println(ex);
            System.exit(-1);
        }
    }

    /**
     *
     */
    public void myCBXml() {
        try {
            System.out.println("\n ---------------------------- Test.myCBXml ----------------------\n");
            Hashtable<String, String> xmlTagI = xipResultManager.getXmlTagInfo();
            System.out.println("xmlTagInfo = " + xmlTagI.toString());
        } catch (Exception ex) {
            System.out.println(ex);
            System.exit(-1);
        }
    }
    private static XipResultManager xipResultManager;

    /**
     *
     * @param args
     */
    private void test2(String[] args) throws Exception {
        count = 1;
        if (args.length != 2) {
            System.out.println("Two parameters are required: the fullpath of the grm file, and the input");
            System.exit(-1);
        }
        System.out.println("JXip::main() Loading grammar file: " + args[0]);
        System.out.println("Xip::main() parsing  = " + args[1]);
        JXip jxip = new JXip();
        int gHandler = jxip.XipGrmFile(args[0], 0, true);
        //xipResultManager.xipResultBuilderFromString(gHandler, "Peter is happy. The cat is black.", this, "myCB");
        //xipResultManager.xipResultBuilderFromTextFile(gHandler, args[1], this, "myCB");
        xipResultManager.xipResultBuilderFromXmlFile(gHandler, "input.xml", this, "myCB", "myCBXml", 2);
    }

    private void test3() throws Exception {
        count = 1;
        String gram = "";
        String input = "";
        if (DynLoaderFromJar.isWindows()) {
            String root = "z:\\users\\grondeau\\parSem\\xip\\dev\\";
            gram = root + "GRAMMARS\\ENGLISH\\GRMFILES\\GRAM_GEN\\gram_gen_entit.grm";
            //input = root + "java\\testReg\\testCallBack1\\inputs\\en1";
            input = root + "java\\testAna\\testMem1\\input-5000";
            //input = root + "java\\testAna\\testMem1\\input-5000";
            //input = root + "java\\testAna\\testMem1\\input-50000";
        } else {
            String root = "/opt/ParSem/users/grondeau/parSem/xip/dev/";
            gram = root + "GRAMMARS/ENGLISH/GRMFILES/GRAM_GEN/gram_gen_entit.grm";
            input = root + "java/testReg/testCallBack1/inputs/en1";
        }
        System.out.println("JXip::main() Loading grammar file: " + gram);
        System.out.println("Xip::main() parsing  = " + input);
        //JXip jxip = new JXip();
        JXip jxip = new JXip(null, false); // to be used with netbeans
        int gHandler = jxip.XipGrmFile(gram, 0, true);
        //xipResultManager.xipResultBuilderFromString(gHandler, "Peter is happy. The cat is black.", this, "myCB");
        xipResultManager.xipResultBuilderFromTextFile(gHandler, input, this, "myCB");
        //xipResultManager.xipResultBuilderFromXmlFile(gHandler, input, this, "myCB", "myCBXml", 2);
        jxip.printSysInfo();
    }

    /**
     *
     *
     * @param args
     */
    public static void main(String[] args) {
        try {
            xipResultManager = new XipResultManager();
            //xipResultManager.test1(args);
            //xipResultManager.test2(args);
            xipResultManager.test3();
        } catch (Exception ex) {
            System.out.println("Exception in main: " + ex);
            //ex.printStackTrace();
            System.exit(-1);
        }
    }
}
