DependencyRules:


////////////////////////
//AR J'ai réorganisé ce fichier et ajouté des règles

// 1. Création des dépendances de factualité pour tous les COREs

if ( CORE-VERB[modality](#1) )
	POSSIBLE(#1).

//COORD(and_CONJ:+,dispose_POTCORE:+)
//COORD(and_CONJ:+,negotiates_POTCORE:+)
//MAIN(and_CONJ:+)


if ( COORD(#1[conj],#2) & COORD(#1[conj],#3) & MAIN(#1[conj]) )
	FACTUAL(#2).

if ( MAIN(#1[conj:~]) & ~POSSIBLE(#1) & CORE-VERB[main](#1) )
	FACTUAL(#1).


if ( VDOMAIN[modal:~](#1,#2) & ~POSSIBLE(#1) & CORE-VERB[main](#1) & ~FACTUAL(#1))
	FACTUAL(#1)
.
// règles qui servent à éviter les cas où un CORE ne se voit pas attribuer de factualité
if ( CORE-DRIVE(#1,#3) & CORE-VERB(#3) & ~POSSIBLE(#3) & ~FACTUAL(#3) & ~COUNTER-FACTUAL(#3))
	POSSIBLE(#3)
if ( MAIN(#3) & CORE(#3) & CORE-VERB(#3) & ~POSSIBLE(#3) & ~FACTUAL(#3) & ~COUNTER-FACTUAL(#3))
	FACTUAL(#3)
if ( CORE-VERB(#1) & ~CORE-DRIVE(?,#1) & ~CORE-ANNEX(?,#1) &  ~POSSIBLE(#1) & ~FACTUAL(#1) & ~COUNTER-FACTUAL(#1))
	FACTUAL(#1)

// 2. modification de la factualité
//a) modalité attachée
if ( CORE-ATT(#1[aux],#2) & (^POSSIBLE(#2)|^FACTUAL(#2)) )
	POSSIBLE[att=+](#2).

if ( CORE-ATT(#1[adjmod],#2) & (^POSSIBLE(#2)|^FACTUAL(#2)) )
	POSSIBLE[att=+](#2).

// négation (concerne les verbes principaux)
if (^FACTUAL(#1) & MOD[neg](#1,?))
	COUNTER-FACTUAL[neg=+](#1)


 
//b) modalité héritée

//relatives
if( CORE-ANNEX[rel](#1,#2) & ^POSSIBLE[att:~](#2))
	FACTUAL(#2).


//conditionnelles
| #1[form:fif] |
if ( ^FACTUAL(#2) & #1 < #2 )
	POSSIBLE(#2).

//présupposé
if ( CORE-DRIVE(#1[presupp],#2) & ^POSSIBLE[att:~](#2) )
	FACTUAL(#2).

// verbes de parole
if (CORE-DRIVE(#1[say],#2) & FACTUAL(#1) & ^POSSIBLE[att:~](#2))
	FACTUAL(#2).

// négation (pour les événements emboîtés)
if (^FACTUAL[neg:~](#1) & MOD[neg](#1,?))
	COUNTER-FACTUAL[neg=+](#1)



////////////// ancienne version :
/
if ( CORE-VERB[modality](#1) )
	POSSIBLE(#1).

if ( CORE-ATT(#1[aux],#2) & ^POSSIBLE(#2) )
	POSSIBLE[att=+](#2).


//COORD(and_CONJ:+,dispose_POTCORE:+)
//COORD(and_CONJ:+,negotiates_POTCORE:+)
//MAIN(and_CONJ:+)


if ( COORD(#1[conj],#2) & COORD(#1[conj],#3) & MAIN(#1[conj]) )
	FACTUAL(#2).

if ( MAIN(#1[conj:~]) & ~POSSIBLE(#1) & CORE-VERB[main](#1) )
	FACTUAL(#1).


if ( VDOMAIN[modal:~](#1,#2) & ~POSSIBLE(#1) & CORE-VERB[main](#1) & ~FACTUAL(#1))
	FACTUAL(#1).


| #1[form:fif] |
if ( ^FACTUAL(#2) & #1 < #2 )
	POSSIBLE(#2).

if ( CORE-DRIVE(#1[presupp],#2) & ^POSSIBLE[att:~](#2) )
	FACTUAL(#2).

// je commente cette règle parce que la relation CORE-DRIVE signale maintenant un véritable emboîtement : les relatives ne donnent pas lieu à la relation CORE-DRIVE sauf si le nom qualifié est un nom d'événement
//| #2[rel] |
//if ( CORE-DRIVE(#1,#3) & ^POSSIBLE[att:~](#3) & #1 < #2 & #2 < #3 )
//	FACTUAL(#3).

if( CORE-ANNEX[rel](#1,#2) & ^POSSIBLE[att:~](#2))
	FACTUAL(#2).

// règles qui servent à éviter les cas où un CORE ne se voit pas attribuer de factualité
if ( CORE-DRIVE(#1,#3) & ~POSSIBLE(#3) & ~FACTUAL(#3) & ~COUNTER-FACTUAL(#3))
	POSSIBLE(#3)
if ( MAIN(#3) & ~POSSIBLE(#3) & ~FACTUAL(#3) & ~COUNTER-FACTUAL(#3))
	FACTUAL(#3)
if ( CORE(#1) & ~CORE-DRIVE(?,#1) & ~CORE-ANNEX(?,#1) &  ~POSSIBLE(#3) & ~FACTUAL(#3) & ~COUNTER-FACTUAL(#3))
	FACTUAL(#1)

\