
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//! Xerox Research Centre Europe - Grenoble Laboratory
//!
//! Copyright (c) 2006 Xerox Corporation.  All Rights Reserved.
//!
//! --- CONTENTS ---
//!   Project    : English XIP grammar for EERQI
//!   filename   : dependency_eerqi.xip
//!   Date       : August 2008
//!   Author     : Agnes Sandor
//!  
//!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

DependencyRules:

if ( ^VDOMAIN(?,?))
	~.

//if ( ^HEAD(#1,#2) )
//HEAD	~.

// create a dependency between a the negative word and a subject complement

if ( MOD(#1,#2[form:fnot]) & NUCL(#1,#3) )
	MOD[negative=+](#3,#2).



//marking words that have special roles in relsents and bkdepsent: level



////////////////////////////////////////////////////////////
//EERQIDEP
////////////////////////////////////////////////////////////


/////////////////////

// has not previously been demonstrated

| #1[bk,adv], #2[form:fbe], #3[bk] |
	MOD(#1,#3).




| #1[bk],#2[bk] |
//if ( ~$1(#1,#2) | ~$2(#2,#1) | ~$3(#1,#3[bk]) | ~$4(#3[bk],#1) | | ~$5(#2,#3[bk]) | ~$4(#3[bk],#2) )
if ( ~$1(#1,#2) | ~$2(#2,#1) )
	LIXO(#1,#2).,

if (^LIXO(#1,#2) & $3(#1,#3[bk]) | $4(#3[bk],#1) | $5(#2,#3[bk]) | $4(#3[bk],#2) )
	~.

if ( ^LIXO(#1,#2))
	MOD(#1,#2).


// basic dependency 1 

if ( $1(#1[bk],#2[bk]) )
        $1[bk=+](#1,#2).




//////////////////

//////////////////
// 2 keywords that are not potential bkdeps
//////////////////

if ( ^$1[bk](#1[mental,know],#2[mental,know:~]) )
	$1[bk=~](#1,#2).

// Basic dependency 2: Words that cannot build unary dependencies are possible EERQIDEPs when in relationship with importance and attitude words. Importance words can also make a potential bkdep with scope words

if ( $1(#1[nounary],#2[importance]) )
        $1[bk=+](#1,#2).

if ( $1(#1[nounary],#2[attitude]) )
        $1[bk=+](#1,#2).

if ( $1(#1[scope,level:~],#2[importance]) )
        $1[bk=+,weak=+](#1,#2).

if ( $1(#1[noun,know,level:~],#2[importance]) )
        $1[bk=+,weak=+](#1,#2).

if ( $1(#1[contr],#2[importance]) )
        $1[bk=+](#1,#2).

if ( $1(#1[importance],#2[contr]) )
        $1[bk=+](#1,#2).


//////////////////
// dependency types that don't allow the feature bk
//////////////////

// AJCOORD

if ( ^AJCOORD[bk](#1,#2) )
	~.

// NCOORD

if ( ^NCOORD[bk](#1,#2) )
	~.

// VCOORD

if ( ^VCOORD[bk](#1,#2) )
	~.

//////////////////

// indirect dependencies

// "it has been done" the parser links "it has" and "has been done"


//if ( SUBJ(#1,#2[bk]) & OBJ(#1,#3[bk]) )
//	OBJ[bk=+](#2,#3).

//if ( SUBJ(#1,#2[bk]) & NUCL[subjcompl](#1,#3[bk]) & ~EERQIDEP(#2,#3) )
if ( SUBJ(#1,#2[bk]) & NUCL(#1,#3[bk]) & ~EERQIDEP(#2,#3) )
	SUBJ[bk=+](#2,#3).

//"In contrast to what was generally believed"

if ( $1(#1[mental],#2[form:fwhat]) & PREPD(#2,#3[contr]) )
	CONTR[bk=+](#3,#1).

// dependency with the same lemma is not a potential EERQIDEP

if ( ^$1(#1,#2) & #1[lemme]::#2[lemme] )
//	$1[bk=~](#1,#2).
	~.



////////////////////////
//idiosyncrasies
////////////////////////


// certain words (wseem) when they are in a dependency with "seem", are EERQIDEPs

if ( $1(#1[form_bk:fseem],#2[wseem]) )
	EERQIDEP(#1,#2).

if ( $1(#1[wseem],#2[form_bk:fseem]) )
	EERQIDEP(#1,#2).

// first time
// This rule has been transferred to the compounds

//if ( QUANTD(#1[form_bk:ftime],#2[change,form:fone]) )
//	QUANTD[bk=+](#1,#2).

// first report

if ( QUANTD(#1[publ,noun,notfirsttime:~],#2[change,form:fone]) )
	QUANTD[bk=+](#1,#2).

//hitherto, debate, questions

| #1[bkbk] |
	EERQIDEP(#1).

// Restrictions on the cooccurence

// wscope: if the word having this feature appears with a word that does not have the feature "scope", the dependency is removed. However, if it also appears with a contr word, the bk is kept

if ( ^$1[bk](#1[wscope],#2[scope]) )
	$1[wscope=+](#1,#2).

if ( ^$1[bk](#1[scope],#2[wscope]) )
	$1[wscope=+](#1,#2).

if ( $1[bk,wscope](#1[wscope],#2[scope]) & ^$2(#1[wscope],#3[contr] ))
	$2[wscope=+](#1,#3).

if ( ^$1(#1[contr],#2[wscope] ))
	$1[wscope=+](#1,#2).

if ( $1(#1[wscope],#2[contr] ))
	$1[wscope=+](#1,#2).

if ( ^$1[bk,wscope:~](#1[wscope],#2) )
	~.

if ( ^$1[bk,wscope:~](#1,#2[wscope]) )
	~.

if ( ^$1[wscope](#1,#2) )
	$1[bk=+,wscope=~](#1,#2).

// the challenge was examined

if ( ^$1(#1[form_bk:fchallenge],#2[methodology]) | ^$1(#1[methodology],#2[form_bk:fchallenge]) )
	$1[bk=~](#1,#2).





// wwidescope: if the word having this feature appears with a word that does not have the feature "widescope", the dependency is removed

if ( ^$1[bk](#1[wwidescope],#2[widescope]) )
	$1[wwidescope=+](#1,#2).

if ( ^$1[bk](#1[widescope],#2[wwidescope]) )
	$1[wwidescope=+](#1,#2).

if ( $1[bk,wwidescope](#1[wwidescope],#2[widescope]) & ^$2(#1[wwidescope],#3[contr] ))
	$2[wwidescope=+](#1,#3).

if ( $1[bk,wwidescope](#1[wwidescope],#2[widescope]) & ^$2(#3[contr],#1[wwidescope] ))
	$2[wwidescope=+](#3,#1).

if ( $1[bk,wwidescope](#1[widescope],#2[wwidescope]) & ^$2(#3[contr],#2[wwidescope] ))
	$2[wwidescope=+](#3,#2).

if ( $1[bk,wwidescope](#1[widescope],#2[wwidescope]) & ^$2(#2[wwidescope],#3[contr] ))
	$2[wwidescope=+](#2,#3).

if ( ^$1[bk,wwidescope:~](#1[wwidescope],#2) )
	~.

if ( ^$1[bk,wwidescope:~](#1,#2[wwidescope]) )
	~.

if ( ^$1[wwidescope](#1,#2) )
	$1[bk=+,wwidescope=~](#1,#2).



// wtime

if ( ^$1[bk](#1[wtime],#2[timefact,verb:~]) ) 
	$1[bk=+,weak=+](#1,#2) .

if ( ^$1[bk](#1[timefact,verb:~],#2[wtime]) )
	$1[bk=+,weak=+](#1,#2) .

if ( ^$1[bk,weak:~](#1[wtime],#2 ) )
	~ .

if ( ^$1[bk,weak:~](#1,#2[wtime]) )
	~ .


//wcontr

if ( ^$1[bk](#1[wcontr],#2[contr:~]) )
	~ .

if ( ^$1[bk](#1[contr:~],#2[wcontr]) )
	~ .


if ( ^$1[bk](#1[wcontr],#2[contr,noun:~]) )
	~ .

if ( ^$1[bk](#1[contr,noun:~],#2[wcontr]) )
	$1[bk=+](#1,#2).

if ( ^$1(#1[wcontr],#2[contr,noun,noweak]) )
	~ .

if ( ^$1[bk](#1[contr,noun,noweak],#2[wcontr]) )
	$1[bk=+](#1,#2).


// wneg: positive words that make up a contr dependency when negated

if ( $1(#1,#2[form:fnot,toutmaj:~]) & $2(#1,#3[wneg]) )
	EERQIDEP[weak=+](#2,#3).


// wment

if ( ^$1[bk](#1[wment],#2[mental:~]) )
	~ .

if ( ^$1[bk](#1[mental:~],#2[wment]) )
	~ .

// wknow

if ( ^$1[bk](#1[wknow],#2[know:~]) )
	~ .

if ( ^$1[bk](#1[know:~],#2[wknow]) )
	~ .

// wmentsco

if ( ^$1[bk](#1[wment],#2[mentsco:~]) )
	~ .

if ( ^$1[bk](#1[mentsco:~],#2[wment]) )
	~ .

// "first" + verb

if ( ^$1[bk](#1[verb,form_bk:~fevidence],#2[form_bk:ffirst]) )
	~.

if ( ^$1[bk](#1[verb,form_bk:~fevidence],#2[form:fone,ord]) )
	~.

if ( ^$1[bk](#1[form:fone,ord],#2[verb,form_bk:~fevidence]) )
	~.

// "recognition" is very ambiguous. It is accepepted only in a dependency with a word that has the feature "incr" or "timefact"

if ( ^$1[bk](#1[form_bk:frecognition],#2) | ^$1[bk](#1,#2[form_bk:frecognition]) )
	~.


if ( ^$1(#1[form_bk:frecognition],#2[incr]) | ^$1(#1[incr],#2[form_bk:frecognition]) )
	$1[bk=+](#1,#2).

if ( ^$1(#1[form_bk:frecognition],#2[timefact]) | ^$1(#1[timefact],#2[form_bk:frecognition]) )
	$1[bk=+](#1,#2).

//"accumulate" is a "change" word, but it can only be coupled with words that can "grow":

if ( ^$1[bk](#1[nogrow],#2[wnogrow]) )
	~.

if ( ^$1[bk](#1[wnogrow],#2[nogrow]) )
	~.





//////////////////

// Unary dependencies: for important words for which either no dependency is calculated in the general grammar or are in relationship with a non-marked word

| #1[contr,form:~fnot,toutmaj:~,form:~fno,form_bk:~flittle,wscope:~,nounary:~] |
if ( ~$1[bk](#1[contr,form:~fnot,toutmaj:~,form:~fno,form_bk:~flittle],?) & ~$2[bk](?,#1[contr,form:~fnot,toutmaj:~,form:~fno]) )
	MAIN[bk=+,weak=+](#1).
	
| #1[attitude,nounary:~] |
if ( ~$1[bk](#1[attitude],?) & ~$2[bk](?,#1[attitude]) )
	MAIN[bk=+,weak=+](#1).

| #1[form:fwhile,contr,func:~,wment:~] |
	MAIN[bk=+,weak=+](#1).

// challenge when it is vprog

| #1[form_bk:fchallenge,vprog] |
if ( ~$1[bk](#1[form_bk:fchallenge,vprog],?) & ~$2[bk](?,#1[form_bk:fchallenge,vprog]) )
	MAIN[bk=+,weak=+](#1).

// exceptions wscope

if ( ^$1[bk](#1[wscope]) )
	~ .

// exceptions wment

if ( ^$1[bk](#1[wment]) )
	~ .

// If a word consituting a unary dependency is an argument in a dependency, the unary dependency is deleted

if (^MAIN[bk,weak](#1) & $1[bk](#1,#2) )
	~.

if (^MAIN[bk,weak](#2) & $1[bk](#1,#2) )
	~.



// If a sentence just contains a dependency with 1 importance argument and one uanry dependency, it is not a potential weak bkdep

if ( ^$1[bk](#1[importance],#2[contr:~]) & $2[bk](#3) & ~$3[bk](#4[importance:~],#5) )
	$1[bk=~](#1,#2).

if ( ^$1[bk](#1[contr:~],#2[importance]) & $2[bk](#3) & ~$3[bk](#4,#5[importance:~]) )
	$1[bk=~](#1,#2).

if ( ^$1[bk](#1[importance],#2[contr,func]) & $2[bk](#3) & ~$3[bk](#4[importance:~],#5) )
	$1[bk=~](#1,#2).

if ( ^$1[bk](#1[contr,func],#2[importance]) & $2[bk](#3) & ~$3[bk](#4,#5[importance:~]) )
	$1[bk=~](#1,#2).



////////////////////

// weak EERQIDEP

// just "possibility"

if ( ^$1[bk](#1[possibility],#2) )
	$1[bk=+,weak=+](#1,#2) .

if ( ^$1[bk](#1,#2[possibility]) )
	$1[bk=+,weak=+](#1,#2) .

// dependency with arguments of the same type

if ( ^$1[bk](#1[scope],#2[scope]) )
	$1[bk=+,weak=+](#1,#2) .
	
if ( ^$1[bk](#1[timefact],#2[timefact]) )
	$1[bk=+,weak=+](#1,#2) .
	
if ( ^$1[bk](#1[change],#2[change]) )
	$1[bk=+,weak=+](#1,#2) .
	
if ( ^$1[bk](#1[mental],#2[mental]) )
	$1[bk=+,weak=+](#1,#2) .
	
if ( ^$1[bk](#1[contr,mental:~,change:~,know:~],#2[contr,mental:~,change:~,know:~]) )
	$1[bk=+,weak=+](#1,#2) .

// subject dependencies with arguments of the same kind are not potential EERQIDEPs


if ( ^SUBJ[bk,weak](#1[scope],#2[scope]) )
	SUBJ[bk=~,weak=~](#1,#2) .
	
if ( ^SUBJ[bk,weak](#1[timefact],#2[timefact]) )
	SUBJ[bk=~,weak=~](#1,#2) .
	
if ( ^SUBJ[bk,weak](#1[change],#2[change]) )
	SUBJ[bk=~,weak=~](#1,#2) .
	
if ( ^SUBJ[bk,weak](#1[mental],#2[mental]) )
	SUBJ[bk=~,weak=~](#1,#2) .
	
if ( ^SUBJ[bk,weak](#1[contr],#2[contr]) )
	SUBJ[bk=~,weak=~](#1,#2) .

if ( ^SUBJATTR[bk,weak](#1[scope],#2[scope]) )
	SUBJATTR[bk=~,weak=~](#1,#2) .
	
if ( ^SUBJATTR[bk,weak](#1[timefact],#2[timefact]) )
	SUBJATTR[bk=~,weak=~](#1,#2) .
	
if ( ^SUBJATTR[bk,weak](#1[change],#2[change]) )
	SUBJATTR[bk=~,weak=~](#1,#2) .
	
if ( ^SUBJATTR[bk,weak](#1[mental],#2[mental]) )
	SUBJATTR[bk=~,weak=~](#1,#2) .
	
if ( ^SUBJATTR[bk,weak](#1[contr],#2[contr]) )
	SUBJATTR[bk=~,weak=~](#1,#2) .

// certain couples of dependencies

if ( ^$1[bk](#1[mental,contr:~],#2[scope]) )
	$1[bk=+,weak=+](#1,#2) .


if ( ^$1[bk](#1[scope],#2[mental,contr:~]) )
	$1[bk=+,weak=+](#1,#2) .


if ( ^$1[bk](#1[change],#2[timefact]) )
	$1[bk=+,weak=+](#1,#2) .

if ( ^$1[bk](#1[timefact],#2[change]) )
	$1[bk=+,weak=+](#1,#2) .

//if ( ^$1[bk](#1[scope],#2[timefact]) )
//	$1[bk=+,weak=+](#1,#2) .

if ( ^$1[bk](#1[timefact],#2[scope]) )
	$1[bk=+,weak=+](#1,#2) .

if ( ^$1[bk](#1[contr,noun:~,mental:~],#2[timefact]) )
	$1[bk=+,weak=+](#1,#2) .

if ( ^$1[bk](#1[timefact],#2[contr,mental:~,noun:~]) )
	$1[bk=+,weak=+](#1,#2) .

if ( ^$1[bk](#1[timefact,adj],#2[attitude]) )
	$1[bk=+,weak=+](#1,#2) .

if ( ^$1[bk](#1[mental,know,contr:~],#2[question,contr]) || ^$1(#1[question,contr],#2[mental,know,contr:~]) )
	$1[bk=+,weak=+](#1,#2) .

// specweak: no evidence/role

if ( ^$1[bk](#1[specweak],#2[form:fno,toutmaj:~]) )
	$1[bk=+,weak=+](#1,#2) .

// "recent results may"

if ( ^$1[bk](#1[possibility],#2[scope]) & $2[bk](#2[scope],#3[timefact]) )
	$1[weak=+](#1,#2).

if ( $1[bk](#1[possibility],#2[scope]) & ^$2[bk](#2[scope],#3[timefact]) )
	$2[weak=+](#2,#3).

//(may_BK:+_MENTSCOPOSS:+_POSSIBILITY:+,results_BK:+_MENTSCOPOSS:+_MENTSCOTIME:+_MENTSCO:+_SCOPE:+)
//(results_BK:+_MENTSCOPOSS:+_MENTSCOTIME:+_MENTSCO:+_SCOPE:+,Recent_BK:+_MENTSCOTIME:+_TIMEFACT:+)


// "no contradiction" - not a EERQIDEP, and the other dependencies with "contradiction" don't count either

| ?{#1[contr,form:fno,toutmaj:~],?*,#2[contr,noun]} |
if ( ^$1[bk](?,#2) )
	~ .

| ?{#1[contr,form:fno,toutmaj:~],?*,#2[contr,noun]} |
if ( ^$1[bk](#2,?) )
	~ .

// if one argument of the dependency has the feature "weak", the dependency becomes weak

if ( ^$1[bk](#1[weak],#2) )
	$1[bk=+,weak=+](#1,#2) .

if ( ^$1[bk](#1,#2[weak]) )
	$1[bk=+,weak=+](#1,#2) .

// exception: amazing discovery

if ( ^$1[bk,weak](#1[attitude],#2[widescope]) | ^$1[weak](#1[widescope],#2[attitude]) )
	$1[bk=+,weak=~](#1,#2) .
	

// if a sentence contains just 1 negation with "not", the dependency is weak

if ( ^$1[bk](#1,#2[form:fnot,toutmaj:~]) )
	$1[bk=+,weak=+](#1,#2) .

//////////////////////////////
// noweak
////////////////////////////

// If an argument of a weak dependency has the feature "noweak", the 
// dependency is not weak any more. If 1 of the arguments of a EERQIDEP has the feature noweak, and the other argument is a possibility, the dependency is still weak.


if ( ^$1[weak](#1[noweak],#2[possibility:~]) | ^$1[weak](#1[possibility:~],#2[noweak]) )
	$1[weak=~](#1,#2).





/////////////////////////////////////
// Marking EERQIDEP's
/////////////////////////////////////



// If besides a weak dependency, a sentence just contains a dependency
// whose only argument has the feature "attitude", both dependencies
// will be EERQIDEPs, and get the feature "attitude"

if ( $1[weak](#1) & ^$2(#2[attitude]) & ~$1[bk,weak:~](#3,#4))
	$2[attitude=+,weak=~](#2).

if ( $1[weak](#1) & ^$2(#2[attitude]) & ~$1[bk,weak:~](#3))
	$2[attitude=+,weak=~](#2).

if ( ^$1[weak](#1) & $2(#2[attitude]) & ~$1[bk,weak:~](#3,#4) )
	$1[attitude=+,weak=~](#1).

if ( ^$1[weak](#1) & $2(#2[attitude]) & ~$1[bk,weak:~](#3) )
	$1[attitude=+,weak=~](#1).

if ( $1[weak](#1,#2) & ^$2(#3[attitude]) & ~$1[bk,weak:~](#4,#5) )
	$2[attitude=+,weak=~](#3).

if ( $1[weak](#1,#2) & ^$2(#3[attitude]) & ~$1[bk,weak:~](#4) )
	$2[attitude=+,weak=~](#3).

if ( ^$1[weak](#1,#2) & $2(#3[attitude]) & ~$1[bk,weak:~](#4,#5) )
	$1[attitude=+,weak=~](#1,#2).

if ( ^$1[weak](#1,#2) & $2(#3[attitude]) & ~$1[bk,weak:~](#4) )
	$1[attitude=+,weak=~](#1,#2).

if ( $1[attitude](#1) )
	EERQIDEP[attitude=+](#1).

if ( $1[attitude](#1,#2) )
	EERQIDEP[attitude=+](#1,#2).

//if ( ^EERQIDEP[attitude](#1) & $1[attitude:~,bk](#2) )
//	~.

//if ( ^EERQIDEP[attitude](#1) & $1[attitude:~,bk](#2,#3) )
//	~.

//if ( ^EERQIDEP[attitude](#1,#2) & $1[attitude:~,bk](#3) )
//	~.

//if ( ^EERQIDEP[attitude](#1,#2) & $1[attitude:~,bk](#3,#4) )
//	~.

// if 2 importance words are syntactic relationship, the dependency gets the feature attitude

if ( $1(#1[importance],#2[importance]) )
	EERQIDEP[attitude=+](#1,#2).


// if the sentence contains other bk-dependencies besides a weak one, the sentence is selected

//a) if the sentence contains a non-weak bk dependency, the sentence is selected


if ($1[bk,weak:~](#1,#2))
	EERQIDEP(#1,#2).

if (^$1[bk,weak](#1,#2) & EERQIDEP(#3,#4))
	EERQIDEP[weak=~,bk=~](#1,#2).

if (^$1[bk,weak](#1) & EERQIDEP(#3,#4))
	EERQIDEP[weak=~,bk=~](#1).

if (^$1[bk,weak](#1,#2) & EERQIDEP(#3))
	EERQIDEP[weak=~,bk=~](#1,#2).

if (^$1[bk,weak](#1) & EERQIDEP(#2))
	EERQIDEP[weak=~,bk=~](#1).


// b) if the sentence contains several weak dependencies, the sentence is selected


if (~EERQIDEP(#1,#2) & $1[bk,weak](#1,#2) & $2[bk,weak](#3,#4) &  (#1<#3 | #3<#1 | #2<#4 | #4<#2) )
	EERQIDEP(#1,#2).

if (~EERQIDEP(#3,#4) & $1[bk,weak](#1,#2) & $2[bk,weak](#3,#4) &  (#1<#3 | #3<#1 | #2<#4 | #4<#2) )
	EERQIDEP(#3,#4).


if (~EERQIDEP(#1,#2) & $1[bk,weak](#1,#2) & $2[bk,weak](#3) & (#1<#3 | #3<#1 | #2<#3 | #3<#2 ))
	EERQIDEP(#1,#2).

if (~EERQIDEP(#3) & $1[bk,weak](#1,#2) & $2[bk,weak](#3) & (#1<#3 | #3<#1 | #2<#3 | #3<#2 ) )
	EERQIDEP(#3).

if (~EERQIDEP(#1) & $1[bk,weak](#1) & $2[bk,weak](#2) & (#1<#2 | #2<#1) )
	EERQIDEP(#1).

if (~EERQIDEP(#2) & $1[bk,weak](#1) & $2[bk,weak](#2) & (#1<#2 | #2<#1) )
	EERQIDEP(#2).


/////////////////////////////////////

// if the sentence contains EERQIDEP's that only contain "mental" and "scope" arguments, the sentence is not selected


if ( ^EERQIDEP(#1[mentsco],#2[mentsco]) )
	EERQIDEP[mentsco=+](#1,#2).

if ( ^EERQIDEP[mentsco](#1,#2) &  EERQIDEP[mentsco:~](?,?) )
	EERQIDEP[mentsco=~](#1,#2) .

if ( ^EERQIDEP[mentsco](#1,#2) &  EERQIDEP[mentsco:~](?) )
	EERQIDEP[mentsco=~](#1,#2) .

if ( ^EERQIDEP[mentsco](#1,#2) )
	~ .

// if the sentence contains EERQIDEP's that only contain "mental" and "contr" arguments, the sentence is not selected


if ( ^EERQIDEP(#1[mentcont,func],#2[mentcont,func:~]) )
	EERQIDEP[mentcont=+](#1,#2).

if ( ^EERQIDEP(#1[mentcont,func:~],#2[mentcont,func]) )
	EERQIDEP[mentcont=+](#1,#2).

if ( ^EERQIDEP[mentcont](#1,#2) &  EERQIDEP[mentcont:~](?,?) )
	EERQIDEP[mentcont=~](#1,#2) .

if ( ^EERQIDEP[mentcont](#1,#2) &  EERQIDEP[mentcont:~](?) )
	EERQIDEP[mentcont=~](#1,#2) .


if ( ^EERQIDEP[mentcont](#1,#2) )
	~ .


// If a sentence contains EERQIDEP's that only contain CONTR arguments that have the feature FUNC, the sentence is not selected

if ( ^EERQIDEP(#1[func,mental:~,change:~]) )
	EERQIDEP[contr=+](#1).

if ( ^EERQIDEP[contr](#1) & EERQIDEP[contr:~](#2,#3) )
	EERQIDEP[contr=~](#1).

if ( ^EERQIDEP[contr](#1) & EERQIDEP[contr:~](#2) & ~EERQIDEP[contr](#2) )
	EERQIDEP[contr=~](#1).

if ( ^EERQIDEP[contr](#1) )
	~ .


// If a sentence besides unary contr+func dependencies only contains dependencies that contain an argument with the "possibility" feature, the sentence is not selected


if ( ^EERQIDEP(#1[possibility],#2) & EERQIDEP(#3[contr,func]) )
	EERQIDEP[test=+](#1,#2).


if ( ^EERQIDEP(#1,#2[possibility]) & EERQIDEP(#3[contr,func]) )
	EERQIDEP[test=+](#1,#2).

if ( ^EERQIDEP[test](#1,#2) & EERQIDEP(#3,#4) )
	EERQIDEP[test=~](#1,#2).


if ( ^EERQIDEP[test](#1,#2) & EERQIDEP(#3[contr:~,func:~]) )
	EERQIDEP[test=~](#1,#2).

if ( ^EERQIDEP[test](#1,#2) )
	~ .



/////////////////////////////////////
// Giving features to change of direction sentences
/////////////////////////////////////


// A EERQIDEP that has an "importance" argument gets the feature "emph"

if ( ^EERQIDEP(#1[contr:~],#2[importance]) | ^EERQIDEP(#1[importance],#2[contr:~])   )
	EERQIDEP[emph=+](#1,#2).

if ( ^EERQIDEP(#1[contr,func],#2[importance]) | ^EERQIDEP(#1[importance],#2[contr,func])   )
	EERQIDEP[emph=+](#1,#2).

if ( ^EERQIDEP(#1[contr,func:~],#2[importance]) | ^EERQIDEP(#1[importance],#2[contr,func:~])   )
	EERQIDEP(#1,#2).

// more complicated than previously thought - must be refined

//| #5[form_bk:fthan] |
//if ( EERQIDEP(#1[old],#2) | EERQIDEP(#1,#2[old]) | $1(#1[old],#2[publ]) | $1(#1[publ],#2[old]) & MOD[pre](#3[partpas],#4[compar]) & #4<#5 )
//	EERQIDEP(#3,#4,#5).

//| #5[form_bk:fthan] |
//if ( EERQIDEP(#1[old],#2) | EERQIDEP(#1,#2[old]) | $1(#1[old],#2[publ]) | $1(#1[publ],#2[old]) & MOD[pre](#3[partpas],#4[compar]) & #4<#5 )
//	EERQIDEP(#1,#2).


//| #5[form_bk:fthan] |
//if ( EERQIDEP(#1[old],#2) | EERQIDEP(#1,#2[old]) | $1(#1[publ],#2[old]) | $1(#1[old],#2[publ]) & MOD[pre](#3[adv],#4[compar]) & #4<#5 )
//	EERQIDEP(#3,#4,#5).

//| #5[form_bk:fthan] |
//if ( EERQIDEP(#1[old],#2) | EERQIDEP(#1,#2[old]) | $1(#1[publ],#2[old]) | $1(#1[old],#2[publ]) & MOD[pre](#3[adv],#4[compar]) & #4<#5 )
//	EERQIDEP(#1,#2).


//| #5[form_bk:fthan] |
//if ( EERQIDEP(#1[old],#2) | EERQIDEP(#1,#2[old]) | $1(#1[publ],#2[old]) | $1(#1[old],#2[publ]) & MOD[pre](#3[adj],#4[compar]) & #4<#5 )
//	EERQIDEP(#3,#4,#5).

//| #5[form_bk:fthan] |
//if ( EERQIDEP(#1[old],#2) | EERQIDEP(#1,#2[old]) | $1(#1[publ],#2[old]) | $1(#1[old],#2[publ]) & MOD[pre](#3[adj],#4[compar]) & #4<#5 )
//	EERQIDEP(#1,#2).


//| #1[compar] |
//if ( ~MOD[pre](#2,#1[compar]) )
//	MAIN(#1).

//| #3[form_bk:fthan] |
//if ( MAIN(#4[compar]) & EERQIDEP(#1[old],#2) | EERQIDEP(#1,#2[old]) | $1(#1[publ],#2[old]) | $1(#1[old],#2[publ]) & #4<#3 )
//	EERQIDEP(#4,#3).

//| #3[form_bk:fthan] |
//if ( MAIN(#4[compar]) & EERQIDEP(#1[old],#2) | EERQIDEP(#1,#2[old]) | $1(#1[publ],#2[old]) | $1(#1[old],#2[publ]) & #4<#3 )
//	EERQIDEP(#1,#2).

//if ( ^MAIN(#1[compar]) )
//	~.
	


/////////////////////////////////////
// 1. Sentences containing dependencies having words with the feature "old" 
// express a change of direction if they also contain dependencies with
// the features "contr", "change" or "attitude". If this is not the case
// the sentence is marked "OLD". Such sentences are potentially
// change of direction sentences, but it is less probable than the
// sentences that contain the above-mentioned features
//////////////////////////////////////


if ( ^EERQIDEP(#1[old,contr:~,change:~,attitude:~],#2[contr:~,change:~,attitude:~]) | ^EERQIDEP(#1[contr:~,change:~,attitude:~],#2[old,contr:~,change:~,attitude:~]) )
	EERQIDEP[old=+](#1,#2).

if ( ^EERQIDEP[old](#1,#2) & EERQIDEP(#3[attitude]) | EERQIDEP(#3,#4[attitude]) | EERQIDEP(#3[attitude],#4) | EERQIDEP(#3[contr]) | EERQIDEP(#3,#4[contr]) | EERQIDEP(#3[contr],#4) | | EERQIDEP(#3,#4[change]) | EERQIDEP(#3[change],#4) )
	EERQIDEP[old=~](#1,#2).


////////////////////////////////////
// 2. Sentences containing dependencies having words with no other features
// than "mental", "scope" and "timefact", are marked TEMPSTAT, since they 
// are probably just statements about some past, present or current 
// hypotheses.
////////////////////////////////////

if ( ^EERQIDEP(#1[old,mental],#2) | ^EERQIDEP(#1,#2[old,mental]) )
	EERQIDEP[tempstat=+](#1,#2).



if ( ^EERQIDEP(#1[timefact],#2[mentscotime]) | ^EERQIDEP(#1[mentscotime],#2[timefact]) )
	EERQIDEP[tempstat=+](#1,#2).

if ( EERQIDEP[tempstat](#1,#2) & ^EERQIDEP[tempstat:~](#3[mentscotime],#4[mentscotime]) )
	EERQIDEP[tempstat=+](#3,#4).

// TEMPSTAT_OLD

if ( ^EERQIDEP[tempstat](#1[old],#2) | ^EERQIDEP[tempstat](#1,#2[old]) )
	EERQIDEP[old=+](#1,#2).

if ( ^EERQIDEP[tempstat,old](#1,#2) & ^EERQIDEP[tempstat,old:~](#1,#3) )
	EERQIDEP[old=+](#1,#3).

if ( ^EERQIDEP[tempstat,old](#1,#2) & ^EERQIDEP[tempstat,old:~](#3,#1) )
	EERQIDEP[old=+](#3,#1).

if ( ^EERQIDEP[tempstat,old](#1,#2) & ^EERQIDEP[tempstat,old:~](#2,#3) )
	EERQIDEP[old=+](#2,#3).

if ( ^EERQIDEP[tempstat,old](#1,#2) & ^EERQIDEP[tempstat,old:~](#3,#2) )
	EERQIDEP[old=+](#3,#2).

////////////////////////////////////
// 2.a "However+EERQIDEP[tempstat]" 
////////////////////////////////////

if ( ^EERQIDEP[tempstat](#1,#2) & EERQIDEP[tempstat:~](#3[however]) & ~EERQIDEP[tempstat:~](#4,#5) )
	EERQIDEP[tempstat=+,contr=+](#1,#2).	

if ( EERQIDEP[tempstat](#1,#2) & ^EERQIDEP[tempstat:~](#3[however]) & ~EERQIDEP[tempstat:~](#4,#5) )
	EERQIDEP[tempstat=+,contr=+](#3).	

if ( EERQIDEP[tempstat](#1,#2) & ^EERQIDEP[tempstat:~](#3,#4[however]) & ~EERQIDEP[tempstat:~](#4,#5) )
	EERQIDEP[tempstat=+,contr=+](#3,#4).	

//if ( EERQIDEP[tempstat](#1,#2) & ^EERQIDEP[tempstat](#3[mental,old],#4[however]) & ~EERQIDEP[tempstat:~](#4,#5) )
//	EERQIDEP[tempstat=+,contr=+](#3,#4).	

////////////////////////////////////
// end 
////////////////////////////////////

if ( ^EERQIDEP[tempstat](#1,#2) & EERQIDEP[tempstat:~,emph:~](#3,#4) | EERQIDEP[tempstat:~](#5) )
	EERQIDEP[tempstat=~,contr=~](#1,#2).
	
if ( ^EERQIDEP[tempstat](#1) & EERQIDEP[tempstat:~,emph:~](#2,#3) | EERQIDEP[tempstat:~](#4) )
	EERQIDEP[tempstat=~,contr=~](#1).


	
////////////////////////////////////
// 3. Sentences containing dependencies having words with no other features
// than "mental", "scope" and "possibility", are marked POSTAT, since they 
// are probably just statements about some past, present or current 
// hypotheses.
////////////////////////////////////

if ( ^EERQIDEP(#1[possibility],#2[mentscoposs]) | ^EERQIDEP(#1[mentscoposs],#2[possibility]))
	EERQIDEP[postat=+](#1,#2).

if ( EERQIDEP[postat](#1,#2) & ^EERQIDEP[postat:~,emph:~](#3[mentscoposs],#4[mentscoposs]) )
	EERQIDEP[postat=+](#3,#4).

if ( EERQIDEP[postat](#1,#2) & ^EERQIDEP[postat:~,emph:~](#3[mental],#4[func,contr]) )
	EERQIDEP[postat=+](#3,#4).

if ( EERQIDEP[postat](#1,#2) & ^EERQIDEP[postat:~,emph:~](#3[func,contr],#4[mental]) )
	EERQIDEP[postat=+](#3,#4).

if ( EERQIDEP[postat](#1,#2) & ^EERQIDEP(#3[func,contr]) )
	EERQIDEP[postat=+](#3).

if ( ^EERQIDEP[postat](#1,#2) & EERQIDEP[postat:~,emph:~,tempstat:~,old:~](#3,#4) | EERQIDEP[postat:~](#3) )
	EERQIDEP[postat=~](#1,#2).

// open possibility

if ( ^EERQIDEP(#1[p_open],#2[possibility]) | ^EERQIDEP(#1[possibility],#2[p_open]) )
	EERQIDEP[postat=+](#1,#2).


////////////////////////////////////
// 4. Some sentences just draw our attention to the fact that a
// phenomenon is unknown. In this case the sentence is marked NOSTAT.
////////////////////////////////////

////////////////////////////////////
// 4.a. dependency type: SUBJ or SUBJATTR(scope,know+contr)
////////////////////////////////////

if ( ^EERQIDEP(#1[scope],#2[know,contr]) & SUBJ[pre](#1[scope],#2[know,contr]) | SUBJATTR(#1[scope],#2[know,contr]) | MOD[pre](#1[scope],#2[know,contr]) | NUCL[pre](#1[scope],#2[know,contr]) )
	EERQIDEP[nostat=+](#1,#2).


if ( ^EERQIDEP(#1[know,contr:~,partpas],#2[form:fnot,toutmaj:~]) )
	EERQIDEP[nostat=+](#1,#2).
	

////////////////////////////////////
// 4.b. dependency type: EERQIDEP(cop+timefact,know+contr)
////////////////////////////////////

if ( ^EERQIDEP(#1[cop,timefact],#2[know,contr]) )
	EERQIDEP[nostat=+](#1,#2).


////////////////////////////////////
// 4.c. dependency type: EERQIDEP(scope;mental,fno) (no evidence)
////////////////////////////////////

if (^EERQIDEP(#1[scope],#2[form:fno,toutmaj:~]) | ^EERQIDEP(#1[noun,mental],#2[form:fno,toutmaj:~]))
	EERQIDEP[nostat=+](#1,#2).


////////////////////////////////////
// 4.d. dependency type: EERQIDEP(know,nocompl) (no studies)
////////////////////////////////////

if ( ^EERQIDEP(#1[know,nocomp]) )
	EERQIDEP[nostat=+](#1).

if ( ^EERQIDEP(#1[know,nocomp],#2) )
	EERQIDEP[nostat=+](#1,#2).

if ( ^EERQIDEP(#1,#2[know,nocomp]) )
	EERQIDEP[nostat=+](#1,#2).

if ( ^EERQIDEP(#1[know,nocomp]) & ~EERQIDEP(#1[know,nocomp]) & #1::#1)
	EERQIDEP[nostat=+](#1).

if ( ^EERQIDEP(#1[know,nocomp],#2) & ~EERQIDEP(#1[know,nocomp],#2) & #1::#1 & #2::#2 )
	EERQIDEP[nostat=+](#1,#2).

if ( ^EERQIDEP(#1,#2[know,nocomp]) & ~EERQIDEP(#1,#2[know,nocomp]) & #1::#1 & #2::#2 )
	EERQIDEP[nostat=+](#1,#2).
////////////////////////////////////
// 4.e. dependency type: EERQIDEP(scope,form_bk:flittle) 
////////////////////////////////////

if ( ^EERQIDEP(#1[scope],#2[form_bk:flittle]) )
	EERQIDEP[nostat=+](#1,#2).

////////////////////////////////////
// 4.f. dependency type: EERQIDEP(form_bk:flittle,know) 
////////////////////////////////////

if ( ^EERQIDEP(#1[form_bk:flittle],#2[know]) )
	EERQIDEP[nostat=+](#1,#2).

if ( ^EERQIDEP(#1[know],#2[form_bk:flittle]) )
	EERQIDEP[nostat=+](#1,#2).

////////////////////////////////////
// 4.g. dependency type: EERQIDEP(mentscotime,mentscotime) EERQIDEP(know,contr)
////////////////////////////////////

if ( ^EERQIDEP(#1[mentscotime],#2[mentscotime]) & EERQIDEP(#3[know,contr]) )
	EERQIDEP[nostat=+](#1,#2).
	
if ( EERQIDEP(#1[mentscotime],#2[mentscotime]) & ^EERQIDEP(#3[know,contr]) )
	EERQIDEP[nostat=+](#3).

if ( ^EERQIDEP[nostat:~](#1[mentscotime],#2[mentscotime]) & EERQIDEP[nostat](#3,#4) )
	EERQIDEP[nostat=+](#1,#2).

////////////////////////////////////
// 4.h. dependency type: EERQIDEP(know) EERQIDEP(know,contr,adv) "poorly understood"
////////////////////////////////////

if ( ^EERQIDEP(#1[know],#2[know,contr,adv]) )
	EERQIDEP[nostat=+](#1,#2).

if ( ^EERQIDEP(#1[know,contr,adv],#2[know]) )
	EERQIDEP[nostat=+](#1,#2).

////////////////////////////////////
// 4.h. dependency type: EERQIDEP(know;mental;contr,~contr) " largly uncharacterized"
////////////////////////////////////

if ( ^EERQIDEP(#1[mental,know,contr],#2[contr:~]) || ^EERQIDEP(#1[contr:~],#2[mental,know,contr]) )
	EERQIDEP[nostat=+](#1,#2).

	

////////////////////////////////////
// 4.h. "However ... unknown" dependency type: EERQIDEP(know+contr); 
// EERQIDEP(however) 
////////////////////////////////////

if ( ^EERQIDEP(#1[contr,know]) & EERQIDEP(#2[however]) )
	EERQIDEP[nostat=+,contr=+](#1).
	
if ( EERQIDEP(#1[contr,know]) & ^EERQIDEP(#2[however]) )
	EERQIDEP[nostat=+,contr=+](#2).

////////////////////////////////////
// 4.i. nostat + EERQIDEP(mentscotime,mentscotime)
//////////////////////////////////////

if (EERQIDEP[nostat](#1,#2) & ^EERQIDEP(#3[mentscotime],#4[mentscotime]) )
	EERQIDEP[nostat=+](#3,#4).


////////////////////////////////////
// 5. staknow: sentences that indicate the state of knowledge at a 
// certain time. Dependency type: EERQIDEP(know;time,old:~)
////////////////////////////////////


if (^EERQIDEP[old:~](#1[know],#2[timefact,old:~]) )
	EERQIDEP[statknow=+](#1,#2).

if (^EERQIDEP[old:~](#1[timefact,old:~,form:fhave],#2[know]) )
	EERQIDEP[statknow=+](#1,#2).

//if ( EERQIDEP[statknow](#1,#2) & ^EERQIDEP[statknow:~](#3) )
//	EERQIDEP[statknow=+](#3).

//if ( EERQIDEP[statknow](#1,#2) & ^EERQIDEP[statknow:~](#3,#4) )
//	EERQIDEP[statknow=+](#3,#4).


////////////////////////////////////
//6. EERQIDEP_with_feature+however: If a sentence contains one or several
// featured EERQIDEPs, plus "however", and no other EERQIDEPs, "however" should
// also get the feature, and all the dependencies should also get the
// feature "contr"
////////////////////////////////////


////////////////////////////////////
// 6.a "However+EERQIDEP[nostat]" 
////////////////////////////////////

if ( ^EERQIDEP[nostat](#1,#2) & EERQIDEP[nostat:~](#3[however]) )
	EERQIDEP[nostat=+,contr=+](#1,#2).	

if ( EERQIDEP[nostat](#1,#2) & ^EERQIDEP[nostat:~](#3[however]) )
	EERQIDEP[nostat=+,contr=+](#3).	

if ( ^EERQIDEP[nostat](#1,#2) & EERQIDEP[nostat:~](#3,#4[however]) )
	EERQIDEP[nostat=+,contr=+](#1,#2).	

if ( EERQIDEP[nostat](#1,#2) & ^EERQIDEP[nostat:~](#3,#4[however]) )
	EERQIDEP[nostat=+,contr=+](#3,#4).	

if ( ^EERQIDEP[nostat](#1) & EERQIDEP[nostat:~](#2[however]) )
	EERQIDEP[contr=+](#1).

if ( EERQIDEP[nostat](#1) & ^EERQIDEP[nostat:~](#2[however]) )
	EERQIDEP[contr=+,nostat=+](#2).

if ( EERQIDEP[nostat](#1) & ^EERQIDEP[nostat:~](#2,#3[however]) )
	EERQIDEP[contr=+,nostat=+](#2,#3).

if ( ^EERQIDEP[nostat](#1) & EERQIDEP[nostat:~](#2,#3[however]) )
	EERQIDEP[contr=+](#1).

if ( ^EERQIDEP(#1[know,contr]) & EERQIDEP(#2,#3[however]) )
	EERQIDEP[nostat=+,contr=+](#1).

if ( EERQIDEP(#1[know,contr]) & ^EERQIDEP(#2,#3[however]) )
	EERQIDEP[nostat=+,contr=+](#2,#3).

if ( ^EERQIDEP[nostat](#1,#2) & EERQIDEP[nostat,contr](#3) )
	EERQIDEP[contr=+](#1,#2).

if ( ^EERQIDEP[nostat,contr](#1,#2) & EERQIDEP[nostat:~,emph:~](#3,#4) )
	EERQIDEP[nostat=~,contr=~](#1,#2).

if ( ^EERQIDEP[nostat,contr](#1,#2) & EERQIDEP[nostat:~](#3) )
	EERQIDEP[nostat=~,contr=~](#1,#2).

if ( ^EERQIDEP[nostat,contr](#1) & EERQIDEP[nostat:~,emph:~](#2,#3) )
	EERQIDEP[nostat=~,contr=~](#1).

if ( ^EERQIDEP[nostat,contr](#1) & EERQIDEP[nostat:~](#2) )
	EERQIDEP[nostat=~,contr=~](#1).

// if a dependency like "previously[timefact,old] unknown[know,contr]" gets the feature nostat, it should be deleted

if ( ^EERQIDEP[nostat](#1[timefact,old],#2[know,contr]) | ^EERQIDEP[nostat](#1[know,contr],#2[timefact,old]) )
	EERQIDEP[nostat=~](#1,#2).

// If besides "nostat" dependencies a sentence only contains an "attitude"
// dependency that just has 1 argument, all the dependencies get the feature
// "nostat" and "attitude"

if ( ^EERQIDEP[nostat](#1,#2) & EERQIDEP(#3[attitude]) )
	EERQIDEP[attitude=+](#1,#2).

if ( EERQIDEP[nostat](#1,#2) & ^EERQIDEP(#3[attitude]) )
	EERQIDEP[nostat=+,attitude=+](#3).

if ( ^EERQIDEP[nostat](#1) & EERQIDEP(#2[attitude]) )
	EERQIDEP[attitude=+](#1).

if ( EERQIDEP[nostat](#1) & ^EERQIDEP(#2[attitude]) )
	EERQIDEP[nostat=+,attitude=+](#2).

// If a sentence only contains dependecies that have an argument whose feature is FUNC, and the other argument of the dependency is not WIDESCOPE, the sentence should not be selected


if ( ^EERQIDEP(#1[func],#2[widescope:~]) | ^EERQIDEP(#1[know:~,widescope:~],#2[func]) )
	EERQIDEP[test=+](#1,#2).

if ( ^EERQIDEP(#1[func]) )
	EERQIDEP[test=+](#1).

if ( ^EERQIDEP[test](#1,#2) & EERQIDEP[test:~](#3,#4) )
	EERQIDEP[test=~](#1,#2).


if ( ^EERQIDEP[test](#1,#2) & EERQIDEP[test:~](#3) )
	EERQIDEP[test=~](#1,#2).


if ( ^EERQIDEP[test](#1) & EERQIDEP[test:~](#2,#3) )
	EERQIDEP[test=~](#1).


if ( ^EERQIDEP[test](#1) & EERQIDEP[test:~](#2) )
	EERQIDEP[test=~](#1).

if ( ^EERQIDEP[test](#1,#2) )
	~.

if ( ^EERQIDEP[test](#1) )
	~.


// If a sentence contains just 1 EERQIDEP(scope,change) or 1 EERQIDEP(change,scope),
// it gets the feature GROW

if ( ^EERQIDEP(#1[scope],#2[incr,know:~]) | ^EERQIDEP(#1[incr,know:~],#2[scope]) )
	EERQIDEP[grow=+](#1,#2).

if ( ^EERQIDEP(#1[mental],#2[incr,know:~]) | ^EERQIDEP(#1[incr,know:~],#2[mental]) )
	EERQIDEP[grow=+](#1,#2).

if ( EERQIDEP[grow](#1,#2) & ^EERQIDEP[grow:~](#3,#4) )
	EERQIDEP[grow=+](#3,#4).

if ( EERQIDEP[grow](#1,#2) & ^EERQIDEP[grow:~](#3) )
	EERQIDEP[grow=+](#3).

// If a sentence contains just 1 EERQIDEP and it contains the word "first", the
// EERQIDEP gets the feature "first"

if ( ^EERQIDEP(#1,#2[form_bk:ffirst]) | ^EERQIDEP(#1,#2[form:fone, numer,change]) )
	EERQIDEP[first=+](#1,#2).

// The compound "first time" turns the sentence into a "first"

if ( ^$1(#1[bkbk,form_bk:ffirst]) )
	EERQIDEP[first=+](#1).

// No idea why these 2 rules were made:

//if ( ^EERQIDEP[first](#1,#2) & EERQIDEP[first:~](#3,#4) )
//	EERQIDEP[first=~](#1,#2).

//if ( ^EERQIDEP[first](#1,#2) & EERQIDEP[first:~](#3) )
//	EERQIDEP[first=~](#1,#2).


// If a EERQIDEP sentence contains a contradiction that is weaker than a change of direction, it is marked WEAKCONTR. These sentences have dependencies that contain a mental and a scope argument, as well as a cont,func


if ( EERQIDEP(#1[mental],#2[scope]) & ^EERQIDEP(#3[contr,func]) )
	EERQIDEP[weakcontr=+](#3).

if ( ^EERQIDEP(#1[mental],#2[scope]) & EERQIDEP(#3[contr,func]) )
	EERQIDEP[weakcontr=+](#1,#2).


if ( EERQIDEP[weakcontr:~,emph:~](#1,#2) & ^EERQIDEP[weakcontr](#3) )
	EERQIDEP[weakcontr=~](#3).


if ( EERQIDEP[weakcontr:~,emph:~](#1,#2) & ^EERQIDEP[weakcontr](#3,#4) )
	EERQIDEP[weakcontr=~](#3,#4).


if ( ^EERQIDEP[weakcontr](#1,#2) & EERQIDEP[weakcontr:~](#3) )
	EERQIDEP[weakcontr=~](#1,#2).


if ( ^EERQIDEP[weakcontr](#1) & EERQIDEP[weakcontr:~](#2) )
	EERQIDEP[weakcontr=~](#1).

// If a sentence just contains unary dependencies and one of them is contr, the dependecy is weakcontr

if ( ^EERQIDEP(#1[contr]) & EERQIDEP(#2[bkbk:~]) & #1~:#2 )
	EERQIDEP[weakcontr=+](#1).

if ( EERQIDEP[weakcontr](#1[contr]) & ^EERQIDEP(#2[bkbk:~]) & #1~:#2 )
	EERQIDEP[weakcontr=+](#2).

if ( ^EERQIDEP[weakcontr](#1) & EERQIDEP[weakcontr:~,emph:~](#2,#3) )
	EERQIDEP[weakcontr=~](#1).

if ( ^EERQIDEP[weakcontr](#1) & EERQIDEP[weakcontr:~](#2) )
	EERQIDEP[weakcontr=~](#1).

// Give the feature "novstat" to sentences that just speak about a novelty

if ( ^EERQIDEP(#1[new],#2) )
	EERQIDEP[novstat=+,tempstat=~](#1,#2).

if ( ^EERQIDEP(#1,#2[new]) )
	EERQIDEP[novstat=+,tempstat=~](#1,#2).

if ( EERQIDEP[novstat](#1,#2) & ^EERQIDEP[novstat:~](#3,#4) )
	EERQIDEP[novstat=+,tempstat=~](#3,#4).

if ( EERQIDEP[novstat](#1,#2) & ^EERQIDEP[novstat:~](#3) )
	EERQIDEP[novstat=+,tempstat=~](#3).

// Sentences that have a EERQIDEP+a level word get the feature LEVEL

if ( ^EERQIDEP(#1,#2) & LEVEL(#3) )
	EERQIDEP[level=+](#1,#2).

if ( ^EERQIDEP(#1) & LEVEL(#2) )
	EERQIDEP[level=+](#1).


////////////////////////////////////////////////////////////
//Relevant sentences: titles, synthetic sentences, last sentences
////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////
//Synthetic sentences
////////////////////////////////////////////////////////////

| TOP#1{ ?+ } |
if ( contributionsent:1 )
	SUMMARY[contribution=+](#1).

| TOP#1{ ?+ } |
if ( _nextanalyse:1 & _nextanalyse=0 )
//if ( _nextanalyse:1 )
	SUMMARY[contribution=+](#1).

//Script:

//_nextanalyse=0;


// provide evidence is art:+ : We provide evidence

Script:

iftest ( OBJ(#1[form_bk:fprovide],#2[form_bk:fevidence]) ) { #1[publ=+];}

DependencyRules:

// add the feature synth to sentences that contain 2 marked words

if ( ^$1(#1[publ],#2[deict]) )
        $1[contribution=+](#1,#2).

if ( ^$1(#1[deict],#2[publ]) )
        $1[contribution=+](#1,#2).

//if ( NUCL[passive](#1,#2[publ]) )
//	NUCL[contribution=+](#1,#2).

// we will discuss

| TOP#4{ ?+ } |
if ( SUBJ(#1,#2[deict]) & NUCL(#1,#3[publ]) )
	SUMMARY[contribution=+](#4).

// taken together/altogether/all together + scope -> synth (These results, taken together)

| #1[adv,art] |
	MAIN(#1).

| TOP#4{ ?+ } |
if ( ^MAIN(#1[adv,art]) & SUBJ(#2,#3[scope]) )
	SUMMARY[contribution=+](#4).

| TOP#4{ ?+ } |
if ( ^MAIN(#1[adv,art]) & SUBJ(#2[mental],#3[deict]) )
	SUMMARY[contribution=+](#4).

if ( MAIN(#1[adv,art]) )
	~ .
| TOP#3{ ?+ } |
if ( $1[contribution](#1) & ~SUMMARY(#2) )
	SUMMARY[contribution=+](#3).
	
| TOP#3{ ?+ } |
if ( $1[contribution](#1,#2) & ~SUMMARY(#4) )
	SUMMARY[contribution=+](#3).

//In conclusion

| TOP#3{ ?+ } |
if ( $1(#1[relword],#2[prep,maj]) )
	SUMMARY[contribution=+](#3).

////////////////////////////////////
// Last sentences
////////////////////////////////////

| #1[lastsent] |
	LASTSENT(#1).

| TOP#1{ ?+ } |
if ( LASTSENT(#2) )
	SUMMARY[lastsent=+](#1).

if ( ^SUMMARY[contribution](#1) & SUMMARY[lastsent](#2) )
	SUMMARY[contribution=+,lastsent=+](#1).

if ( SUMMARY[contribution,lastsent](#1) & ^SUMMARY[lastsent](#2) )
	~.

if ( ^LASTSENT(#2) )
	~.

///////////////////////////////
// Titles
//////////////////////////////

| TOP#1{ ?+ } |
if (@_xtd.title->Test())
	SUMMARY[title=+](#1).



// Marking viss: EERQIDEPS without a feature of with "first" or "change"


if ( ^EERQIDEP[old:~,tempstat:~,postat:~,nostat:~,weakcontr:~,statknow:~,contr:~,attitude:~,emph:~,question:~](#1,#2) )
	EERQIDEP[vis=+](#1,#2).


if ( ^EERQIDEP[old:~,tempstat:~,postat:~,nostat:~,weakcontr:~,statknow:~,contr:~,attitude:~,question:~](#1) )
	EERQIDEP[vis=+](#1).

// Surprisingly , this paper reports 

if ( $1[contribution](#1,#2) & $2(#3[attitude]) )
	EERQIDEP[vis=+](#3).
	
| TOP#3{ ?+ } |
if ( EERQIDEP(#1) & ~IMPSENT(#2) )
	IMPSENT(#3).
	
| TOP#3{ ?+ } |
if ( EERQIDEP(#1,#2) & ~IMPSENT(#4) )
	IMPSENT(#3).

if ( LEVEL(#1) & ^IMPSENT(#2) )
	IMPSENT[level=+](#2).


// Give features to IMPSENT

// If a sentence has a vis EERQIDEP, the IMPSENT is a vis

if ( EERQIDEP[vis](#1,#2) & ^IMPSENT(#4) & ~IMPSENT[vis](#5) )
	IMPSENT[vis=+](#4).

if ( EERQIDEP[vis](#3) & ^IMPSENT(#4) & ~IMPSENT[vis](#5) )
	IMPSENT[vis=+](#4).

// contrast: the best viss

// a. contr+scope

if ( ^EERQIDEP(#1[contr,question:~],#2[scope]) & IMPSENT[vis](#3) )
	EERQIDEP[contrast=+](#1,#2). 

if ( ^EERQIDEP(#1[scope],#2[contr,question:~]) & IMPSENT[vis](#3) )
	EERQIDEP[contrast=+](#1,#2). 

// b. mental+contr_scope

| #1[scope] |
if ( EERQIDEP(#1[scope],#2) | EERQIDEP(#2,#1[scope]) )
	LIXO(#1).

if ( ^EERQIDEP(#1[mental],#2[contr,question:~]) & LIXO(#4) & IMPSENT[vis](#3) )
	EERQIDEP[contrast=+](#1,#2). 

if ( ^EERQIDEP(#1[contr,question:~],#2[mental]) & LIXO(#4) & IMPSENT[vis](#3) )
	EERQIDEP[contrast=+](#1,#2).

if ( LIXO(#1) )
	~.

// c. scope+attitude_time 

| #1[timefact] |
if ( EERQIDEP(#1[timefact],#2) | EERQIDEP(#2,#1[timefact]) )
	LIXO(#1).

if ( ^EERQIDEP(#1[scope],#2[attitude]) & LIXO(#4) & IMPSENT[vis](#3) )
	EERQIDEP[contrast=+](#1,#2). 

if ( ^EERQIDEP(#1[attitude],#2[scope]) & LIXO(#4) & IMPSENT[vis](#3) )
	EERQIDEP[contrast=+](#1,#2).

if ( LIXO(#1) )
	~.

// d. scope+old_contr

| #1[contr] |
if ( EERQIDEP(#1[contr,question:~],#2) | EERQIDEP(#2,#1[contr,question:~]) | EERQIDEP(#1[contr]) )
	LIXO(#1).

if ( ^EERQIDEP(#1[scope],#2[old]) & LIXO(#4) & IMPSENT[vis](#3) )
	EERQIDEP[contrast=+](#1,#2). 

if ( ^EERQIDEP(#1[old],#2[scope]) & LIXO(#4) & IMPSENT[vis](#3) )
	EERQIDEP[contrast=+](#1,#2).

if ( LIXO(#1) )
	~.

// If a IMPSENT contains a dependency with contrast, it gets the feature contrast

if ( EERQIDEP[contrast](#1,#2) & ^IMPSENT[vis](#3) )
	IMPSENT[contrast=+](#3)

// Other features

if ( EERQIDEP[tempstat](#1,#2) & ^IMPSENT[vis:~](#3) )
	IMPSENT[tempstat=+](#3).

if ( EERQIDEP[old](#1,#2) & ^IMPSENT[vis:~](#3) )
	IMPSENT[old=+](#3).

if ( EERQIDEP[postat](#1,#2) & ^IMPSENT[vis:~](#3) )
	IMPSENT[postat=+](#3).

if ( EERQIDEP[nostat](#1,#2) & ^IMPSENT[vis:~](#3) )
	IMPSENT[nostat=+](#3).

if ( EERQIDEP[nostat](#1) & ^IMPSENT[vis:~](#3) )
	IMPSENT[nostat=+](#3).

if ( EERQIDEP[contr](#1,#2) & ^IMPSENT[vis:~](#3) )
	IMPSENT[contr=+](#3).

if ( EERQIDEP[contr](#1) & ^IMPSENT[vis:~](#3) )
	IMPSENT[contr=+](#3).

if ( EERQIDEP[weakcontr](#1,#2) & ^IMPSENT[vis:~](#3) )
	IMPSENT[weakcontr=+](#3).

if ( EERQIDEP[weakcontr](#1) & ^IMPSENT[vis:~](#3) )
	IMPSENT[weakcontr=+](#3).

if ( EERQIDEP[statknow](#1,#2) & ^IMPSENT[vis:~](#3) )
	IMPSENT[statknow=+](#3).

if ( EERQIDEP[novstat](#1,#2) & ^IMPSENT(#3) )
	IMPSENT[novstat=+](#3).

if ( EERQIDEP[grow](#1,#2) & ^IMPSENT(#3) )
	IMPSENT[grow=+](#3).

if ( EERQIDEP[first](#1,#2) & ^IMPSENT(#3) )
	IMPSENT[first=+](#3).

if ( EERQIDEP[first](#1) & ^IMPSENT(#3) )
	IMPSENT[first=+](#3).

if ( EERQIDEP[emph](#1,#2) & ^IMPSENT(#3) )
	IMPSENT[emph=+](#3).

if ( EERQIDEP[attitude](#1,#2) & ^IMPSENT[vis:~](#3) )
	IMPSENT[attitude=+](#3).

if ( EERQIDEP[attitude](#1) & ^IMPSENT[vis:~](#3) )
	IMPSENT[attitude=+](#3).

// if a IMPSENT does not have any feature and its verb whose subject is 

////////////////////////////////
// marking features of relsents
////////////////////////////////


| #1[form:fquest] |
if ( ^SUMMARY(#2) & LEVEL(#3))
	SUMMARY[question=+](#2).

| #1[questlevel] |
	LIXO(#1).

| #1[form:fquest] |
if ( ^SUMMARY(#2) & LIXO(#3) & ~SUMMARY[question](#2))
	SUMMARY[question=+](#2).

if ( ^LIXO(#1) )
	~.

| #1[possibility] |
if ( ^SUMMARY(#2))
	SUMMARY[postat=+](#2).


| #1[postat] |
if ( ^SUMMARY(#2))
	SUMMARY[postat=+](#2).

if ( ^SUMMARY(#2[future],#3[scope]) )
	SUMMARY[future=+](#2,#3).


if ( ^SUMMARY(#2[scope],#3[future]) )
	SUMMARY[future=+](#2,#3).


| #1[forneg] |
if ( ^SUMMARY(#2) )
	SUMMARY[negative=+](#2).

//| #1[form:fnot] |
if ( ^SUMMARY(#2) & $1(#1,#3[forneg,toutmaj:~]) )
	SUMMARY[negative=+](#2).

if ( ^SUMMARY(#2) & $1(#1[forneg,toutmaj:~],#3) )
	SUMMARY[negative=+](#2).

| #1[negative] |
if ( ^SUMMARY(#2) )
	SUMMARY[negative=+](#2).

| #1[question] |
if ( ^SUMMARY(#2)  & $1(#1[bk_feat],#3[question]) )
	SUMMARY[question=+](#2).

| #1[question] |
if ( ^SUMMARY(#2)  & $1(#1[question],#3[bk_feat]) )
	SUMMARY[question=+](#2).

if ( ^SUMMARY[postat:~,future:~,contr:~,question:~,title:~](#1) )
	SUMMARY[stat=+](#1).

if ( ^SUMMARY(#1) & LEVEL(#3) & ~SUMMARY[level](#1) )
	SUMMARY[level=+](#1).

//| #3[importance] |
//if ( ^SUMMARY(#1) & ~SUMMARY[strong](#1) )
//	SUMMARY[strong=+](#1).


//| #3[questlevel] |
//if ( ^SUMMARY[title](#1) & ~SUMMARY[strong](#1) )
//	SUMMARY[title=+,strong=+](#1).


//| #3[bk,possibility:~,func:~] |
//if ( ^SUMMARY[title,question,negative:~](#1) & ~SUMMARY[strong](#1) )
//	SUMMARY[title=+,strong=+](#1).

//if ( ^SUMMARY(#1) & $1[bk](#2[form:~fnot,form:~fno,negative:~]) )
//	SUMMARY[strong=+](#1).

//if ( ^SUMMARY(#1) & $1[bk](#2[form:~fnot,form:~fno,negative:~],#3[form:~fnot,form:~fno,negative:~]) )
//	SUMMARY[strong=+](#1).


////////////</////////////////
//IMPSUMMARY
////////////////////////////

// Marking relevant sentences that are EERQIDEPs - this doesn't seem to be an important category

if ( ^SUMMARY(#1) & $1(#2[level],#3[new]) )
	IMPSUMMARY[vis=+](#1).

if ( ^SUMMARY(#1) & $1(#2[new],#3[level]) )
	IMPSUMMARY[vis=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[vis](#2) )
	IMPSUMMARY[vis=+](#1).

if ( EERQIDEP[contrast](#1,#2) & ^IMPSUMMARY(#3) )
	IMPSUMMARY[contrast=+](#3).

if ( ^SUMMARY(#1) & IMPSENT[novstat](#2) )
	IMPSUMMARY[novstat=+](#1).

if ( ^IMPSUMMARY(#1) & IMPSENT[novstat](#2) )
	IMPSUMMARY[novstat=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[first](#2) )
	IMPSUMMARY[first=+](#1).

if ( ^IMPSUMMARY(#1) & IMPSENT[first](#2) )
	IMPSUMMARY[first=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[old](#2) )
	IMPSUMMARY[old=+](#1).

if ( ^IMPSUMMARY(#1) & IMPSENT[old](#2) )
	IMPSUMMARY[old=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[grow](#2) )
	IMPSUMMARY[grow=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[emph](#2) )
	IMPSUMMARY[emph=+](#1).

if ( ^IMPSUMMARY(#1) & IMPSENT[grow](#2) )
	IMPSUMMARY[grow=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[tempstat](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[tempstat=+](#1).

if ( ^IMPSUMMARY(#1) & IMPSENT[tempstat](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[tempstat=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[nostat](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[nostat=+](#1).

if ( ^IMPSUMMARY(#1) & IMPSENT[nostat](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[nostat=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[postat](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[postat=+](#1).

if ( ^IMPSUMMARY(#1) & IMPSENT[postat](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[postat=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[statknow](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[statknow=+](#1).

if ( ^IMPSUMMARY(#1) & IMPSENT[statknow](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[statknow=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[contr](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[contr=+](#1).

if ( ^IMPSUMMARY(#1) & IMPSENT[contr](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[contr=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[weakcontr](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[weakcontr=+](#1).

if ( ^IMPSUMMARY(#1) & IMPSENT[weakcontr](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[weakcontr=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[attitude](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[attitude=+](#1).

if ( ^IMPSUMMARY(#1) & IMPSENT[attitude](#2) & ~IMPSUMMARY[vis](#3) )
	IMPSUMMARY[attitude=+](#1).

if ( ^SUMMARY(#1) & IMPSENT[weakreview](#2) )
	IMPSUMMARY[weakreview=+](#1).

if ( ^IMPSUMMARY(#1) & IMPSENT[weakreview](#2) )
	IMPSUMMARY[weakreview=+](#1).

if ( IMPSUMMARY(#1) & ^IMPSENT(#2) )
	~.

if ( IMPSUMMARY(#1) & ^SUMMARY(#2) )
	~.

if ( ^IMPSUMMARY[strong](#1) )
	IMPSUMMARY[strong=~](#1).

//if ( LEVEL(#1) & ^IMPSUMMARY(#2) )
//	IMPSUMMARY[level=+](#2).
	


// This is a correction: EERQIDEP(REL)SENT having the features CONTR+OLD should have the feature VIS, CONTRAST and not TEMPSTAT or OLDSTAT

if ( ^$1[contr,old](#1) )
	$1[contr=~,old=~,tempstat=~,oldstat=~,contrast=+,vis=+](#1).

// Marking weak reviews

// grow

if ( ^IMPSENT[grow](#1) )
	IMPSENT[weakreview=+](#1).

if ( ^IMPSUMMARY[grow](#1) )
	IMPSUMMARY[weakreview=+](#1).

if ( ^IMPSENT[first](#1) )
	IMPSENT[weakreview=+](#1).

if ( ^IMPSUMMARY[first](#1) )
	IMPSUMMARY[weakreview=+](#1).

if ( ^IMPSENT[novstat,vis](#1) )
	IMPSENT[weakreview=+](#1).

if ( ^IMPSUMMARY[novstat,vis](#1) )
	IMPSUMMARY[weakreview=+](#1).

| #1[possibility] |
if ( ^IMPSENT[vis](#2) )
	IMPSENT[weakreview=+](#2).

| #1[possibility] |
if ( ^IMPSUMMARY[vis](#2) )
	IMPSUMMARY[weakreview=+](#2).

| #1[weakreview] |
if ( ^IMPSENT[vis](#2) )
	IMPSENT[weakreview=+](#2).

| #1[weakreview] |
if ( ^IMPSUMMARY[vis](#2) )
	IMPSUMMARY[weakreview=+](#2).

| #1[form:fquest] |
if ( ^IMPSENT[vis](#2) )
	IMPSENT[weakreview=+](#2).

| #1[form:fquest] |
if ( ^IMPSUMMARY[vis](#2) )
	IMPSUMMARY[weakreview=+](#2).


// If a weakreview sentence contains a bkbk and and a contr it should not be a weakreview

if ( ^IMPSENT[weakreview](#1) & EERQIDEP(#2[bkbk]) & EERQIDEP(#3[contr]) )
	IMPSENT[weakreview=~](#1)

if ( ^IMPSENT[weakreview](#1) & EERQIDEP(#2[bkbk]) & EERQIDEP(#3[contr],#4) )
	IMPSENT[weakreview=~](#1)

if ( ^IMPSENT[weakreview](#1) & EERQIDEP(#2[bkbk]) & EERQIDEP(#3,#4[contr]) )
	IMPSENT[weakreview=~](#1)




//////////////////////////////////
// translation to EERQI vocabulary
/////////////////////////////////

if ( ^SUMMARY(#1) | ^IMPSUMMARY(#1) )
   SENT[contribution=+](#1). 

////////////////////

| TOP#4{ ?+ } |
if ( ~SENT(#4) )
   SENT(#4).
 

/////////// references

// his/their work

| #1[other=+] |
if ( ^PERSON(#1) )
   ~.
// authors hold

if ( SUBJ-N(#1,#2[lemme:author]) & ^SENT(#3) )
   SENT[reference=+](#3).
   

| #1[lemme:p\.] |
if ( ^SENT(#3) )
   SENT[reference=+](#3).

| #1[lemme:pp\.] |
if ( ^SENT(#3) )
   SENT[reference=+](#3).

if ( $1(#1[other],#2[mentsco]) & ^SENT(#3) )
   SENT[reference=+](#3).

if ( $1(#2[mentsco],#1[other]) & ^SENT(#3) )
   SENT[reference=+](#3).

if ( $1(#1[other],#2[publ]) & ^SENT(#3) )
   SENT[reference=+](#3).

if ( $1(#2[publ],#1[other]) & ^SENT(#3) )
   SENT[reference=+](#3).

//////////// more contribution

if ( $1(#1[deict],#2[mentsco]) & ^SENT(#3) )
   SENT[contribution=+](#3).

if ( $1(#2[mentsco],#1[deict]) & ^SENT(#3) )
   SENT[contribution=+](#3).


//////////// translation of features into EERQI

if ( $1[contr](#1) & ^SENT(#1) )
   SENT[contr=~,contrast=+](#1).
   
if ( $1[weakcontr](#1) & ^SENT(#1) )
   SENT[weakcontr=~,contrast=+](#1).
   
if ( $1[contrast](#1) & ^SENT(#1) )
   SENT[contrast=+](#1).
   
if ( $1[negative](#1) & ^SENT(#1) )
   SENT[negative=~,contrast=+](#1).
   
if ( $1[nostat](#1) & ^SENT(#1) )
   SENT[nostat=~,contrast=+](#1).
   
if ( $1[question](#1) & ^SENT(#1) )
   SENT[question=~,contrast=+](#1).
   
if ( $1[emph](#1) & ^SENT(#1) )
   SENT[emph=~,value=+](#1).
   
if ( $1[attitude](#1) & ^SENT(#1) )
   SENT[attitude=+~,value=+](#1).
   
if ( $1[novstat](#1) & ^SENT(#1) )
   SENT[novstat=+](#1).

if ( ^SENT[contr](#1) )
   SENT[contr=~,contrast=+](#1).

if ( ^SENT[weakcontr](#1) )
   SENT[weakcontr=~,contrast=+](#1).

if ( ^SENT[negative](#1) )
   SENT[negative=~,contrast=+](#1).

if ( ^SENT[nostat](#1) )
   SENT[nostat=~,contrast=+](#1).

if ( ^SENT[question](#1) )
   SENT[question=~,contrast=+](#1).

if ( ^SENT[emph](#1) )
   SENT[emph=~,contrast=+](#1).

if ( ^SENT[attitude](#1) )
   SENT[attitude=~,contrast=+](#1).

if ( ^SENT[novstat](#1) )
   SENT[novstat=~,contrast=+](#1).




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//| np{#1[last,nokeyword:~]} |
//KEYWORD(#1).

//| np{#1[nokeyword], #2[last,nokeyword:~]} |
//KEYWORD(#2).

| np{#1[nokeyword:~], #2[last,nokeyword:~]} |
KEYWORD(#1,#2).

| np{#1[nokeyword], #2[nokeyword:~], #3[last,nokeyword:~]} |
KEYWORD(#2,#3).

if ( ^KEYWORD(#1[topicword],#2) | ^KEYWORD(#1,#2[topicword]) )
   KEYWORD[topicword=+](#1,#2).

if ( ^KEYWORD[topicword:~](#1,#2) )
   ~.

| np{#1[nokeyword:~], #2[nokeyword:~], #3[last,nokeyword:~]} |
KEYWORD(#1,#2,#3).

| np{#1[nokeyword], #2[nokeyword:~], #3[nokeyword:~], #4[last,nokeyword:~]} |
KEYWORD(#2,#3,#4).

if ( ^KEYWORD(#1[topicword],#2,#3) | ^KEYWORD(#1,#2[topicword],#3) | ^KEYWORD(#1,#2,#3[topicword]) )
   KEYWORD[topicword=+](#1,#2,#3).

if ( ^KEYWORD[topicword:~](#1,#2,#3) )
   ~.

// explanation of keywords


if ( SUBJ-N(#1,#2) & KEYWORD(#3,#2) & ^SENT[characterization:~](#4) )
  SENT[characterization=+](#4).

if ( OBJ-N(#1,#2) & KEYWORD(#3,#2) & ^SENT[characterization:~](#4) )
   SENT[characterization=+](#4).



// argumentation

// after all

| ADV[argumentation=+,contrast=+]{#1[lemme:after], #2[lemme:all]} |
  ~.

//For these kinds of reasons
//PP{For NP{these kinds}} PP{of NP{reasons}} 

| pp[argumentation=+,explanation=+]{?[lemme:for],?+}, pp[argumentation=+,explanation=+]{?*,?[last,lemme:reason]} |
  ~.

//for this reason
//PP{For NP{this reason}} 

| pp[argumentation=+,explanation=+]{?[lemme:for], ?{?*, ?[last,lemme:reason]}} |
  ~.

//| #2[lemme:I,argumentation=+] |
//if ( SUBJ-N(#1,#2) )
//   ~.


//| #1[argumentation=+] |
//if ( SUBJ-N(#1,#2[argumentation]) )
//   ~.


//Typing sentences with argumentation

| #1[explanation] |
if ( ^SENT[explanation:~](#2) )
   SENT[explanation=+](#2)

| #1[contrast] |
if ( ^SENT[contrast:~](#2) )
   SENT[contrast=+](#2)

| #1[conditional] |
if ( ^SENT[conditional:~](#2) )
   SENT[conditional=+](#2)

| #1[confirmation] |
if ( ^SENT[confirmation:~](#2) )
   SENT[confirmation=+](#2)

| #1[choice] |
if ( ^SENT[choice:~](#2) )
   SENT[choice=+](#2)


| #1[enumeration] |
if ( ^SENT[enumeration:~](#2) )
   SENT[enumeration=+](#2)


| #1[example] |
if ( ^SENT[example:~](#2) )
   SENT[example=+](#2)







///////////////////////////////////////////////////////////////////////////////
/////								    //////////
///// 	       *****   COLORING       *******                     //////////
/////						                   //////////
//////////////////////////////////////////////////////////////////////////////






| #1[keyword=+] |
if ( KEYWORD(#1,#2) )
   ~.


| #2[keyword=+] |
if ( KEYWORD(#1,#2) )
   ~.

| #1[keyword=+] |
if ( KEYWORD(#1,#2,#3) )
   ~.

| #2[keyword=+] |
if ( KEYWORD(#1,#2,#3) )
   ~.

| #3[keyword=+] |
if ( KEYWORD(#1,#2,#3) )
   ~.

| #1[keyword]{#3[keyword=+],#4[keyword=+]} |
   ~.

| #1[keyword]{#2[keyword=+],#3[keyword=+],#4[keyword=+]} |
   ~.

| #1[keyword]{#3[keyword=+]} |
   ~.

| #1[argumentation]{#3[argumentation=+],#4[argumentation=+]} |
   ~.

| #1[argumentation]{#2[argumentation=+],#3[argumentation=+],#4[argumentation=+]} |
   ~.

| #1[argumentation]{#1[argumentation=+],#2[argumentation=+],#3[argumentation=+],#4[argumentation=+]} |
   ~.

| #1[argumentation]{#3[argumentation=+]} |
   ~.

| #1[presupposition]{#3[presupposition=+],#4[presupposition=+]} |
   ~.

| #1[presupposition]{#2[presupposition=+],#3[presupposition=+],#4[presupposition=+]} |
   ~.

| #1[presupposition]{#2[presupposition=+],#3[presupposition=+],#4[presupposition=+],#4[presupposition=+]} |
   ~.

| #1[presupposition]{#3[presupposition=+]} |
   ~.


if ( IMPSENT(#1) & ~INDICATOR(#1) & ^SENT(#1) )
    ~.

if ( ^IMPSENT(#1) & ~INDICATOR(#1) )
   SENT(#1).






/////////////////////////////////
///EERQI
////////////////////////////////






/////////////////////////////////
///KEYWORDS
////////////////////////////////

//1: On the Necessity of Radical State Education: Democracy and the Common School.



|#1[lemme:necessity,topicword=+]|
	~.

|#1[lemme:democracy,topicword=+]|
	~.


|#1[lemme:education,topicword=+]|
	~.

|#1[lemme:common,topicword=+]|
	~.


|#1[lemme:school,topicword=+]|
	~.


|#1[lemme:radical,topicword=+]|
	~.


|#1[lemme:state,topicword=+]|
	~.



//2.Keyword: Cultural Diversity. A Guide Through the Debate
/

|#1[lemme:keyword,topicword=+]|
	 ~.

|#1[lemme:cultural,topicword=+]|
	~.

|#1[lemme:diversity,topicword=+]|
	~.

|#1[lemme:guide,topicword=+]|
	~.

|#1[lemme:debate,topicword=+]|
	~.
\

//3. NEW LEARNING ENVIRONMENTS AND CONSTRUCTIVISM: THE STUDENTS' PERSPECTIVE.


/
|#1[lemme:environment,topicword=+]|
	~.

|#1[lemme:constructivism,topicword=+]|
	~.

|#1[lemme:student,topicword=+]|
	~.

|#1[lemme:perspective,topicword=+]|
	~.

|#1[lemme:learning,topicword=+]|
	~.

|#1[lemme:learn,topicword=+]|
	~.

|#1[lemme:new,topicword=+]|
	~.

\

/

|#1[lemme:building,topicword=+]|
	~.	

|#1[lemme:build,topicword=+]|
	~.	
,
|#1[lemme:culture,topicword=+]|
	~.	

|#1[lemme:bottom,topicword=+]|
	~.	

|#1[lemme:educational,topicword=+]|
	~.	

|#1[lemme:origin,topicword=+]|
	~.	

|#1[lemme:federation,topicword=+]|
	~.	

|#1[lemme:worker,topicword=+]|
	~.	

|#1[lemme:writer,topicword=+]|
	~.	

|#1[lemme:community,topicword=+]|
	~.	

|#1[lemme:publisher,topicword=+]|
	~.
\

// NOUN{cultural diversity}

| noun{#1[topicword], #2[topicword]} |
  KEYWORD(#1,#2).


//| np{#1[last,nokeyword:~]} |
//KEYWORD(#1).

//| np{#1[nokeyword], #2[last,nokeyword:~]} |
//KEYWORD(#2).

| np{#1[nokeyword:~], #2[last,nokeyword:~]} |
KEYWORD(#1,#2).

| np{#1[nokeyword], #2[nokeyword:~], #3[last,nokeyword:~]} |
KEYWORD(#2,#3).

if ( ^KEYWORD(#1[topicword],#2) | ^KEYWORD(#1,#2[topicword]) )
   KEYWORD[topicword=+](#1,#2).

if ( ^KEYWORD[topicword:~](#1,#2) )
   ~.

| np{#1[nokeyword:~], #2[nokeyword:~], #3[last,nokeyword:~]} |
KEYWORD(#1,#2,#3).

| np{#1[nokeyword], #2[nokeyword:~], #3[nokeyword:~], #4[last,nokeyword:~]} |
KEYWORD(#2,#3,#4).

if ( ^KEYWORD(#1[topicword],#2,#3) | ^KEYWORD(#1,#2[topicword],#3) | ^KEYWORD(#1,#2,#3[topicword]) )
   KEYWORD[topicword=+](#1,#2,#3).

if ( ^KEYWORD[topicword:~](#1,#2,#3) )
   ~.

// explanation of keywords


if ( SUBJ-N(#1,#2) & KEYWORD(#3,#2) & ^SENT[characterization:~](#4) )
  SENT[characterization=+](#4).

if ( SUBJ-N(#1,#2) & KEYWORD(#5,#3,#2) & ^SENT[characterization:~](#4) )
  SENT[characterization=+](#4).

if ( OBJ-N(#1,#2) & KEYWORD(#3,#2) & ^SENT[characterization:~](#4) )
   SENT[characterization=+](#4).

if ( OBJ-N(#1,#2) & KEYWORD(#5,#3,#2) & ^SENT[characterization:~](#4) )
   SENT[characterization=+](#4).



// argumentation

// after all

| ADV[argumentation=+,contrast=+]{#1[lemme:after], #2[lemme:all]} |
  ~.

//For these kinds of reasons
//PP{For NP{these kinds}} PP{of NP{reasons}} 

| pp[argumentation=+,explanation=+]{?[lemme:for],?+}, pp[argumentation=+,explanation=+]{?*,?[last,lemme:reason]} |
  ~.

//for this reason
//PP{For NP{this reason}} 

| pp[argumentation=+,explanation=+]{?[lemme:for], ?{?*, ?[last,lemme:reason]}} |
  ~.

//| #2[lemme:I,argumentation=+] |
//if ( SUBJ-N(#1,#2) )
//   ~.


//| #1[argumentation=+] |
//if ( SUBJ-N(#1,#2[argumentation]) )
//   ~.


//Typing sentences with argumentation

| #1[explanation] |
if ( ^SENT[explanation:~](#2) )
   SENT[explanation=+](#2)

| #1[contrast] |
if ( ^SENT[contrast:~](#2) )
   SENT[contrast=+](#2)

| #1[conditional] |
if ( ^SENT[conditional:~](#2) )
   SENT[conditional=+](#2)

| #1[confirmation] |
if ( ^SENT[confirmation:~](#2) )
   SENT[confirmation=+](#2)

| #1[choice] |
if ( ^SENT[choice:~](#2) )
   SENT[choice=+](#2)


| #1[enumeration] |
if ( ^SENT[enumeration:~](#2) )
   SENT[enumeration=+](#2)


| #1[example] |
if ( ^SENT[example:~](#2) )
   SENT[example=+](#2)





///////////////////////////////////////////////////////////////////////////////
/////								    //////////
///// 	       *****   COLORING       *******                     //////////
/////						                   //////////
//////////////////////////////////////////////////////////////////////////////






| #1[keyword=+] |
if ( KEYWORD(#1,#2) )
   ~.


| #2[keyword=+] |
if ( KEYWORD(#1,#2) )
   ~.

| #1[keyword=+] |
if ( KEYWORD(#1,#2,#3) )
   ~.

| #2[keyword=+] |
if ( KEYWORD(#1,#2,#3) )
   ~.

| #3[keyword=+] |
if ( KEYWORD(#1,#2,#3) )
   ~.

| #1[keyword]{#3[keyword=+],#4[keyword=+]} |
   ~.

| #1[keyword]{#2[keyword=+],#3[keyword=+],#4[keyword=+]} |
   ~.

| #1[keyword]{#3[keyword=+]} |
   ~.

| #1[argumentation]{#3[argumentation=+],#4[argumentation=+]} |
   ~.

| #1[argumentation]{#2[argumentation=+],#3[argumentation=+],#4[argumentation=+]} |
   ~.

| #1[argumentation]{#1[argumentation=+],#2[argumentation=+],#3[argumentation=+],#4[argumentation=+]} |
   ~.

| #1[argumentation]{#3[argumentation=+]} |
   ~.

| #1[presupposition]{#3[presupposition=+],#4[presupposition=+]} |
   ~.

| #1[presupposition]{#2[presupposition=+],#3[presupposition=+],#4[presupposition=+]} |
   ~.

| #1[presupposition]{#2[presupposition=+],#3[presupposition=+],#4[presupposition=+],#4[presupposition=+]} |
   ~.

| #1[presupposition]{#3[presupposition=+]} |
   ~.



| #2[keyword] |
if ( ^SENT[topic:~](#1) )
   SENT[topic=+](#1)

| #2[keyword] |
if ( ^INDICATOR[topic:~](#1) )
   INDICATOR[topic=+](#1)

if ( ^SENT[emph](#1) )
   SENT[subjectivity=+,emph=~](#1)


if ( ^SENT[weakcontr](#1) )
   SENT[contrast=+,weakcontr=~](#1)
