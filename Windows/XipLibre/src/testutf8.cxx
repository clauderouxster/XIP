/*
* Xerox Research Centre Europe - Grenoble Laboratory
*
* Copyright (C) 2003 - 2010 Xerox Corporation, XRCE-Grenoble, All Rights Reserved.
* This file can only be used with the XIP library,
* it should not and cannot be used otherwise.
*/
/* --- CONTENTS ---
Project    : XIP
Version    : 10.00
filename   : testutf8.cxx
Date       : 12/08/2003
Purpose    : Conversion methods to handle UTF8 strings
Programmer : Claude ROUX
Reviewer   :
*/


#ifdef KIF_RAW
#include "kif.h"
#else
#include "parsbin.h"
#endif

#include "conversion.h"
#include "x_node.h"
#include "kifbinmap.h"

#ifdef KIF_HASH_MAP
#if defined(WIN32) || defined(MAVERICK)
#include <unordered_map>
#define hmap unordered_map
using std::unordered_map;
#else
#include <tr1/unordered_map>
#define hmap std::tr1::unordered_map
#endif
#else
#define hmap map
#endif

//------------------------------------------------------------------------

template <class Z> class hash_short {
private:
	short hashshortsz;
	short hashshortkey; // 65536/hashshortsz == 2^^hashshortkey

public:
	hash_bin<unsigned short, Z>** table;

	hash_short(short h, short k)  {
		hashshortsz = h;
		hashshortkey = k;
		table = new hash_bin<unsigned short, Z>*[hashshortsz];
		for (int i = 0; i < hashshortsz; i++)
			table[i] = NULL;
	}

	~hash_short() {
		for (int i = 0; i < hashshortsz; i++) {
			if (table[i] != NULL)
				delete table[i];
		}
		delete[] table;
	}

	bool check(ushort r) {
		int i = r >> hashshortkey;
		if (table[i] == NULL)
			return false;
		//65536/hashshortsz = hashshortsz192 = 2^^13
		r = r - (i << hashshortkey);
		return table[i]->check(r);
	}

	Z& operator [](ushort r) {
		int i = r >> hashshortkey;
		if (table[i] == NULL)
			table[i] = new hash_bin<ushort, Z>(2);

		r = r - (i << hashshortkey);
		return (*table[i])[r];
	}

	int countnull() {
		int nb = 0;
		for (int i = 0; i < hashshortsz; i++) {
			if (table[i] == NULL)
				nb++;
			else {
				for (int j = 0; j < table[i]->tsize; j++) {
					if (table[i]->table[j] == NULL)
						nb++;
				}
			}
		}
		return nb;
	}
};

//------------------------------------------------------------------------

extern double kifnan;

static int latincodetable[] = {
	133, 0x2026, 160, 0x00A0, 161, 0x00A1, 166, 0x00A6, 170, 0x00AA, 172, 0x00AC, 173, 0x00AD, 175, 0x00AF, 176, 0x00B0, 177, 0x00B1,
	181, 0x00B5, 182, 0x00B6, 183, 0x00B7, 184, 0x00B8, 186, 0x00BA, 191, 0x00BF, 215, 0x00D7, 247, 0x00F7, 223, 0x00DF, 150, 0x2013, 151, 0x2014, 171, 0x00AB,
	187, 0x00BB, 139, 0x3008, 155, 0x3009, 134, 0x2020, 135, 0x2021, 162, 0x00A2, 163, 0x00A3, 164, 0x00A4, 128, 0x20AC, 165, 0x00A5, 188, 0x00BC, 189, 0x00BD,
	190, 0x00BE, 185, 0x00B9, 178, 0x00B2, 179, 0x00B3, 39, 0x2018, 39, 0x2019, 34, 0x201C, 34, 0x201D, 0, 0 };

static int latin2codetable[] = {
	161, 0x0104, 162, 0x02D8, 163, 0x0141, 164, 0x00A4, 165, 0x013D, 166, 0x015A, 167, 0x00A7, 168, 0x00A8, 169, 0x0160, 170, 0x015E,
	171, 0x0164, 172, 0x0179, 174, 0x017D, 175, 0x017B, 176, 0x00B0, 177, 0x0105, 178, 0x02DB, 179, 0x0142, 180, 0x00B4,
	181, 0x013E, 182, 0x015B, 183, 0x02C7, 184, 0x00B8, 185, 0x0161, 186, 0x015F, 187, 0x0165, 188, 0x017A, 189, 0x02DD, 190, 0x017E,
	191, 0x017C, 192, 0x0154, 193, 0x00C1, 194, 0x00C2, 195, 0x0102, 196, 0x00C4, 197, 0x0139, 198, 0x0106, 199, 0x00C7, 200, 0x010C,
	201, 0x00C9, 202, 0x0118, 203, 0x00CB, 204, 0x011A, 205, 0x00CD, 206, 0x00CE, 207, 0x010E, 208, 0x0110, 209, 0x0143, 210, 0x0147,
	211, 0x00D3, 212, 0x00D4, 213, 0x0150, 214, 0x00D6, 215, 0x00D7, 216, 0x0158, 217, 0x016E, 218, 0x00DA, 219, 0x0170, 220, 0x00DC,
	221, 0x00DD, 222, 0x0162, 223, 0x00DF, 224, 0x0155, 225, 0x00E1, 226, 0x00E2, 227, 0x0103, 228, 0x00E4, 229, 0x013A, 230, 0x0107,
	231, 0x00E7, 232, 0x010D, 233, 0x00E9, 234, 0x0119, 235, 0x00EB, 236, 0x011B, 237, 0x00ED, 238, 0x00EE, 239, 0x010F, 240, 0x0111,
	241, 0x0144, 242, 0x0148, 243, 0x00F3, 244, 0x00F4, 245, 0x0151, 246, 0x00F6, 247, 0x00F7, 248, 0x0159, 249, 0x016F, 250, 0x00FA,
	251, 0x0171, 252, 0x00FC, 253, 0x00FD, 254, 0x0163, 255, 0x02D9,
	0, 0 };


static int latin3codetable[] = {
	161, 0x0126, 162, 0x02D8, 163, 0x00A3, 164, 0x00A4, 166, 0x0124, 167, 0x00A7, 168, 0x00A8, 169, 0x0130, 170, 0x015E, 171, 0x011E,
	172, 0x0134, 175, 0x017B, 176, 0x00B0, 177, 0x0127, 178, 0x00B2, 179, 0x00B3, 180, 0x00B4, 181, 0x00B5, 182, 0x0125,
	183, 0x00B7, 184, 0x00B8, 185, 0x0131, 186, 0x015F, 187, 0x011F, 188, 0x0135, 189, 0x00BD, 191, 0x017C, 192, 0x00C0, 193, 0x00C1,
	194, 0x00C2, 196, 0x00C4, 197, 0x010A, 198, 0x0108, 199, 0x00C7, 200, 0x00C8, 201, 0x00C9, 202, 0x00CA, 203, 0x00CB, 204, 0x00CC,
	205, 0x00CD, 206, 0x00CE, 207, 0x00CF, 209, 0x00D1, 210, 0x00D2, 211, 0x00D3, 212, 0x00D4, 213, 0x0120, 214, 0x00D6, 215, 0x00D7,
	216, 0x011C, 217, 0x00D9, 218, 0x00DA, 219, 0x00DB, 220, 0x00DC, 221, 0x016C, 222, 0x015C, 223, 0x00DF, 224, 0x00E0, 225, 0x00E1,
	226, 0x00E2, 228, 0x00E4, 229, 0x010B, 230, 0x0109, 231, 0x00E7, 232, 0x00E8, 233, 0x00E9, 234, 0x00EA, 235, 0x00EB, 236, 0x00EC,
	237, 0x00ED, 238, 0x00EE, 239, 0x00EF, 241, 0x00F1, 242, 0x00F2, 243, 0x00F3, 244, 0x00F4, 245, 0x0121, 246, 0x00F6, 247, 0x00F7,
	248, 0x011D, 249, 0x00F9, 250, 0x00FA, 251, 0x00FB, 252, 0x00FC, 253, 0x016D, 254, 0x015D, 255, 0x02D9,
	0, 0 };

static int latin4codetable[] = {
	161, 0x0104, 162, 0x0138, 163, 0x0156, 164, 0x00A4, 165, 0x0128, 166, 0x013B, 167, 0x00A7, 168, 0x00A8, 169, 0x0160, 170, 0x0112,
	171, 0x0122, 172, 0x0166, 174, 0x017D, 175, 0x00AF, 176, 0x00B0, 177, 0x0105, 178, 0x02DB, 179, 0x0157, 180, 0x00B4,
	181, 0x0129, 182, 0x013C, 183, 0x02C7, 184, 0x00B8, 185, 0x0161, 186, 0x0113, 187, 0x0123, 188, 0x0167, 189, 0x014A, 190, 0x017E,
	191, 0x014B, 192, 0x0100, 193, 0x00C1, 194, 0x00C2, 195, 0x00C3, 196, 0x00C4, 197, 0x00C5, 198, 0x00C6, 199, 0x012E, 200, 0x010C,
	201, 0x00C9, 202, 0x0118, 203, 0x00CB, 204, 0x0116, 205, 0x00CD, 206, 0x00CE, 207, 0x012A, 208, 0x0110, 209, 0x0145, 210, 0x014C,
	211, 0x0136, 212, 0x00D4, 213, 0x00D5, 214, 0x00D6, 215, 0x00D7, 216, 0x00D8, 217, 0x0172, 218, 0x00DA, 219, 0x00DB, 220, 0x00DC,
	221, 0x0168, 222, 0x016A, 223, 0x00DF, 224, 0x0101, 225, 0x00E1, 226, 0x00E2, 227, 0x00E3, 228, 0x00E4, 229, 0x00E5, 230, 0x00E6,
	231, 0x012F, 232, 0x010D, 233, 0x00E9, 234, 0x0119, 235, 0x00EB, 236, 0x0117, 237, 0x00ED, 238, 0x00EE, 239, 0x012B, 240, 0x0111,
	241, 0x0146, 242, 0x014D, 243, 0x0137, 244, 0x00F4, 245, 0x00F5, 246, 0x00F6, 247, 0x00F7, 248, 0x00F8, 249, 0x0173, 250, 0x00FA,
	251, 0x00FB, 252, 0x00FC, 253, 0x0169, 254, 0x016B, 255, 0x02D9,
	0, 0 };

static int latin5codetable[] = {
	161, 0x401, 162, 0x402, 163, 0x403, 164, 0x404, 165, 0x405, 166, 0x406, 167, 0x407, 168, 0x408, 169, 0x409,
	170, 0x40A, 171, 0x40B, 172, 0x40C, 173, 0x3, 174, 0x40E, 175, 0x40F, 176, 0x410, 177, 0x411, 178, 0x412, 179, 0x413, 180, 0x414, 181, 0x415,
	182, 0x416, 183, 0x417, 184, 0x418, 185, 0x419, 186, 0x41A, 187, 0x41B, 188, 0x41C, 189, 0x41D, 190, 0x41E, 191, 0x41F, 192, 0x420, 193, 0x421,
	194, 0x422, 195, 0x423, 196, 0x424, 197, 0x425, 198, 0x426, 199, 0x427, 200, 0x428, 201, 0x429, 202, 0x42A, 203, 0x42B, 204, 0x42C, 205, 0x42D,
	206, 0x42E, 207, 0x42F, 208, 0x430, 209, 0x431, 210, 0x432, 211, 0x433, 212, 0x434, 213, 0x435, 214, 0x436, 215, 0x437, 216, 0x438, 217, 0x439,
	218, 0x43A, 219, 0x43B, 220, 0x43C, 221, 0x43D, 222, 0x43E, 223, 0x43F, 224, 0x440, 225, 0x441, 226, 0x442, 227, 0x443, 228, 0x444, 229, 0x445,
	230, 0x446, 231, 0x447, 232, 0x448, 233, 0x449, 234, 0x44A, 235, 0x44B, 236, 0x44C, 237, 0x44D, 238, 0x44E, 239, 0x44F, 240, 0x2116, 241, 0x451, 242, 0x452,
	243, 0x453, 244, 0x454, 245, 0x455, 246, 0x456, 247, 0x457, 248, 0x458, 249, 0x459, 250, 0x45A, 251, 0x45B, 252, 0x45C, 253, 0xA7, 254, 0x45E, 255, 0x45F,
	0, 0 };

static int latin6codetable[] = {
	164, 0x00A4, 172, 0x060C, 187, 0x061B, 191, 0x061F, 193, 0x0621, 194, 0x0622, 195, 0x0623, 196, 0x0624, 197, 0x0625,
	198, 0x0626, 199, 0x0627, 200, 0x0628, 201, 0x0629, 202, 0x062A, 203, 0x062B, 204, 0x062C, 205, 0x062D, 206, 0x062E, 207, 0x062F,
	208, 0x0630, 209, 0x0631, 210, 0x0632, 211, 0x0633, 212, 0x0634, 213, 0x0635, 214, 0x0636, 215, 0x0637, 216, 0x0638, 217, 0x0639,
	218, 0x063A, 224, 0x0640, 225, 0x0641, 226, 0x0642, 227, 0x0643, 228, 0x0644, 229, 0x0645, 230, 0x0646, 231, 0x0647, 232, 0x0648,
	233, 0x0649, 234, 0x064A, 0, 0 };

static int latin7codetable[] = {
	163, 0x00A3, 164, 0x20AC, 165, 0x20AF, 166, 0x00A6, 167, 0x00A7, 168, 0x00A8, 169, 0x00A9, 170, 0x037A,
	171, 0x00AB, 172, 0x00AC, 175, 0x2015, 176, 0x00B0, 177, 0x00B1, 178, 0x00B2, 179, 0x00B3, 180, 0x0384, 181, 0x0385,
	182, 0x0386, 183, 0x00B7, 184, 0x0388, 185, 0x0389, 186, 0x038A, 187, 0x00BB, 188, 0x038C, 189, 0x00BD, 190, 0x038E, 191, 0x038F,
	192, 0x0390, 193, 0x0391, 194, 0x0392, 195, 0x0393, 196, 0x0394, 197, 0x0395, 198, 0x0396, 199, 0x0397, 200, 0x0398, 201, 0x0399,
	202, 0x039A, 203, 0x039B, 204, 0x039C, 205, 0x039D, 206, 0x039E, 207, 0x039F, 208, 0x03A0, 209, 0x03A1, 211, 0x03A3, 212, 0x03A4,
	213, 0x03A5, 214, 0x03A6, 215, 0x03A7, 216, 0x03A8, 217, 0x03A9, 218, 0x03AA, 219, 0x03AB, 220, 0x03AC, 221, 0x03AD, 222, 0x03AE,
	223, 0x03AF, 224, 0x03B0, 225, 0x03B1, 226, 0x03B2, 227, 0x03B3, 228, 0x03B4, 229, 0x03B5, 230, 0x03B6, 231, 0x03B7, 232, 0x03B8,
	233, 0x03B9, 234, 0x03BA, 235, 0x03BB, 236, 0x03BC, 237, 0x03BD, 238, 0x03BE, 239, 0x03BF, 240, 0x03C0, 241, 0x03C1, 242, 0x03C2,
	243, 0x03C3, 244, 0x03C4, 245, 0x03C5, 246, 0x03C6, 247, 0x03C7, 248, 0x03C8, 249, 0x03C9, 250, 0x03CA, 251, 0x03CB, 252, 0x03CC,
	253, 0x03CD, 254, 0x03CE, 0, 0 };

static int latin8codetable[] = {
	162, 0x00A2, 163, 0x00A3, 164, 0x00A4, 165, 0x00A5, 166, 0x00A6, 167, 0x00A7, 168, 0x00A8, 169, 0x00A9, 170, 0x00D7, 171, 0x00AB,
	172, 0x00AC, 174, 0x00AE, 175, 0x00AF, 176, 0x00B0, 177, 0x00B1, 178, 0x00B2, 179, 0x00B3, 180, 0x00B4, 181, 0x00B5,
	182, 0x00B6, 183, 0x00B7, 184, 0x00B8, 185, 0x00B9, 186, 0x00F7, 187, 0x00BB, 188, 0x00BC, 189, 0x00BD, 190, 0x00BE, 223, 0x2017,
	224, 0x05D0, 225, 0x05D1, 226, 0x05D2, 227, 0x05D3, 228, 0x05D4, 229, 0x05D5, 230, 0x05D6, 231, 0x05D7, 232, 0x05D8, 233, 0x05D9,
	234, 0x05DA, 235, 0x05DB, 236, 0x05DC, 237, 0x05DD, 238, 0x05DE, 239, 0x05DF, 240, 0x05E0, 241, 0x05E1, 242, 0x05E2, 243, 0x05E3,
	244, 0x05E4, 245, 0x05E5, 246, 0x05E6, 247, 0x05E7, 248, 0x05E8, 249, 0x05E9, 250, 0x05EA, 0, 0 };

static int latin9codetable[] = {
	161, 0x00A1, 162, 0x00A2, 163, 0x00A3, 164, 0x00A4, 165, 0x00A5, 166, 0x00A6, 167, 0x00A7, 168, 0x00A8, 169, 0x00A9, 170, 0x00AA,
	171, 0x00AB, 172, 0x00AC, 174, 0x00AE, 175, 0x00AF, 176, 0x00B0, 177, 0x00B1, 178, 0x00B2, 179, 0x00B3, 180, 0x00B4,
	181, 0x00B5, 182, 0x00B6, 183, 0x00B7, 184, 0x00B8, 185, 0x00B9, 186, 0x00BA, 187, 0x00BB, 188, 0x00BC, 189, 0x00BD, 190, 0x00BE,
	191, 0x00BF, 192, 0x00C0, 193, 0x00C1, 194, 0x00C2, 195, 0x00C3, 196, 0x00C4, 197, 0x00C5, 198, 0x00C6, 199, 0x00C7, 200, 0x00C8,
	201, 0x00C9, 202, 0x00CA, 203, 0x00CB, 204, 0x00CC, 205, 0x00CD, 206, 0x00CE, 207, 0x00CF, 208, 0x011E, 209, 0x00D1, 210, 0x00D2,
	211, 0x00D3, 212, 0x00D4, 213, 0x00D5, 214, 0x00D6, 215, 0x00D7, 216, 0x00D8, 217, 0x00D9, 218, 0x00DA, 219, 0x00DB, 220, 0x00DC,
	221, 0x0130, 222, 0x015E, 223, 0x00DF, 224, 0x00E0, 225, 0x00E1, 226, 0x00E2, 227, 0x00E3, 228, 0x00E4, 229, 0x00E5, 230, 0x00E6,
	231, 0x00E7, 232, 0x00E8, 233, 0x00E9, 234, 0x00EA, 235, 0x00EB, 236, 0x00EC, 237, 0x00ED, 238, 0x00EE, 239, 0x00EF, 240, 0x011F,
	241, 0x00F1, 242, 0x00F2, 243, 0x00F3, 244, 0x00F4, 245, 0x00F5, 246, 0x00F6, 247, 0x00F7, 248, 0x00F8, 249, 0x00F9, 250, 0x00FA,
	251, 0x00FB, 252, 0x00FC, 253, 0x0131, 254, 0x015F, 255, 0x00FF, 0, 0 };

static int latin10codetable[] = {
	161, 0x0104, 162, 0x0112, 163, 0x0122, 164, 0x012A, 165, 0x0128, 166, 0x0136, 167, 0x00A7, 168, 0x013B, 169, 0x0110, 170, 0x0160,
	171, 0x0166, 172, 0x017D, 174, 0x016A, 175, 0x014A, 176, 0x00B0, 177, 0x0105, 178, 0x0113, 179, 0x0123, 180, 0x012B,
	181, 0x0129, 182, 0x0137, 183, 0x00B7, 184, 0x013C, 185, 0x0111, 186, 0x0161, 187, 0x0167, 188, 0x017E, 189, 0x2015, 190, 0x016B,
	191, 0x014B, 192, 0x0100, 193, 0x00C1, 194, 0x00C2, 195, 0x00C3, 196, 0x00C4, 197, 0x00C5, 198, 0x00C6, 199, 0x012E, 200, 0x010C,
	201, 0x00C9, 202, 0x0118, 203, 0x00CB, 204, 0x0116, 205, 0x00CD, 206, 0x00CE, 207, 0x00CF, 208, 0x00D0, 209, 0x0145, 210, 0x014C,
	211, 0x00D3, 212, 0x00D4, 213, 0x00D5, 214, 0x00D6, 215, 0x0168, 216, 0x00D8, 217, 0x0172, 218, 0x00DA, 219, 0x00DB, 220, 0x00DC,
	221, 0x00DD, 222, 0x00DE, 223, 0x00DF, 224, 0x0101, 225, 0x00E1, 226, 0x00E2, 227, 0x00E3, 228, 0x00E4, 229, 0x00E5, 230, 0x00E6,
	231, 0x012F, 232, 0x010D, 233, 0x00E9, 234, 0x0119, 235, 0x00EB, 236, 0x0117, 237, 0x00ED, 238, 0x00EE, 239, 0x00EF, 240, 0x00F0,
	241, 0x0146, 242, 0x014D, 243, 0x00F3, 244, 0x00F4, 245, 0x00F5, 246, 0x00F6, 247, 0x0169, 248, 0x00F8, 249, 0x0173, 250, 0x00FA,
	251, 0x00FB, 252, 0x00FC, 253, 0x00FD, 254, 0x00FE, 255, 0x0138, 0, 0 };

static int latin11codetable[] = {
	161, 0x0E01, 162, 0x0E02, 163, 0x0E03, 164, 0x0E04, 165, 0x0E05, 166, 0x0E06, 167, 0x0E07, 168, 0x0E08, 169, 0x0E09, 170, 0x0E0A,
	171, 0x0E0B, 172, 0x0E0C, 173, 0x0E0D, 174, 0x0E0E, 175, 0x0E0F, 176, 0x0E10, 177, 0x0E11, 178, 0x0E12, 179, 0x0E13, 180, 0x0E14,
	181, 0x0E15, 182, 0x0E16, 183, 0x0E17, 184, 0x0E18, 185, 0x0E19, 186, 0x0E1A, 187, 0x0E1B, 188, 0x0E1C, 189, 0x0E1D, 190, 0x0E1E,
	191, 0x0E1F, 192, 0x0E20, 193, 0x0E21, 194, 0x0E22, 195, 0x0E23, 196, 0x0E24, 197, 0x0E25, 198, 0x0E26, 199, 0x0E27, 200, 0x0E28,
	201, 0x0E29, 202, 0x0E2A, 203, 0x0E2B, 204, 0x0E2C, 205, 0x0E2D, 206, 0x0E2E, 207, 0x0E2F, 208, 0x0E30, 210, 0x0E32,
	211, 0x0E33, 223, 0x0E3F, 224, 0x0E40,
	225, 0x0E41, 226, 0x0E42, 227, 0x0E43, 228, 0x0E44, 229, 0x0E45, 230, 0x0E46,
	239, 0x0E4F, 240, 0x0E50, 241, 0x0E51, 242, 0x0E52, 243, 0x0E53, 244, 0x0E54,
	245, 0x0E55, 246, 0x0E56, 247, 0x0E57, 248, 0x0E58, 249, 0x0E59, 250, 0x0E5A, 251, 0x0E5B, 0, 0 };

static int latin13codetable[] = {
	34, 0x201D, 162, 0x00A2, 163, 0x00A3, 164, 0x00A4, 165, 0x201E, 166, 0x00A6, 167, 0x00A7, 168, 0x00D8, 169, 0x00A9, 170, 0x0156,
	171, 0x00AB, 172, 0x00AC, 174, 0x00AE, 175, 0x00C6, 176, 0x00B0, 177, 0x00B1, 178, 0x00B2, 179, 0x00B3, 34, 0x201C,
	181, 0x00B5, 182, 0x00B6, 183, 0x00B7, 184, 0x00F8, 185, 0x00B9, 186, 0x0157, 187, 0x00BB, 188, 0x00BC, 189, 0x00BD, 190, 0x00BE,
	191, 0x00E6, 192, 0x0104, 193, 0x012E, 194, 0x0100, 195, 0x0106, 196, 0x00C4, 197, 0x00C5, 198, 0x0118, 199, 0x0112, 200, 0x010C,
	201, 0x00C9, 202, 0x0179, 203, 0x0116, 204, 0x0122, 205, 0x0136, 206, 0x012A, 207, 0x013B, 208, 0x0160, 209, 0x0143, 210, 0x0145,
	211, 0x00D3, 212, 0x014C, 213, 0x00D5, 214, 0x00D6, 215, 0x00D7, 216, 0x0172, 217, 0x0141, 218, 0x015A, 219, 0x016A, 220, 0x00DC,
	221, 0x017B, 222, 0x017D, 223, 0x00DF, 224, 0x0105, 225, 0x012F, 226, 0x0101, 227, 0x0107, 228, 0x00E4, 229, 0x00E5, 230, 0x0119,
	231, 0x0113, 232, 0x010D, 233, 0x00E9, 234, 0x017A, 235, 0x0117, 236, 0x0123, 237, 0x0137, 238, 0x012B, 239, 0x013C, 240, 0x0161,
	241, 0x0144, 242, 0x0146, 243, 0x00F3, 244, 0x014D, 245, 0x00F5, 246, 0x00F6, 247, 0x00F7, 248, 0x0173, 249, 0x0142, 250, 0x015B,
	251, 0x016B, 252, 0x00FC, 253, 0x017C, 254, 0x017E, 39, 0x2019, 0, 0 };

static int latin14codetable[] = {
	161, 0x1E02, 162, 0x1E03, 163, 0x00A3, 164, 0x010A, 165, 0x010B, 166, 0x1E0A, 167, 0x00A7, 168, 0x1E80, 169, 0x00A9, 170, 0x1E82,
	171, 0x1E0B, 172, 0x1EF2, 174, 0x00AE, 175, 0x0178, 176, 0x1E1E, 177, 0x1E1F, 178, 0x0120, 179, 0x0121, 180, 0x1E40,
	181, 0x1E41, 182, 0x00B6, 183, 0x1E56, 184, 0x1E81, 185, 0x1E57, 186, 0x1E83, 187, 0x1E60, 188, 0x1EF3, 189, 0x1E84, 190, 0x1E85,
	191, 0x1E61, 192, 0x00C0, 193, 0x00C1, 194, 0x00C2, 195, 0x00C3, 196, 0x00C4, 197, 0x00C5, 198, 0x00C6, 199, 0x00C7, 200, 0x00C8,
	201, 0x00C9, 202, 0x00CA, 203, 0x00CB, 204, 0x00CC, 205, 0x00CD, 206, 0x00CE, 207, 0x00CF, 208, 0x0174, 209, 0x00D1, 210, 0x00D2,
	211, 0x00D3, 212, 0x00D4, 213, 0x00D5, 214, 0x00D6, 215, 0x1E6A, 216, 0x00D8, 217, 0x00D9, 218, 0x00DA, 219, 0x00DB, 220, 0x00DC,
	221, 0x00DD, 222, 0x0176, 223, 0x00DF, 224, 0x00E0, 225, 0x00E1, 226, 0x00E2, 227, 0x00E3, 228, 0x00E4, 229, 0x00E5, 230, 0x00E6,
	231, 0x00E7, 232, 0x00E8, 233, 0x00E9, 234, 0x00EA, 235, 0x00EB, 236, 0x00EC, 237, 0x00ED, 238, 0x00EE, 239, 0x00EF, 240, 0x0175,
	241, 0x00F1, 242, 0x00F2, 243, 0x00F3, 244, 0x00F4, 245, 0x00F5, 246, 0x00F6, 247, 0x1E6B, 248, 0x00F8, 249, 0x00F9, 250, 0x00FA,
	251, 0x00FB, 252, 0x00FC, 253, 0x00FD, 254, 0x0177, 255, 0x00FF, 0, 0 };

static int latin15codetable[] = {
	161, 0x00A1, 162, 0x00A2, 163, 0x00A3, 164, 0x20AC, 165, 0x00A5, 166, 0x0160, 167, 0x00A7, 168, 0x0161, 169, 0x00A9, 170, 0x00AA,
	171, 0x00AB, 172, 0x00AC, 174, 0x00AE, 175, 0x00AF, 176, 0x00B0, 177, 0x00B1, 178, 0x00B2, 179, 0x00B3, 180, 0x017D,
	181, 0x00B5, 182, 0x00B6, 183, 0x00B7, 184, 0x017E, 185, 0x00B9, 186, 0x00BA, 187, 0x00BB, 188, 0x0152, 189, 0x0153, 190, 0x0178,
	191, 0x00BF, 192, 0x00C0, 193, 0x00C1, 194, 0x00C2, 195, 0x00C3, 196, 0x00C4, 197, 0x00C5, 198, 0x00C6, 199, 0x00C7, 200, 0x00C8,
	201, 0x00C9, 202, 0x00CA, 203, 0x00CB, 204, 0x00CC, 205, 0x00CD, 206, 0x00CE, 207, 0x00CF, 208, 0x00D0, 209, 0x00D1, 210, 0x00D2,
	211, 0x00D3, 212, 0x00D4, 213, 0x00D5, 214, 0x00D6, 215, 0x00D7, 216, 0x00D8, 217, 0x00D9, 218, 0x00DA, 219, 0x00DB, 220, 0x00DC,
	221, 0x00DD, 222, 0x00DE, 223, 0x00DF, 224, 0x00E0, 225, 0x00E1, 226, 0x00E2, 227, 0x00E3, 228, 0x00E4, 229, 0x00E5, 230, 0x00E6,
	231, 0x00E7, 232, 0x00E8, 233, 0x00E9, 234, 0x00EA, 235, 0x00EB, 236, 0x00EC, 237, 0x00ED, 238, 0x00EE, 239, 0x00EF, 240, 0x00F0,
	241, 0x00F1, 242, 0x00F2, 243, 0x00F3, 244, 0x00F4, 245, 0x00F5, 246, 0x00F6, 247, 0x00F7, 248, 0x00F8, 249, 0x00F9, 250, 0x00FA,
	251, 0x00FB, 252, 0x00FC, 253, 0x00FD, 254, 0x00FE, 255, 0x00FF, 0, 0 };

static int latin16codetable[] = {
	161, 0x0104, 162, 0x0105, 163, 0x0141, 164, 0x20AC, 165, 0x201E, 166, 0x0160, 167, 0x00A7, 168, 0x0161, 169, 0x00A9, 170, 0x0218,
	171, 0x00AB, 172, 0x0179, 174, 0x017A, 175, 0x017B, 176, 0x00B0, 177, 0x00B1, 178, 0x010C, 179, 0x0142, 180, 0x017D,
	34, 0x201D, 182, 0x00B6, 183, 0x00B7, 184, 0x017E, 185, 0x010D, 186, 0x0219, 187, 0x00BB, 188, 0x0152, 189, 0x0153, 190, 0x0178,
	191, 0x017C, 192, 0x00C0, 193, 0x00C1, 194, 0x00C2, 195, 0x0102, 196, 0x00C4, 197, 0x0106, 198, 0x00C6, 199, 0x00C7, 200, 0x00C8,
	201, 0x00C9, 202, 0x00CA, 203, 0x00CB, 204, 0x00CC, 205, 0x00CD, 206, 0x00CE, 207, 0x00CF, 208, 0x0110, 209, 0x0143, 210, 0x00D2,
	211, 0x00D3, 212, 0x00D4, 213, 0x0150, 214, 0x00D6, 215, 0x015A, 216, 0x0170, 217, 0x00D9, 218, 0x00DA, 219, 0x00DB, 220, 0x00DC,
	221, 0x0118, 222, 0x021A, 223, 0x00DF, 224, 0x00E0, 225, 0x00E1, 226, 0x00E2, 227, 0x0103, 228, 0x00E4, 229, 0x0107, 230, 0x00E6,
	231, 0x00E7, 232, 0x00E8, 233, 0x00E9, 234, 0x00EA, 235, 0x00EB, 236, 0x00EC, 237, 0x00ED, 238, 0x00EE, 239, 0x00EF, 240, 0x0111,
	241, 0x0144, 242, 0x00F2, 243, 0x00F3, 244, 0x00F4, 245, 0x0151, 246, 0x00F6, 247, 0x015B, 248, 0x0171, 249, 0x00F9, 250, 0x00FA,
	251, 0x00FB, 252, 0x00FC, 253, 0x0119, 254, 0x021B, 255, 0x00FF, 0, 0 };


static int table[] = { 65, 97, 2, 66, 98, 2, 67, 99, 2, 68, 100, 2, 69, 101, 2, 70, 102, 2, 71, 103, 2, 72, 104, 2, 73, 105, 2, 74, 106, 2
, 75, 107, 2, 76, 108, 2, 77, 109, 2, 78, 110, 2, 79, 111, 2, 80, 112, 2, 81, 113, 2, 82, 114, 2, 83, 115, 2, 84, 116, 2
, 85, 117, 2, 86, 118, 2, 87, 119, 2, 88, 120, 2, 89, 121, 2, 90, 122, 2, 97, 65, 1, 98, 66, 1, 99, 67, 1, 100, 68, 1
, 101, 69, 1, 102, 70, 1, 103, 71, 1, 104, 72, 1, 105, 73, 1, 106, 74, 1, 107, 75, 1, 108, 76, 1, 109, 77, 1, 110, 78, 1
, 111, 79, 1, 112, 80, 1, 113, 81, 1, 114, 82, 1, 115, 83, 1, 116, 84, 1, 117, 85, 1, 118, 86, 1, 119, 87, 1, 120, 88, 1
, 121, 89, 1, 122, 90, 1, 170, 170, 1, 181, 924, 1, 186, 186, 1, 192, 224, 2, 193, 225, 2, 194, 226, 2, 195, 227, 2, 196, 228, 2
, 197, 229, 2, 198, 230, 2, 199, 231, 2, 200, 232, 2, 201, 233, 2, 202, 234, 2, 203, 235, 2, 204, 236, 2, 205, 237, 2, 206, 238, 2
, 207, 239, 2, 208, 240, 2, 209, 241, 2, 210, 242, 2, 211, 243, 2, 212, 244, 2, 213, 245, 2, 214, 246, 2, 216, 248, 2, 217, 249, 2
, 218, 250, 2, 219, 251, 2, 220, 252, 2, 221, 253, 2, 222, 254, 2, 223, 223, 1, 224, 192, 1, 225, 193, 1, 226, 194, 1, 227, 195, 1
, 228, 196, 1, 229, 197, 1, 230, 198, 1, 231, 199, 1, 232, 200, 1, 233, 201, 1, 234, 202, 1, 235, 203, 1, 236, 204, 1, 237, 205, 1
, 238, 206, 1, 239, 207, 1, 240, 208, 1, 241, 209, 1, 242, 210, 1, 243, 211, 1, 244, 212, 1, 245, 213, 1, 246, 214, 1, 248, 216, 1
, 249, 217, 1, 250, 218, 1, 251, 219, 1, 252, 220, 1, 253, 221, 1, 254, 222, 1, 255, 376, 1, 256, 257, 2, 257, 256, 1, 258, 259, 2
, 259, 258, 1, 260, 261, 2, 261, 260, 1, 262, 263, 2, 263, 262, 1, 264, 265, 2, 265, 264, 1, 266, 267, 2, 267, 266, 1, 268, 269, 2
, 269, 268, 1, 270, 271, 2, 271, 270, 1, 272, 273, 2, 273, 272, 1, 274, 275, 2, 275, 274, 1, 276, 277, 2, 277, 276, 1, 278, 279, 2
, 279, 278, 1, 280, 281, 2, 281, 280, 1, 282, 283, 2, 283, 282, 1, 284, 285, 2, 285, 284, 1, 286, 287, 2, 287, 286, 1, 288, 289, 2
, 289, 288, 1, 290, 291, 2, 291, 290, 1, 292, 293, 2, 293, 292, 1, 294, 295, 2, 295, 294, 1, 296, 297, 2, 297, 296, 1, 298, 299, 2
, 299, 298, 1, 300, 301, 2, 301, 300, 1, 302, 303, 2, 303, 302, 1, 304, 105, 2, 305, 73, 1, 306, 307, 2, 307, 306, 1, 308, 309, 2
, 309, 308, 1, 310, 311, 2, 311, 310, 1, 312, 312, 1, 313, 314, 2, 314, 313, 1, 315, 316, 2, 316, 315, 1, 317, 318, 2, 318, 317, 1
, 319, 320, 2, 320, 319, 1, 321, 322, 2, 322, 321, 1, 323, 324, 2, 324, 323, 1, 325, 326, 2, 326, 325, 1, 327, 328, 2, 328, 327, 1
, 329, 329, 1, 330, 331, 2, 331, 330, 1, 332, 333, 2, 333, 332, 1, 334, 335, 2, 335, 334, 1, 336, 337, 2, 337, 336, 1, 338, 339, 2
, 339, 338, 1, 340, 341, 2, 341, 340, 1, 342, 343, 2, 343, 342, 1, 344, 345, 2, 345, 344, 1, 346, 347, 2, 347, 346, 1, 348, 349, 2
, 349, 348, 1, 350, 351, 2, 351, 350, 1, 352, 353, 2, 353, 352, 1, 354, 355, 2, 355, 354, 1, 356, 357, 2, 357, 356, 1, 358, 359, 2
, 359, 358, 1, 360, 361, 2, 361, 360, 1, 362, 363, 2, 363, 362, 1, 364, 365, 2, 365, 364, 1, 366, 367, 2, 367, 366, 1, 368, 369, 2
, 369, 368, 1, 370, 371, 2, 371, 370, 1, 372, 373, 2, 373, 372, 1, 374, 375, 2, 375, 374, 1, 376, 255, 2, 377, 378, 2, 378, 377, 1
, 379, 380, 2, 380, 379, 1, 381, 382, 2, 382, 381, 1, 383, 83, 1, 384, 579, 1, 385, 595, 2, 386, 387, 2, 387, 386, 1, 388, 389, 2
, 389, 388, 1, 390, 596, 2, 391, 392, 2, 392, 391, 1, 393, 598, 2, 394, 599, 2, 395, 396, 2, 396, 395, 1, 397, 397, 1, 398, 477, 2
, 399, 601, 2, 400, 603, 2, 401, 402, 2, 402, 401, 1, 403, 608, 2, 404, 611, 2, 405, 502, 1, 406, 617, 2, 407, 616, 2, 408, 409, 2
, 409, 408, 1, 410, 573, 1, 411, 411, 1, 412, 623, 2, 413, 626, 2, 414, 544, 1, 415, 629, 2, 416, 417, 2, 417, 416, 1, 418, 419, 2
, 419, 418, 1, 420, 421, 2, 421, 420, 1, 422, 640, 2, 423, 424, 2, 424, 423, 1, 425, 643, 2, 426, 426, 1, 427, 427, 1, 428, 429, 2
, 429, 428, 1, 430, 648, 2, 431, 432, 2, 432, 431, 1, 433, 650, 2, 434, 651, 2, 435, 436, 2, 436, 435, 1, 437, 438, 2, 438, 437, 1
, 439, 658, 2, 440, 441, 2, 441, 440, 1, 442, 442, 1, 443, 443, 0, 444, 445, 2, 445, 444, 1, 446, 446, 1, 447, 503, 1, 448, 448, 0
, 449, 449, 0, 450, 450, 0, 451, 451, 0, 452, 454, 2, 453, 453, 0, 454, 452, 1, 455, 457, 2, 456, 456, 0, 457, 455, 1, 458, 460, 2
, 459, 459, 0, 460, 458, 1, 461, 462, 2, 462, 461, 1, 463, 464, 2, 464, 463, 1, 465, 466, 2, 466, 465, 1, 467, 468, 2, 468, 467, 1
, 469, 470, 2, 470, 469, 1, 471, 472, 2, 472, 471, 1, 473, 474, 2, 474, 473, 1, 475, 476, 2, 476, 475, 1, 477, 398, 1, 478, 479, 2
, 479, 478, 1, 480, 481, 2, 481, 480, 1, 482, 483, 2, 483, 482, 1, 484, 485, 2, 485, 484, 1, 486, 487, 2, 487, 486, 1, 488, 489, 2
, 489, 488, 1, 490, 491, 2, 491, 490, 1, 492, 493, 2, 493, 492, 1, 494, 495, 2, 495, 494, 1, 496, 496, 1, 497, 499, 2, 498, 498, 0
, 499, 497, 1, 500, 501, 2, 501, 500, 1, 502, 405, 2, 503, 447, 2, 504, 505, 2, 505, 504, 1, 506, 507, 2, 507, 506, 1, 508, 509, 2
, 509, 508, 1, 510, 511, 2, 511, 510, 1, 512, 513, 2, 513, 512, 1, 514, 515, 2, 515, 514, 1, 516, 517, 2, 517, 516, 1, 518, 519, 2
, 519, 518, 1, 520, 521, 2, 521, 520, 1, 522, 523, 2, 523, 522, 1, 524, 525, 2, 525, 524, 1, 526, 527, 2, 527, 526, 1, 528, 529, 2
, 529, 528, 1, 530, 531, 2, 531, 530, 1, 532, 533, 2, 533, 532, 1, 534, 535, 2, 535, 534, 1, 536, 537, 2, 537, 536, 1, 538, 539, 2
, 539, 538, 1, 540, 541, 2, 541, 540, 1, 542, 543, 2, 543, 542, 1, 544, 414, 2, 545, 545, 1, 546, 547, 2, 547, 546, 1, 548, 549, 2
, 549, 548, 1, 550, 551, 2, 551, 550, 1, 552, 553, 2, 553, 552, 1, 554, 555, 2, 555, 554, 1, 556, 557, 2, 557, 556, 1, 558, 559, 2
, 559, 558, 1, 560, 561, 2, 561, 560, 1, 562, 563, 2, 563, 562, 1, 564, 564, 1, 565, 565, 1, 566, 566, 1, 567, 567, 1, 568, 568, 1
, 569, 569, 1, 570, 11365, 2, 571, 572, 2, 572, 571, 1, 573, 410, 2, 574, 11366, 2, 575, 11390, 1, 576, 11391, 1, 577, 578, 2, 578, 577, 1
, 579, 384, 2, 580, 649, 2, 581, 652, 2, 582, 583, 2, 583, 582, 1, 584, 585, 2, 585, 584, 1, 586, 587, 2, 587, 586, 1, 588, 589, 2
, 589, 588, 1, 590, 591, 2, 591, 590, 1, 592, 11375, 1, 593, 11373, 1, 594, 11376, 1, 595, 385, 1, 596, 390, 1, 597, 597, 1, 598, 393, 1
, 599, 394, 1, 600, 600, 1, 601, 399, 1, 602, 602, 1, 603, 400, 1, 604, 604, 1, 605, 605, 1, 606, 606, 1, 607, 607, 1, 608, 403, 1
, 609, 609, 1, 610, 610, 1, 611, 404, 1, 612, 612, 1, 613, 613, 1, 614, 614, 1, 615, 615, 1, 616, 407, 1, 617, 406, 1, 618, 618, 1
, 619, 11362, 1, 620, 620, 1, 621, 621, 1, 622, 622, 1, 623, 412, 1, 624, 624, 1, 625, 11374, 1, 626, 413, 1, 627, 627, 1, 628, 628, 1
, 629, 415, 1, 630, 630, 1, 631, 631, 1, 632, 632, 1, 633, 633, 1, 634, 634, 1, 635, 635, 1, 636, 636, 1, 637, 11364, 1, 638, 638, 1
, 639, 639, 1, 640, 422, 1, 641, 641, 1, 642, 642, 1, 643, 425, 1, 644, 644, 1, 645, 645, 1, 646, 646, 1, 647, 647, 1, 648, 430, 1
, 649, 580, 1, 650, 433, 1, 651, 434, 1, 652, 581, 1, 653, 653, 1, 654, 654, 1, 655, 655, 1, 656, 656, 1, 657, 657, 1, 658, 439, 1
, 659, 659, 1, 660, 660, 0, 661, 661, 1, 662, 662, 1, 663, 663, 1, 664, 664, 1, 665, 665, 1, 666, 666, 1, 667, 667, 1, 668, 668, 1
, 669, 669, 1, 670, 670, 1, 671, 671, 1, 672, 672, 1, 673, 673, 1, 674, 674, 1, 675, 675, 1, 676, 676, 1, 677, 677, 1, 678, 678, 1
, 679, 679, 1, 680, 680, 1, 681, 681, 1, 682, 682, 1, 683, 683, 1, 684, 684, 1, 685, 685, 1, 686, 686, 1, 687, 687, 1, 688, 688, 0
, 689, 689, 0, 690, 690, 0, 691, 691, 0, 692, 692, 0, 693, 693, 0, 694, 694, 0, 695, 695, 0, 696, 696, 0, 697, 697, 0, 698, 698, 0
, 699, 699, 0, 700, 700, 0, 701, 701, 0, 702, 702, 0, 703, 703, 0, 704, 704, 0, 705, 705, 0, 710, 710, 0, 711, 711, 0, 712, 712, 0
, 713, 713, 0, 714, 714, 0, 715, 715, 0, 716, 716, 0, 717, 717, 0, 718, 718, 0, 719, 719, 0, 720, 720, 0, 721, 721, 0, 736, 736, 0
, 737, 737, 0, 738, 738, 0, 739, 739, 0, 740, 740, 0, 748, 748, 0, 750, 750, 0, 880, 881, 2, 881, 880, 1, 882, 883, 2, 883, 882, 1
, 884, 884, 0, 886, 887, 2, 887, 886, 1, 890, 890, 0, 891, 1021, 1, 892, 1022, 1, 893, 1023, 1, 902, 940, 2, 904, 941, 2, 905, 942, 2
, 906, 943, 2, 908, 972, 2, 910, 973, 2, 911, 974, 2, 912, 912, 1, 913, 945, 2, 914, 946, 2, 915, 947, 2, 916, 948, 2, 917, 949, 2
, 918, 950, 2, 919, 951, 2, 920, 952, 2, 921, 953, 2, 922, 954, 2, 923, 955, 2, 924, 956, 2, 925, 957, 2, 926, 958, 2, 927, 959, 2
, 928, 960, 2, 929, 961, 2, 931, 963, 2, 932, 964, 2, 933, 965, 2, 934, 966, 2, 935, 967, 2, 936, 968, 2, 937, 969, 2, 938, 970, 2
, 939, 971, 2, 940, 902, 1, 941, 904, 1, 942, 905, 1, 943, 906, 1, 944, 944, 1, 945, 913, 1, 946, 914, 1, 947, 915, 1, 948, 916, 1
, 949, 917, 1, 950, 918, 1, 951, 919, 1, 952, 920, 1, 953, 921, 1, 954, 922, 1, 955, 923, 1, 956, 924, 1, 957, 925, 1, 958, 926, 1
, 959, 927, 1, 960, 928, 1, 961, 929, 1, 962, 931, 1, 963, 931, 1, 964, 932, 1, 965, 933, 1, 966, 934, 1, 967, 935, 1, 968, 936, 1
, 969, 937, 1, 970, 938, 1, 971, 939, 1, 972, 908, 1, 973, 910, 1, 974, 911, 1, 975, 983, 2, 976, 914, 1, 977, 920, 1, 978, 978, 2
, 979, 979, 2, 980, 980, 2, 981, 934, 1, 982, 928, 1, 983, 975, 1, 984, 985, 2, 985, 984, 1, 986, 987, 2, 987, 986, 1, 988, 989, 2
, 989, 988, 1, 990, 991, 2, 991, 990, 1, 992, 993, 2, 993, 992, 1, 994, 995, 2, 995, 994, 1, 996, 997, 2, 997, 996, 1, 998, 999, 2
, 999, 998, 1, 1000, 1001, 2, 1001, 1000, 1, 1002, 1003, 2, 1003, 1002, 1, 1004, 1005, 2, 1005, 1004, 1, 1006, 1007, 2, 1007, 1006, 1, 1008, 922, 1
, 1009, 929, 1, 1010, 1017, 1, 1011, 1011, 1, 1012, 952, 2, 1013, 917, 1, 1015, 1016, 2, 1016, 1015, 1, 1017, 1010, 2, 1018, 1019, 2, 1019, 1018, 1
, 1020, 1020, 1, 1021, 891, 2, 1022, 892, 2, 1023, 893, 2, 1024, 1104, 2, 1025, 1105, 2, 1026, 1106, 2, 1027, 1107, 2, 1028, 1108, 2, 1029, 1109, 2
, 1030, 1110, 2, 1031, 1111, 2, 1032, 1112, 2, 1033, 1113, 2, 1034, 1114, 2, 1035, 1115, 2, 1036, 1116, 2, 1037, 1117, 2, 1038, 1118, 2, 1039, 1119, 2
, 1040, 1072, 2, 1041, 1073, 2, 1042, 1074, 2, 1043, 1075, 2, 1044, 1076, 2, 1045, 1077, 2, 1046, 1078, 2, 1047, 1079, 2, 1048, 1080, 2, 1049, 1081, 2
, 1050, 1082, 2, 1051, 1083, 2, 1052, 1084, 2, 1053, 1085, 2, 1054, 1086, 2, 1055, 1087, 2, 1056, 1088, 2, 1057, 1089, 2, 1058, 1090, 2, 1059, 1091, 2
, 1060, 1092, 2, 1061, 1093, 2, 1062, 1094, 2, 1063, 1095, 2, 1064, 1096, 2, 1065, 1097, 2, 1066, 1098, 2, 1067, 1099, 2, 1068, 1100, 2, 1069, 1101, 2
, 1070, 1102, 2, 1071, 1103, 2, 1072, 1040, 1, 1073, 1041, 1, 1074, 1042, 1, 1075, 1043, 1, 1076, 1044, 1, 1077, 1045, 1, 1078, 1046, 1, 1079, 1047, 1
, 1080, 1048, 1, 1081, 1049, 1, 1082, 1050, 1, 1083, 1051, 1, 1084, 1052, 1, 1085, 1053, 1, 1086, 1054, 1, 1087, 1055, 1, 1088, 1056, 1, 1089, 1057, 1
, 1090, 1058, 1, 1091, 1059, 1, 1092, 1060, 1, 1093, 1061, 1, 1094, 1062, 1, 1095, 1063, 1, 1096, 1064, 1, 1097, 1065, 1, 1098, 1066, 1, 1099, 1067, 1
, 1100, 1068, 1, 1101, 1069, 1, 1102, 1070, 1, 1103, 1071, 1, 1104, 1024, 1, 1105, 1025, 1, 1106, 1026, 1, 1107, 1027, 1, 1108, 1028, 1, 1109, 1029, 1
, 1110, 1030, 1, 1111, 1031, 1, 1112, 1032, 1, 1113, 1033, 1, 1114, 1034, 1, 1115, 1035, 1, 1116, 1036, 1, 1117, 1037, 1, 1118, 1038, 1, 1119, 1039, 1
, 1120, 1121, 2, 1121, 1120, 1, 1122, 1123, 2, 1123, 1122, 1, 1124, 1125, 2, 1125, 1124, 1, 1126, 1127, 2, 1127, 1126, 1, 1128, 1129, 2, 1129, 1128, 1
, 1130, 1131, 2, 1131, 1130, 1, 1132, 1133, 2, 1133, 1132, 1, 1134, 1135, 2, 1135, 1134, 1, 1136, 1137, 2, 1137, 1136, 1, 1138, 1139, 2, 1139, 1138, 1
, 1140, 1141, 2, 1141, 1140, 1, 1142, 1143, 2, 1143, 1142, 1, 1144, 1145, 2, 1145, 1144, 1, 1146, 1147, 2, 1147, 1146, 1, 1148, 1149, 2, 1149, 1148, 1
, 1150, 1151, 2, 1151, 1150, 1, 1152, 1153, 2, 1153, 1152, 1, 1162, 1163, 2, 1163, 1162, 1, 1164, 1165, 2, 1165, 1164, 1, 1166, 1167, 2, 1167, 1166, 1
, 1168, 1169, 2, 1169, 1168, 1, 1170, 1171, 2, 1171, 1170, 1, 1172, 1173, 2, 1173, 1172, 1, 1174, 1175, 2, 1175, 1174, 1, 1176, 1177, 2, 1177, 1176, 1
, 1178, 1179, 2, 1179, 1178, 1, 1180, 1181, 2, 1181, 1180, 1, 1182, 1183, 2, 1183, 1182, 1, 1184, 1185, 2, 1185, 1184, 1, 1186, 1187, 2, 1187, 1186, 1
, 1188, 1189, 2, 1189, 1188, 1, 1190, 1191, 2, 1191, 1190, 1, 1192, 1193, 2, 1193, 1192, 1, 1194, 1195, 2, 1195, 1194, 1, 1196, 1197, 2, 1197, 1196, 1
, 1198, 1199, 2, 1199, 1198, 1, 1200, 1201, 2, 1201, 1200, 1, 1202, 1203, 2, 1203, 1202, 1, 1204, 1205, 2, 1205, 1204, 1, 1206, 1207, 2, 1207, 1206, 1
, 1208, 1209, 2, 1209, 1208, 1, 1210, 1211, 2, 1211, 1210, 1, 1212, 1213, 2, 1213, 1212, 1, 1214, 1215, 2, 1215, 1214, 1, 1216, 1231, 2, 1217, 1218, 2
, 1218, 1217, 1, 1219, 1220, 2, 1220, 1219, 1, 1221, 1222, 2, 1222, 1221, 1, 1223, 1224, 2, 1224, 1223, 1, 1225, 1226, 2, 1226, 1225, 1, 1227, 1228, 2
, 1228, 1227, 1, 1229, 1230, 2, 1230, 1229, 1, 1231, 1216, 1, 1232, 1233, 2, 1233, 1232, 1, 1234, 1235, 2, 1235, 1234, 1, 1236, 1237, 2, 1237, 1236, 1
, 1238, 1239, 2, 1239, 1238, 1, 1240, 1241, 2, 1241, 1240, 1, 1242, 1243, 2, 1243, 1242, 1, 1244, 1245, 2, 1245, 1244, 1, 1246, 1247, 2, 1247, 1246, 1
, 1248, 1249, 2, 1249, 1248, 1, 1250, 1251, 2, 1251, 1250, 1, 1252, 1253, 2, 1253, 1252, 1, 1254, 1255, 2, 1255, 1254, 1, 1256, 1257, 2, 1257, 1256, 1
, 1258, 1259, 2, 1259, 1258, 1, 1260, 1261, 2, 1261, 1260, 1, 1262, 1263, 2, 1263, 1262, 1, 1264, 1265, 2, 1265, 1264, 1, 1266, 1267, 2, 1267, 1266, 1
, 1268, 1269, 2, 1269, 1268, 1, 1270, 1271, 2, 1271, 1270, 1, 1272, 1273, 2, 1273, 1272, 1, 1274, 1275, 2, 1275, 1274, 1, 1276, 1277, 2, 1277, 1276, 1
, 1278, 1279, 2, 1279, 1278, 1, 1280, 1281, 2, 1281, 1280, 1, 1282, 1283, 2, 1283, 1282, 1, 1284, 1285, 2, 1285, 1284, 1, 1286, 1287, 2, 1287, 1286, 1
, 1288, 1289, 2, 1289, 1288, 1, 1290, 1291, 2, 1291, 1290, 1, 1292, 1293, 2, 1293, 1292, 1, 1294, 1295, 2, 1295, 1294, 1, 1296, 1297, 2, 1297, 1296, 1
, 1298, 1299, 2, 1299, 1298, 1, 1300, 1301, 2, 1301, 1300, 1, 1302, 1303, 2, 1303, 1302, 1, 1304, 1305, 2, 1305, 1304, 1, 1306, 1307, 2, 1307, 1306, 1
, 1308, 1309, 2, 1309, 1308, 1, 1310, 1311, 2, 1311, 1310, 1, 1312, 1313, 2, 1313, 1312, 1, 1314, 1315, 2, 1315, 1314, 1, 1316, 1317, 2, 1317, 1316, 1
, 1329, 1377, 2, 1330, 1378, 2, 1331, 1379, 2, 1332, 1380, 2, 1333, 1381, 2, 1334, 1382, 2, 1335, 1383, 2, 1336, 1384, 2, 1337, 1385, 2, 1338, 1386, 2
, 1339, 1387, 2, 1340, 1388, 2, 1341, 1389, 2, 1342, 1390, 2, 1343, 1391, 2, 1344, 1392, 2, 1345, 1393, 2, 1346, 1394, 2, 1347, 1395, 2, 1348, 1396, 2
, 1349, 1397, 2, 1350, 1398, 2, 1351, 1399, 2, 1352, 1400, 2, 1353, 1401, 2, 1354, 1402, 2, 1355, 1403, 2, 1356, 1404, 2, 1357, 1405, 2, 1358, 1406, 2
, 1359, 1407, 2, 1360, 1408, 2, 1361, 1409, 2, 1362, 1410, 2, 1363, 1411, 2, 1364, 1412, 2, 1365, 1413, 2, 1366, 1414, 2, 1369, 1369, 0, 1377, 1329, 1
, 1378, 1330, 1, 1379, 1331, 1, 1380, 1332, 1, 1381, 1333, 1, 1382, 1334, 1, 1383, 1335, 1, 1384, 1336, 1, 1385, 1337, 1, 1386, 1338, 1, 1387, 1339, 1
, 1388, 1340, 1, 1389, 1341, 1, 1390, 1342, 1, 1391, 1343, 1, 1392, 1344, 1, 1393, 1345, 1, 1394, 1346, 1, 1395, 1347, 1, 1396, 1348, 1, 1397, 1349, 1
, 1398, 1350, 1, 1399, 1351, 1, 1400, 1352, 1, 1401, 1353, 1, 1402, 1354, 1, 1403, 1355, 1, 1404, 1356, 1, 1405, 1357, 1, 1406, 1358, 1, 1407, 1359, 1
, 1408, 1360, 1, 1409, 1361, 1, 1410, 1362, 1, 1411, 1363, 1, 1412, 1364, 1, 1413, 1365, 1, 1414, 1366, 1, 1415, 1415, 1
, 1488, 1488, 1, 1489, 1489, 1, 1490, 1490, 1, 1491, 1491, 1, 1492, 1492, 1, 1493, 1493, 1, 1494, 1494, 1, 1495, 1495, 1, 1496, 1496, 1, 1497, 1497, 1
, 1498, 1498, 1, 1499, 1499, 1, 1500, 1500, 1, 1501, 1501, 1, 1502, 1502, 1, 1503, 1503, 1, 1504, 1504, 1, 1505, 1505, 1, 1506, 1506, 1, 1507, 1507, 1
, 1508, 1508, 1, 1509, 1509, 1, 1510, 1510, 1, 1511, 1511, 1, 1512, 1512, 1, 1513, 1513, 1, 1514, 1514, 1
, 1570, 1570, 1, 1571, 1571, 1, 1576, 1576, 1, 1577, 1577, 1, 1578, 1578, 1, 1579, 1579, 1, 1580, 1580, 1, 1581, 1581, 1, 1582, 1582, 1, 1583, 1583, 1
, 1584, 1584, 1, 1585, 1585, 1, 1586, 1586, 1, 1587, 1587, 1, 1588, 1588, 1, 1589, 1589, 1, 1590, 1590, 1, 1591, 1591, 1, 1592, 1592, 1, 1593, 1593, 1
, 1594, 1594, 1, 1601, 1601, 1, 1602, 1602, 1, 1603, 1603, 1, 1604, 1604, 1, 1605, 1605, 1, 1606, 1606, 1, 1607, 1607, 1, 1608, 1608, 1, 1609, 1609, 1
, 1610, 1610, 1, 65153, 65153, 1, 65154, 65154, 1, 65155, 65155, 1, 65156, 65156, 1, 65167, 65167, 1, 65168, 65168, 1, 65169, 65169, 1, 65170, 65170, 1, 65171, 65171, 1
, 65172, 65172, 1, 65173, 65173, 1, 65174, 65174, 1, 65175, 65175, 1, 65176, 65176, 1, 65177, 65177, 1, 65178, 65178, 1, 65179, 65179, 1, 65180, 65180, 1, 65181, 65181, 1
, 65182, 65182, 1, 65183, 65183, 1, 65184, 65184, 1, 65185, 65185, 1, 65186, 65186, 1, 65187, 65187, 1, 65188, 65188, 1, 65189, 65189, 1, 65190, 65190, 1, 65191, 65191, 1
, 65192, 65192, 1, 65193, 65193, 1, 65194, 65194, 1, 65195, 65195, 1, 65196, 65196, 1, 65197, 65197, 1, 65198, 65198, 1, 65199, 65199, 1, 65200, 65200, 1, 65201, 65201, 1
, 65202, 65202, 1, 65203, 65203, 1, 65204, 65204, 1, 65205, 65205, 1, 65206, 65206, 1, 65207, 65207, 1, 65208, 65208, 1, 65209, 65209, 1, 65210, 65210, 1, 65211, 65211, 1
, 65212, 65212, 1, 65213, 65213, 1, 65214, 65214, 1, 65215, 65215, 1, 65216, 65216, 1, 65217, 65217, 1, 65218, 65218, 1, 65219, 65219, 1, 65220, 65220, 1, 65221, 65221, 1
, 65222, 65222, 1, 65223, 65223, 1, 65224, 65224, 1, 65225, 65225, 1, 65226, 65226, 1, 65227, 65227, 1, 65228, 65228, 1, 65229, 65229, 1, 65230, 65230, 1, 65231, 65231, 1
, 65232, 65232, 1, 65233, 65233, 1, 65234, 65234, 1, 65235, 65235, 1, 65236, 65236, 1, 65237, 65237, 1, 65238, 65238, 1, 65239, 65239, 1, 65240, 65240, 1, 65241, 65241, 1
, 65242, 65242, 1, 65243, 65243, 1, 65244, 65244, 1, 65245, 65245, 1, 65246, 65246, 1, 65247, 65247, 1, 65248, 65248, 1, 65249, 65249, 1, 65250, 65250, 1, 65251, 65251, 1
, 65252, 65252, 1, 65253, 65253, 1, 65254, 65254, 1, 65255, 65255, 1, 65256, 65256, 1, 65257, 65257, 1, 65258, 65258, 1, 65259, 65259, 1, 65260, 65260, 1, 65261, 65261, 1
, 65262, 65262, 1, 65263, 65263, 1, 65264, 65264, 1, 65265, 65265, 1, 65266, 65266, 1, 65267, 65267, 1, 65268, 65268, 1, -1 };


static int ponctuations[] = { 0x21, 0x22, 0x23, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E,
0x3F, 0x40, 0x5B, 0x5C, 0x5D, 0x5E, 0x60, 0x7B, 0x7C, 0x7D, 0x7E, 0x9C, 0xA0, 0xA1, 0xA2, 0xA4, 0xA5, 0xA6, 0xAA, 0xAB, 0xAC, 0xAD,
0xAF, 0xB0, 0xB1, 0xB5, 0xB6, 0xB7, 0xB8, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xD7, 0xF7, 0x2BC, 0x2013, 0x2014, 0x2015, 0x2018,
0x2019, 0x201C, 0x201D, 0x2020, 0x2021, 0x2022, 0x2026, 0x2032, 0x2033, 0x203B, 0x212E, 0x2190, 0x2191, 0x2192, 0x2193, 0x2264,
1470, 1472, 1475, 1478, 1523, 1524, 0x2265, 0x263A, 0x3008, 0x3009, 1548, 1549, 1550, 1551, 1567, 1645, 1757, 1758, 1769, 0xFD3E, 0xFD3F, 0 };


static hmap<string, int> htmlcodes;
static hmap<string, string> metacodes;
static hmap<string, int> utf8_to_dos;

static hash_bin<unsigned short, string> dos_to_utf8(false);
static hash_bin<unsigned short, string> codeshtml(false);
static hash_bin<unsigned short, string> vowels(false);
static hash_bin<unsigned short, string> consonants(false);
static hash_bin<unsigned short, string> latinmin(false);
static hash_bin<unsigned short, string> latinmaj(false);

static hash_bin<unsigned short, int> dos2unicode;
static hash_bin<unsigned short, int> unicode2dos;


static hash_short<bool> punctuations(32,11);
static hash_short<BULONG> utf8codemin(32, 11);

static hash_bin<unsigned short, BULONG> utf8codemaj;

static hash_bin<unsigned short, BULONG> wvowels;
static hash_bin<unsigned short, BULONG> wconsonants;

static hash_bin<unsigned short, int> latincodes;
static hash_bin<unsigned short, int> latin2codes;
static hash_bin<unsigned short, int> latin3codes;
static hash_bin<unsigned short, int> latin4codes;
static hash_bin<unsigned short, int> latin5codes;
static hash_bin<unsigned short, int> latin6codes;
static hash_bin<unsigned short, int> latin7codes;
static hash_bin<unsigned short, int> latin8codes;
static hash_bin<unsigned short, int> latin9codes;
static hash_bin<unsigned short, int> latin10codes;
static hash_bin<unsigned short, int> latin11codes;
static hash_bin<unsigned short, int> latin13codes;
static hash_bin<unsigned short, int> latin14codes;
static hash_bin<unsigned short, int> latin15codes;
static hash_bin<unsigned short, int> latin16codes;

static hash_bin<unsigned short, int> codeslatin;
static hash_bin<unsigned short, int> codes2latin;
static hash_bin<unsigned short, int> codes3latin;
static hash_bin<unsigned short, int> codes4latin;
static hash_bin<unsigned short, int> codes5latin;
static hash_bin<unsigned short, int> codes6latin;
static hash_bin<unsigned short, int> codes7latin;
static hash_bin<unsigned short, int> codes8latin;
static hash_bin<unsigned short, int> codes9latin;
static hash_bin<unsigned short, int> codes10latin;
static hash_bin<unsigned short, int> codes11latin;
static hash_bin<unsigned short, int> codes13latin;
static hash_bin<unsigned short, int> codes14latin;
static hash_bin<unsigned short, int> codes15latin;
static hash_bin<unsigned short, int> codes16latin;

static hash_bin<unsigned short, hash_bin<unsigned short, int> > alllatincodes;

static hmap<string, int> utf8codes;
//------------------------------------------------------------------------------------------------------------
static void InitDosCodes() {
	dos_to_utf8[128] = "Ç";
	utf8_to_dos["Ç"] = 128;
	dos2unicode[128] = 199;
	unicode2dos[199] = 128;
	dos_to_utf8[129] = "ü";
	utf8_to_dos["ü"] = 129;
	dos2unicode[129] = 252;
	unicode2dos[252] = 129;
	dos_to_utf8[130] = "é";
	utf8_to_dos["é"] = 130;
	dos2unicode[130] = 233;
	unicode2dos[233] = 130;
	dos_to_utf8[131] = "â";
	utf8_to_dos["â"] = 131;
	dos2unicode[131] = 226;
	unicode2dos[226] = 131;
	dos_to_utf8[132] = "ä";
	utf8_to_dos["ä"] = 132;
	dos2unicode[132] = 228;
	unicode2dos[228] = 132;
	dos_to_utf8[133] = "à";
	utf8_to_dos["à"] = 133;
	dos2unicode[133] = 224;
	unicode2dos[224] = 133;
	dos_to_utf8[134] = "å";
	utf8_to_dos["å"] = 134;
	dos2unicode[134] = 229;
	unicode2dos[229] = 134;
	dos_to_utf8[135] = "ç";
	utf8_to_dos["ç"] = 135;
	dos2unicode[135] = 231;
	unicode2dos[231] = 135;
	dos_to_utf8[136] = "ê";
	utf8_to_dos["ê"] = 136;
	dos2unicode[136] = 234;
	unicode2dos[234] = 136;
	dos_to_utf8[137] = "ë";
	utf8_to_dos["ë"] = 137;
	dos2unicode[137] = 235;
	unicode2dos[235] = 137;
	dos_to_utf8[138] = "è";
	utf8_to_dos["è"] = 138;
	dos2unicode[138] = 232;
	unicode2dos[232] = 138;
	dos_to_utf8[139] = "ï";
	utf8_to_dos["ï"] = 139;
	dos2unicode[139] = 239;
	unicode2dos[239] = 139;
	dos_to_utf8[140] = "î";
	utf8_to_dos["î"] = 140;
	dos2unicode[140] = 238;
	unicode2dos[238] = 140;
	dos_to_utf8[141] = "ì";
	utf8_to_dos["ì"] = 141;
	dos2unicode[141] = 236;
	unicode2dos[236] = 141;
	dos_to_utf8[142] = "Ä";
	utf8_to_dos["Ä"] = 142;
	dos2unicode[142] = 196;
	unicode2dos[196] = 142;
	dos_to_utf8[143] = "Å";
	utf8_to_dos["Å"] = 143;
	dos2unicode[143] = 197;
	unicode2dos[197] = 143;
	dos_to_utf8[144] = "É";
	utf8_to_dos["É"] = 144;
	dos2unicode[144] = 201;
	unicode2dos[201] = 144;
	dos_to_utf8[145] = "æ";
	utf8_to_dos["æ"] = 145;
	dos2unicode[145] = 230;
	unicode2dos[230] = 145;
	dos_to_utf8[146] = "Æ";
	utf8_to_dos["Æ"] = 146;
	dos2unicode[146] = 198;
	unicode2dos[198] = 146;
	dos_to_utf8[147] = "ô";
	utf8_to_dos["ô"] = 147;
	dos2unicode[147] = 244;
	unicode2dos[244] = 147;
	dos_to_utf8[148] = "ö";
	utf8_to_dos["ö"] = 148;
	dos2unicode[148] = 246;
	unicode2dos[246] = 148;
	dos_to_utf8[149] = "ò";
	utf8_to_dos["ò"] = 149;
	dos2unicode[149] = 242;
	unicode2dos[242] = 149;
	dos_to_utf8[150] = "û";
	utf8_to_dos["û"] = 150;
	dos2unicode[150] = 251;
	unicode2dos[251] = 150;
	dos_to_utf8[151] = "ù";
	utf8_to_dos["ù"] = 151;
	dos2unicode[151] = 249;
	unicode2dos[249] = 151;
	dos_to_utf8[152] = "ÿ";
	utf8_to_dos["ÿ"] = 152;
	dos2unicode[152] = 255;
	unicode2dos[255] = 152;
	dos_to_utf8[153] = "Ö";
	utf8_to_dos["Ö"] = 153;
	dos2unicode[153] = 214;
	unicode2dos[214] = 153;
	dos_to_utf8[154] = "Ü";
	utf8_to_dos["Ü"] = 154;
	dos2unicode[154] = 220;
	unicode2dos[220] = 154;
	dos_to_utf8[155] = "¢";
	utf8_to_dos["¢"] = 155;
	dos2unicode[155] = 162;
	unicode2dos[162] = 155;
	dos_to_utf8[156] = "£";
	utf8_to_dos["£"] = 156;
	dos2unicode[156] = 163;
	unicode2dos[163] = 156;
	dos_to_utf8[157] = "¥";
	utf8_to_dos["¥"] = 157;
	dos2unicode[157] = 165;
	unicode2dos[165] = 157;
	dos_to_utf8[158] = "₧";
	utf8_to_dos["₧"] = 158;
	dos2unicode[158] = 8359;
	unicode2dos[8359] = 158;
	dos_to_utf8[159] = "ƒ";
	utf8_to_dos["ƒ"] = 159;
	dos2unicode[159] = 402;
	unicode2dos[402] = 159;
	dos_to_utf8[160] = "á";
	utf8_to_dos["á"] = 160;
	dos2unicode[160] = 225;
	unicode2dos[225] = 160;
	dos_to_utf8[161] = "í";
	utf8_to_dos["í"] = 161;
	dos2unicode[161] = 237;
	unicode2dos[237] = 161;
	dos_to_utf8[162] = "ó";
	utf8_to_dos["ó"] = 162;
	dos2unicode[162] = 243;
	unicode2dos[243] = 162;
	dos_to_utf8[163] = "ú";
	utf8_to_dos["ú"] = 163;
	dos2unicode[163] = 250;
	unicode2dos[250] = 163;
	dos_to_utf8[164] = "ñ";
	utf8_to_dos["ñ"] = 164;
	dos2unicode[164] = 241;
	unicode2dos[241] = 164;
	dos_to_utf8[165] = "Ñ";
	utf8_to_dos["Ñ"] = 165;
	dos2unicode[165] = 209;
	unicode2dos[209] = 165;
	dos_to_utf8[166] = "ª";
	utf8_to_dos["ª"] = 166;
	dos2unicode[166] = 170;
	unicode2dos[170] = 166;
	dos_to_utf8[167] = "º";
	utf8_to_dos["º"] = 167;
	dos2unicode[167] = 186;
	unicode2dos[186] = 167;
	dos_to_utf8[168] = "¿";
	utf8_to_dos["¿"] = 168;
	dos2unicode[168] = 191;
	unicode2dos[191] = 168;
	dos_to_utf8[169] = "⌐";
	utf8_to_dos["⌐"] = 169;
	dos2unicode[169] = 8976;
	unicode2dos[8976] = 169;
	dos_to_utf8[170] = "¬";
	utf8_to_dos["¬"] = 170;
	dos2unicode[170] = 172;
	unicode2dos[172] = 170;
	dos_to_utf8[171] = "½";
	utf8_to_dos["½"] = 171;
	dos2unicode[171] = 189;
	unicode2dos[189] = 171;
	dos_to_utf8[172] = "¼";
	utf8_to_dos["¼"] = 172;
	dos2unicode[172] = 188;
	unicode2dos[188] = 172;
	dos_to_utf8[173] = "¡";
	utf8_to_dos["¡"] = 173;
	dos2unicode[173] = 161;
	unicode2dos[161] = 173;
	dos_to_utf8[174] = "«";
	utf8_to_dos["«"] = 174;
	dos2unicode[174] = 171;
	unicode2dos[171] = 174;
	dos_to_utf8[175] = "»";
	utf8_to_dos["»"] = 175;
	dos2unicode[175] = 187;
	unicode2dos[187] = 175;
	dos_to_utf8[176] = "░";
	utf8_to_dos["░"] = 176;
	dos2unicode[176] = 9617;
	unicode2dos[9617] = 176;
	dos_to_utf8[177] = "▒";
	utf8_to_dos["▒"] = 177;
	dos2unicode[177] = 9618;
	unicode2dos[9618] = 177;
	dos_to_utf8[178] = "▓";
	utf8_to_dos["▓"] = 178;
	dos2unicode[178] = 9619;
	unicode2dos[9619] = 178;
	dos_to_utf8[179] = "│";
	utf8_to_dos["│"] = 179;
	dos2unicode[179] = 9474;
	unicode2dos[9474] = 179;
	dos_to_utf8[180] = "┤";
	utf8_to_dos["┤"] = 180;
	dos2unicode[180] = 9508;
	unicode2dos[9508] = 180;
	dos_to_utf8[181] = "Á";
	utf8_to_dos["Á"] = 181;
	dos2unicode[181] = 193;
	unicode2dos[193] = 181;
	dos_to_utf8[182] = "Â";
	utf8_to_dos["Â"] = 182;
	dos2unicode[182] = 194;
	unicode2dos[194] = 182;
	dos_to_utf8[183] = "À";
	utf8_to_dos["À"] = 192;
	dos2unicode[183] = 192;
	unicode2dos[192] = 183;
	dos_to_utf8[184] = "╕";
	utf8_to_dos["╕"] = 184;
	dos2unicode[184] = 9557;
	unicode2dos[9557] = 184;
	dos_to_utf8[185] = "╣";
	utf8_to_dos["╣"] = 185;
	dos2unicode[185] = 9571;
	unicode2dos[9571] = 185;
	dos_to_utf8[186] = "║";
	utf8_to_dos["║"] = 186;
	dos2unicode[186] = 9553;
	unicode2dos[9553] = 186;
	dos_to_utf8[187] = "╗";
	utf8_to_dos["╗"] = 187;
	dos2unicode[187] = 9559;
	unicode2dos[9559] = 187;
	dos_to_utf8[188] = "╝";
	utf8_to_dos["╝"] = 188;
	dos2unicode[188] = 9565;
	unicode2dos[9565] = 188;
	dos_to_utf8[189] = "╜";
	utf8_to_dos["╜"] = 189;
	dos2unicode[189] = 9564;
	unicode2dos[9564] = 189;
	dos_to_utf8[190] = "╛";
	utf8_to_dos["╛"] = 190;
	dos2unicode[190] = 9563;
	unicode2dos[9563] = 190;
	dos_to_utf8[191] = "┐";
	utf8_to_dos["┐"] = 191;
	dos2unicode[191] = 9488;
	unicode2dos[9488] = 191;
	dos_to_utf8[192] = "└";
	utf8_to_dos["└"] = 192;
	dos2unicode[192] = 9492;
	unicode2dos[9492] = 192;
	dos_to_utf8[193] = "┴";
	utf8_to_dos["┴"] = 193;
	dos2unicode[193] = 9524;
	unicode2dos[9524] = 193;
	dos_to_utf8[194] = "┬";
	utf8_to_dos["┬"] = 194;
	dos2unicode[194] = 9516;
	unicode2dos[9516] = 194;
	dos_to_utf8[195] = "├";
	utf8_to_dos["├"] = 195;
	dos2unicode[195] = 9500;
	unicode2dos[9500] = 195;
	dos_to_utf8[196] = "─";
	utf8_to_dos["─"] = 196;
	dos2unicode[196] = 9472;
	unicode2dos[9472] = 196;
	dos_to_utf8[197] = "┼";
	utf8_to_dos["┼"] = 197;
	dos2unicode[197] = 9532;
	unicode2dos[9532] = 197;
	dos_to_utf8[198] = "╞";
	utf8_to_dos["╞"] = 198;
	dos2unicode[198] = 9566;
	unicode2dos[9566] = 198;
	dos_to_utf8[199] = "╟";
	utf8_to_dos["╟"] = 199;
	dos2unicode[199] = 9567;
	unicode2dos[9567] = 199;
	dos_to_utf8[200] = "╚";
	utf8_to_dos["╚"] = 200;
	dos2unicode[200] = 9562;
	unicode2dos[9562] = 200;
	dos_to_utf8[201] = "╔";
	utf8_to_dos["╔"] = 201;
	dos2unicode[201] = 9556;
	unicode2dos[9556] = 201;
	dos_to_utf8[202] = "╩";
	utf8_to_dos["╩"] = 202;
	dos2unicode[202] = 9577;
	unicode2dos[9577] = 202;
	dos_to_utf8[203] = "╦";
	utf8_to_dos["╦"] = 203;
	dos2unicode[203] = 9574;
	unicode2dos[9574] = 203;
	dos_to_utf8[204] = "╠";
	utf8_to_dos["╠"] = 204;
	dos2unicode[204] = 9568;
	unicode2dos[9568] = 204;
	dos_to_utf8[205] = "═";
	utf8_to_dos["═"] = 205;
	dos2unicode[205] = 9552;
	unicode2dos[9552] = 205;
	dos_to_utf8[206] = "╬";
	utf8_to_dos["╬"] = 206;
	dos2unicode[206] = 9580;
	unicode2dos[9580] = 206;
	dos_to_utf8[207] = "╧";
	utf8_to_dos["╧"] = 207;
	dos2unicode[207] = 9575;
	unicode2dos[9575] = 207;
	dos_to_utf8[208] = "╨";
	utf8_to_dos["╨"] = 208;
	dos2unicode[208] = 9576;
	unicode2dos[9576] = 208;
	dos_to_utf8[209] = "╤";
	utf8_to_dos["╤"] = 209;
	dos2unicode[209] = 9572;
	unicode2dos[9572] = 209;
	dos_to_utf8[210] = "╥";
	utf8_to_dos["╥"] = 210;
	dos2unicode[210] = 9573;
	unicode2dos[9573] = 210;
	dos_to_utf8[211] = "╙";
	utf8_to_dos["╙"] = 211;
	dos2unicode[211] = 9561;
	unicode2dos[9561] = 211;
	dos_to_utf8[212] = "╘";
	utf8_to_dos["╘"] = 212;
	dos2unicode[212] = 9560;
	unicode2dos[9560] = 212;
	dos_to_utf8[213] = "╒";
	utf8_to_dos["╒"] = 213;
	dos2unicode[213] = 9554;
	unicode2dos[9554] = 213;
	dos_to_utf8[214] = "╓";
	utf8_to_dos["╓"] = 214;
	dos2unicode[214] = 9555;
	unicode2dos[9555] = 214;
	dos_to_utf8[215] = "╫";
	utf8_to_dos["╫"] = 215;
	dos2unicode[215] = 9579;
	unicode2dos[9579] = 215;
	dos_to_utf8[216] = "╪";
	utf8_to_dos["╪"] = 216;
	dos2unicode[216] = 9578;
	unicode2dos[9578] = 216;
	dos_to_utf8[217] = "┘";
	utf8_to_dos["┘"] = 217;
	dos2unicode[217] = 9496;
	unicode2dos[9496] = 217;
	dos_to_utf8[218] = "┌";
	utf8_to_dos["┌"] = 218;
	dos2unicode[218] = 9484;
	unicode2dos[9484] = 218;
	dos_to_utf8[219] = "█";
	utf8_to_dos["█"] = 219;
	dos2unicode[219] = 9608;
	unicode2dos[9608] = 219;
	dos_to_utf8[220] = "▄";
	utf8_to_dos["▄"] = 220;
	dos2unicode[220] = 9604;
	unicode2dos[9604] = 220;
	dos_to_utf8[221] = "▌";
	utf8_to_dos["▌"] = 221;
	dos2unicode[221] = 9612;
	unicode2dos[9612] = 221;
	dos_to_utf8[222] = "▐";
	utf8_to_dos["▐"] = 222;
	dos2unicode[222] = 9616;
	unicode2dos[9616] = 222;
	dos_to_utf8[223] = "▀";
	utf8_to_dos["▀"] = 223;
	dos2unicode[223] = 9600;
	unicode2dos[9600] = 223;
	dos_to_utf8[224] = "α";
	utf8_to_dos["α"] = 224;
	dos2unicode[224] = 945;
	unicode2dos[945] = 224;
	dos_to_utf8[225] = "ß";
	utf8_to_dos["ß"] = 225;
	dos2unicode[225] = 223;
	unicode2dos[223] = 225;
	dos_to_utf8[226] = "Γ";
	utf8_to_dos["Γ"] = 226;
	dos2unicode[226] = 915;
	unicode2dos[915] = 226;
	dos_to_utf8[227] = "π";
	utf8_to_dos["π"] = 227;
	dos2unicode[227] = 960;
	unicode2dos[960] = 227;
	dos_to_utf8[228] = "Σ";
	utf8_to_dos["Σ"] = 228;
	dos2unicode[228] = 931;
	unicode2dos[931] = 228;
	dos_to_utf8[229] = "σ";
	utf8_to_dos["σ"] = 229;
	dos2unicode[229] = 963;
	unicode2dos[963] = 229;
	dos_to_utf8[230] = "µ";
	utf8_to_dos["µ"] = 230;
	dos2unicode[230] = 181;
	unicode2dos[181] = 230;
	dos_to_utf8[231] = "τ";
	utf8_to_dos["τ"] = 231;
	dos2unicode[231] = 964;
	unicode2dos[964] = 231;
	dos_to_utf8[232] = "Φ";
	utf8_to_dos["Φ"] = 232;
	dos2unicode[232] = 934;
	unicode2dos[934] = 232;
	dos_to_utf8[233] = "Θ";
	utf8_to_dos["Θ"] = 233;
	dos2unicode[233] = 920;
	unicode2dos[920] = 233;
	dos_to_utf8[234] = "Ω";
	utf8_to_dos["Ω"] = 234;
	dos2unicode[234] = 937;
	unicode2dos[937] = 234;
	dos_to_utf8[235] = "δ";
	utf8_to_dos["δ"] = 235;
	dos2unicode[235] = 948;
	unicode2dos[948] = 235;
	dos_to_utf8[236] = "∞";
	utf8_to_dos["∞"] = 236;
	dos2unicode[236] = 8734;
	unicode2dos[8734] = 236;
	dos_to_utf8[237] = "φ";
	utf8_to_dos["φ"] = 237;
	dos2unicode[237] = 966;
	unicode2dos[966] = 237;
	dos_to_utf8[238] = "ε";
	utf8_to_dos["ε"] = 238;
	dos2unicode[238] = 949;
	unicode2dos[949] = 238;
	dos_to_utf8[239] = "∩";
	utf8_to_dos["∩"] = 239;
	dos2unicode[239] = 8745;
	unicode2dos[8745] = 239;
	dos_to_utf8[240] = "≡";
	utf8_to_dos["≡"] = 240;
	dos2unicode[240] = 8801;
	unicode2dos[8801] = 240;
	dos_to_utf8[241] = "±";
	utf8_to_dos["±"] = 241;
	dos2unicode[241] = 177;
	unicode2dos[177] = 241;
	dos_to_utf8[242] = "≥";
	utf8_to_dos["≥"] = 242;
	dos2unicode[242] = 8805;
	unicode2dos[8805] = 242;
	dos_to_utf8[243] = "≤";
	utf8_to_dos["≤"] = 243;
	dos2unicode[243] = 8804;
	unicode2dos[8804] = 243;
	dos_to_utf8[244] = "⌠";
	utf8_to_dos["⌠"] = 244;
	dos2unicode[244] = 8992;
	unicode2dos[8992] = 244;
	dos_to_utf8[245] = "⌡";
	utf8_to_dos["⌡"] = 245;
	dos2unicode[245] = 8993;
	unicode2dos[8993] = 245;
	dos_to_utf8[246] = "÷";
	utf8_to_dos["÷"] = 246;
	dos2unicode[246] = 247;
	unicode2dos[247] = 246;
	dos_to_utf8[247] = "≈";
	utf8_to_dos["≈"] = 247;
	dos2unicode[247] = 8776;
	unicode2dos[8776] = 247;
	dos_to_utf8[248] = "°";
	utf8_to_dos["°"] = 248;
	dos2unicode[248] = 176;
	unicode2dos[176] = 248;
	dos_to_utf8[249] = "∙";
	utf8_to_dos["∙"] = 249;
	dos2unicode[249] = 8729;
	unicode2dos[8729] = 249;
	dos_to_utf8[250] = "·";
	utf8_to_dos["·"] = 250;
	dos2unicode[250] = 183;
	unicode2dos[183] = 250;
	dos_to_utf8[251] = "√";
	utf8_to_dos["√"] = 251;
	dos2unicode[251] = 8730;
	unicode2dos[8730] = 251;
	dos_to_utf8[252] = "ⁿ";
	utf8_to_dos["ⁿ"] = 252;
	dos2unicode[252] = 8319;
	unicode2dos[8319] = 252;
	dos_to_utf8[253] = "²";
	utf8_to_dos["²"] = 253;
	dos2unicode[253] = 178;
	unicode2dos[178] = 253;
	dos_to_utf8[254] = "■";
	utf8_to_dos["■"] = 254;
	dos2unicode[254] = 9632;
	unicode2dos[9632] = 254;
}

static void InitHtmlCodes() {
	metacodes["\\n"] = "\n";
	metacodes["\\r"] = "\r";
	metacodes["\\\""] = "\"";
	metacodes["\\t"] = "\t";

	codeshtml[34] = "&quot;";
	codeshtml[38] = "&amp;";
	codeshtml[39] = "&apos;";
	codeshtml[60] = "&lt;";
	codeshtml[62] = "&gt;";
	codeshtml[160] = "&nbsp;";
	codeshtml[161] = "&iexcl;";
	codeshtml[162] = "&cent;";
	codeshtml[163] = "&pound;";
	codeshtml[164] = "&curren;";
	codeshtml[165] = "&yen;";
	codeshtml[166] = "&brvbar;";
	codeshtml[167] = "&sect;";
	codeshtml[168] = "&uml;";
	codeshtml[169] = "&copy;";
	codeshtml[170] = "&ordf;";
	codeshtml[171] = "&laquo;";
	codeshtml[172] = "&not;";
	codeshtml[173] = "&shy;";
	codeshtml[174] = "&reg;";
	codeshtml[175] = "&macr;";
	codeshtml[176] = "&deg;";
	codeshtml[177] = "&plusmn;";
	codeshtml[178] = "&sup2;";
	codeshtml[179] = "&sup3;";
	codeshtml[180] = "&acute;";
	codeshtml[181] = "&micro;";
	codeshtml[182] = "&para;";
	codeshtml[183] = "&middot;";
	codeshtml[184] = "&cedil;";
	codeshtml[185] = "&sup1;";
	codeshtml[186] = "&ordm;";
	codeshtml[187] = "&raquo;";
	codeshtml[188] = "&frac14;";
	codeshtml[189] = "&frac12;";
	codeshtml[190] = "&frac34;";
	codeshtml[191] = "&iquest;";
	codeshtml[192] = "&Agrave;";
	codeshtml[193] = "&Aacute;";
	codeshtml[194] = "&Acirc;";
	codeshtml[195] = "&Atilde;";
	codeshtml[196] = "&Auml;";
	codeshtml[197] = "&Aring;";
	codeshtml[198] = "&AElig;";
	codeshtml[199] = "&Ccedil;";
	codeshtml[200] = "&Egrave;";
	codeshtml[201] = "&Eacute;";
	codeshtml[202] = "&Ecirc;";
	codeshtml[203] = "&Euml;";
	codeshtml[204] = "&Igrave;";
	codeshtml[205] = "&Iacute;";
	codeshtml[206] = "&Icirc;";
	codeshtml[207] = "&Iuml;";
	codeshtml[208] = "&ETH;";
	codeshtml[209] = "&Ntilde;";
	codeshtml[210] = "&Ograve;";
	codeshtml[211] = "&Oacute;";
	codeshtml[212] = "&Ocirc;";
	codeshtml[213] = "&Otilde;";
	codeshtml[214] = "&Ouml;";
	codeshtml[215] = "&times;";
	codeshtml[216] = "&Oslash;";
	codeshtml[217] = "&Ugrave;";
	codeshtml[218] = "&Uacute;";
	codeshtml[219] = "&Ucirc;";
	codeshtml[220] = "&Uuml;";
	codeshtml[221] = "&Yacute;";
	codeshtml[222] = "&THORN;";
	codeshtml[223] = "&szlig;";
	codeshtml[224] = "&agrave;";
	codeshtml[225] = "&aacute;";
	codeshtml[226] = "&acirc;";
	codeshtml[227] = "&atilde;";
	codeshtml[228] = "&auml;";
	codeshtml[229] = "&aring;";
	codeshtml[230] = "&aelig;";
	codeshtml[231] = "&ccedil;";
	codeshtml[232] = "&egrave;";
	codeshtml[233] = "&eacute;";
	codeshtml[234] = "&ecirc;";
	codeshtml[235] = "&euml;";
	codeshtml[236] = "&igrave;";
	codeshtml[237] = "&iacute;";
	codeshtml[238] = "&icirc;";
	codeshtml[239] = "&iuml;";
	codeshtml[240] = "&eth;";
	codeshtml[241] = "&ntilde;";
	codeshtml[242] = "&ograve;";
	codeshtml[243] = "&oacute;";
	codeshtml[244] = "&ocirc;";
	codeshtml[245] = "&otilde;";
	codeshtml[246] = "&ouml;";
	codeshtml[247] = "&divide;";
	codeshtml[248] = "&oslash;";
	codeshtml[249] = "&ugrave;";
	codeshtml[250] = "&uacute;";
	codeshtml[251] = "&ucirc;";
	codeshtml[252] = "&uuml;";
	codeshtml[253] = "&yacute;";
	codeshtml[254] = "&thorn;";
	codeshtml[255] = "&yuml;";
	codeshtml[338] = "&OElig;";
	codeshtml[339] = "&oelig;";
	codeshtml[352] = "&Scaron;";
	codeshtml[353] = "&scaron;";
	codeshtml[376] = "&Yuml;";
	codeshtml[402] = "&fnof;";
	codeshtml[710] = "&circ;";
	codeshtml[732] = "&tilde;";
	codeshtml[913] = "&Alpha;";
	codeshtml[914] = "&Beta;";
	codeshtml[915] = "&Gamma;";
	codeshtml[916] = "&Delta;";
	codeshtml[917] = "&Epsilon;";
	codeshtml[918] = "&Zeta;";
	codeshtml[919] = "&Eta;";
	codeshtml[920] = "&Theta;";
	codeshtml[921] = "&Iota;";
	codeshtml[922] = "&Kappa;";
	codeshtml[923] = "&Lambda;";
	codeshtml[924] = "&Mu;";
	codeshtml[925] = "&Nu;";
	codeshtml[926] = "&Xi;";
	codeshtml[927] = "&Omicron;";
	codeshtml[928] = "&Pi;";
	codeshtml[929] = "&Rho;";
	codeshtml[931] = "&Sigma;";
	codeshtml[932] = "&Tau;";
	codeshtml[933] = "&Upsilon;";
	codeshtml[934] = "&Phi;";
	codeshtml[935] = "&Chi;";
	codeshtml[936] = "&Psi;";
	codeshtml[937] = "&Omega;";
	codeshtml[945] = "&alpha;";
	codeshtml[946] = "&beta;";
	codeshtml[947] = "&gamma;";
	codeshtml[948] = "&delta;";
	codeshtml[949] = "&epsilon;";
	codeshtml[950] = "&zeta;";
	codeshtml[951] = "&eta;";
	codeshtml[952] = "&theta;";
	codeshtml[953] = "&iota;";
	codeshtml[954] = "&kappa;";
	codeshtml[955] = "&lambda;";
	codeshtml[956] = "&mu;";
	codeshtml[957] = "&nu;";
	codeshtml[958] = "&xi;";
	codeshtml[959] = "&omicron;";
	codeshtml[960] = "&pi;";
	codeshtml[961] = "&rho;";
	codeshtml[962] = "&sigmaf;";
	codeshtml[963] = "&sigma;";
	codeshtml[964] = "&tau;";
	codeshtml[965] = "&upsilon;";
	codeshtml[966] = "&phi;";
	codeshtml[967] = "&chi;";
	codeshtml[968] = "&psi;";
	codeshtml[969] = "&omega;";
	codeshtml[977] = "&thetasym;";
	codeshtml[978] = "&upsih;";
	codeshtml[982] = "&piv;";
	codeshtml[8194] = "&ensp;";
	codeshtml[8195] = "&emsp;";
	codeshtml[8201] = "&thinsp;";
	codeshtml[8204] = "&zwnj;";
	codeshtml[8205] = "&zwj;";
	codeshtml[8206] = "&lrm;";
	codeshtml[8207] = "&rlm;";
	codeshtml[8211] = "&ndash;";
	codeshtml[8212] = "&mdash;";
	codeshtml[8216] = "&lsquo;";
	codeshtml[8217] = "&rsquo;";
	codeshtml[8218] = "&sbquo;";
	codeshtml[8220] = "&ldquo;";
	codeshtml[8221] = "&rdquo;";
	codeshtml[8222] = "&bdquo;";
	codeshtml[8224] = "&dagger;";
	codeshtml[8225] = "&Dagger;";
	codeshtml[8226] = "&bull;";
	codeshtml[8230] = "&hellip;";
	codeshtml[8240] = "&permil;";
	codeshtml[8242] = "&prime;";
	codeshtml[8243] = "&Prime;";
	codeshtml[8249] = "&lsaquo;";
	codeshtml[8250] = "&rsaquo;";
	codeshtml[8254] = "&oline;";
	codeshtml[8260] = "&frasl;";
	codeshtml[8364] = "&euro;";
	codeshtml[8465] = "&image;";
	codeshtml[8472] = "&weierp;";
	codeshtml[8476] = "&real;";
	codeshtml[8482] = "&trade;";
	codeshtml[8501] = "&alefsym;";
	codeshtml[8592] = "&larr;";
	codeshtml[8593] = "&uarr;";
	codeshtml[8594] = "&rarr;";
	codeshtml[8595] = "&darr;";
	codeshtml[8596] = "&harr;";
	codeshtml[8629] = "&crarr;";
	codeshtml[8656] = "&lArr;";
	codeshtml[8657] = "&uArr;";
	codeshtml[8658] = "&rArr;";
	codeshtml[8659] = "&dArr;";
	codeshtml[8660] = "&hArr;";
	codeshtml[8704] = "&forall;";
	codeshtml[8706] = "&part;";
	codeshtml[8707] = "&exist;";
	codeshtml[8709] = "&empty;";
	codeshtml[8711] = "&nabla;";
	codeshtml[8712] = "&isin;";
	codeshtml[8713] = "&notin;";
	codeshtml[8715] = "&ni;";
	codeshtml[8719] = "&prod;";
	codeshtml[8721] = "&sum;";
	codeshtml[8722] = "&minus;";
	codeshtml[8727] = "&lowast;";
	codeshtml[8730] = "&radic;";
	codeshtml[8733] = "&prop;";
	codeshtml[8734] = "&infin;";
	codeshtml[8736] = "&ang;";
	codeshtml[8743] = "&and;";
	codeshtml[8744] = "&or;";
	codeshtml[8745] = "&cap;";
	codeshtml[8746] = "&cup;";
	codeshtml[8747] = "&int;";
	codeshtml[8756] = "&there4;";
	codeshtml[8764] = "&sim;";
	codeshtml[8773] = "&cong;";
	codeshtml[8776] = "&asymp;";
	codeshtml[8800] = "&ne;";
	codeshtml[8801] = "&equiv;";
	codeshtml[8804] = "&le;";
	codeshtml[8805] = "&ge;";
	codeshtml[8834] = "&sub;";
	codeshtml[8835] = "&sup;";
	codeshtml[8836] = "&nsub;";
	codeshtml[8838] = "&sube;";
	codeshtml[8839] = "&supe;";
	codeshtml[8853] = "&oplus;";
	codeshtml[8855] = "&otimes;";
	codeshtml[8869] = "&perp;";
	codeshtml[8901] = "&sdot;";
	codeshtml[8968] = "&lceil;";
	codeshtml[8969] = "&rceil;";
	codeshtml[8970] = "&lfloor;";
	codeshtml[8971] = "&rfloor;";
	codeshtml[9001] = "&lang;";
	codeshtml[9002] = "&rang;";
	codeshtml[9674] = "&loz;";
	codeshtml[9824] = "&spades;";
	codeshtml[9827] = "&clubs;";
	codeshtml[9829] = "&hearts;";
	codeshtml[9830] = "&diams;";

	htmlcodes["&quot;"] = 34;
	htmlcodes["&amp;"] = 38;
	htmlcodes["&apos;"] = 39;
	htmlcodes["&lt;"] = 60;
	htmlcodes["&gt;"] = 62;
	htmlcodes["&nbsp;"] = 160;
	htmlcodes["&iexcl;"] = 161;
	htmlcodes["&cent;"] = 162;
	htmlcodes["&pound;"] = 163;
	htmlcodes["&curren;"] = 164;
	htmlcodes["&yen;"] = 165;
	htmlcodes["&brvbar;"] = 166;
	htmlcodes["&sect;"] = 167;
	htmlcodes["&uml;"] = 168;
	htmlcodes["&copy;"] = 169;
	htmlcodes["&ordf;"] = 170;
	htmlcodes["&laquo;"] = 171;
	htmlcodes["&not;"] = 172;
	htmlcodes["&shy;"] = 173;
	htmlcodes["&reg;"] = 174;
	htmlcodes["&macr;"] = 175;
	htmlcodes["&deg;"] = 176;
	htmlcodes["&plusmn;"] = 177;
	htmlcodes["&sup2;"] = 178;
	htmlcodes["&sup3;"] = 179;
	htmlcodes["&acute;"] = 180;
	htmlcodes["&micro;"] = 181;
	htmlcodes["&para;"] = 182;
	htmlcodes["&middot;"] = 183;
	htmlcodes["&cedil;"] = 184;
	htmlcodes["&sup1;"] = 185;
	htmlcodes["&ordm;"] = 186;
	htmlcodes["&raquo;"] = 187;
	htmlcodes["&frac14;"] = 188;
	htmlcodes["&frac12;"] = 189;
	htmlcodes["&frac34;"] = 190;
	htmlcodes["&iquest;"] = 191;
	htmlcodes["&Agrave;"] = 192;
	htmlcodes["&Aacute;"] = 193;
	htmlcodes["&Acirc;"] = 194;
	htmlcodes["&Atilde;"] = 195;
	htmlcodes["&Auml;"] = 196;
	htmlcodes["&Aring;"] = 197;
	htmlcodes["&AElig;"] = 198;
	htmlcodes["&Ccedil;"] = 199;
	htmlcodes["&Egrave;"] = 200;
	htmlcodes["&Eacute;"] = 201;
	htmlcodes["&Ecirc;"] = 202;
	htmlcodes["&Euml;"] = 203;
	htmlcodes["&Igrave;"] = 204;
	htmlcodes["&Iacute;"] = 205;
	htmlcodes["&Icirc;"] = 206;
	htmlcodes["&Iuml;"] = 207;
	htmlcodes["&ETH;"] = 208;
	htmlcodes["&Ntilde;"] = 209;
	htmlcodes["&Ograve;"] = 210;
	htmlcodes["&Oacute;"] = 211;
	htmlcodes["&Ocirc;"] = 212;
	htmlcodes["&Otilde;"] = 213;
	htmlcodes["&Ouml;"] = 214;
	htmlcodes["&times;"] = 215;
	htmlcodes["&Oslash;"] = 216;
	htmlcodes["&Ugrave;"] = 217;
	htmlcodes["&Uacute;"] = 218;
	htmlcodes["&Ucirc;"] = 219;
	htmlcodes["&Uuml;"] = 220;
	htmlcodes["&Yacute;"] = 221;
	htmlcodes["&THORN;"] = 222;
	htmlcodes["&szlig;"] = 223;
	htmlcodes["&agrave;"] = 224;
	htmlcodes["&aacute;"] = 225;
	htmlcodes["&acirc;"] = 226;
	htmlcodes["&atilde;"] = 227;
	htmlcodes["&auml;"] = 228;
	htmlcodes["&aring;"] = 229;
	htmlcodes["&aelig;"] = 230;
	htmlcodes["&ccedil;"] = 231;
	htmlcodes["&egrave;"] = 232;
	htmlcodes["&eacute;"] = 233;
	htmlcodes["&ecirc;"] = 234;
	htmlcodes["&euml;"] = 235;
	htmlcodes["&igrave;"] = 236;
	htmlcodes["&iacute;"] = 237;
	htmlcodes["&icirc;"] = 238;
	htmlcodes["&iuml;"] = 239;
	htmlcodes["&eth;"] = 240;
	htmlcodes["&ntilde;"] = 241;
	htmlcodes["&ograve;"] = 242;
	htmlcodes["&oacute;"] = 243;
	htmlcodes["&ocirc;"] = 244;
	htmlcodes["&otilde;"] = 245;
	htmlcodes["&ouml;"] = 246;
	htmlcodes["&divide;"] = 247;
	htmlcodes["&oslash;"] = 248;
	htmlcodes["&ugrave;"] = 249;
	htmlcodes["&uacute;"] = 250;
	htmlcodes["&ucirc;"] = 251;
	htmlcodes["&uuml;"] = 252;
	htmlcodes["&yacute;"] = 253;
	htmlcodes["&thorn;"] = 254;
	htmlcodes["&yuml;"] = 255;
	htmlcodes["&OElig;"] = 338;
	htmlcodes["&oelig;"] = 339;
	htmlcodes["&Scaron;"] = 352;
	htmlcodes["&scaron;"] = 353;
	htmlcodes["&Yuml;"] = 376;
	htmlcodes["&fnof;"] = 402;
	htmlcodes["&circ;"] = 710;
	htmlcodes["&tilde;"] = 732;
	htmlcodes["&Alpha;"] = 913;
	htmlcodes["&Beta;"] = 914;
	htmlcodes["&Gamma;"] = 915;
	htmlcodes["&Delta;"] = 916;
	htmlcodes["&Epsilon;"] = 917;
	htmlcodes["&Zeta;"] = 918;
	htmlcodes["&Eta;"] = 919;
	htmlcodes["&Theta;"] = 920;
	htmlcodes["&Iota;"] = 921;
	htmlcodes["&Kappa;"] = 922;
	htmlcodes["&Lambda;"] = 923;
	htmlcodes["&Mu;"] = 924;
	htmlcodes["&Nu;"] = 925;
	htmlcodes["&Xi;"] = 926;
	htmlcodes["&Omicron;"] = 927;
	htmlcodes["&Pi;"] = 928;
	htmlcodes["&Rho;"] = 929;
	htmlcodes["&Sigma;"] = 931;
	htmlcodes["&Tau;"] = 932;
	htmlcodes["&Upsilon;"] = 933;
	htmlcodes["&Phi;"] = 934;
	htmlcodes["&Chi;"] = 935;
	htmlcodes["&Psi;"] = 936;
	htmlcodes["&Omega;"] = 937;
	htmlcodes["&alpha;"] = 945;
	htmlcodes["&beta;"] = 946;
	htmlcodes["&gamma;"] = 947;
	htmlcodes["&delta;"] = 948;
	htmlcodes["&epsilon;"] = 949;
	htmlcodes["&zeta;"] = 950;
	htmlcodes["&eta;"] = 951;
	htmlcodes["&theta;"] = 952;
	htmlcodes["&iota;"] = 953;
	htmlcodes["&kappa;"] = 954;
	htmlcodes["&lambda;"] = 955;
	htmlcodes["&mu;"] = 956;
	htmlcodes["&nu;"] = 957;
	htmlcodes["&xi;"] = 958;
	htmlcodes["&omicron;"] = 959;
	htmlcodes["&pi;"] = 960;
	htmlcodes["&rho;"] = 961;
	htmlcodes["&sigmaf;"] = 962;
	htmlcodes["&sigma;"] = 963;
	htmlcodes["&tau;"] = 964;
	htmlcodes["&upsilon;"] = 965;
	htmlcodes["&phi;"] = 966;
	htmlcodes["&chi;"] = 967;
	htmlcodes["&psi;"] = 968;
	htmlcodes["&omega;"] = 969;
	htmlcodes["&thetasym;"] = 977;
	htmlcodes["&upsih;"] = 978;
	htmlcodes["&piv;"] = 982;
	htmlcodes["&ensp;"] = 8194;
	htmlcodes["&emsp;"] = 8195;
	htmlcodes["&thinsp;"] = 8201;
	htmlcodes["&zwnj;"] = 8204;
	htmlcodes["&zwj;"] = 8205;
	htmlcodes["&lrm;"] = 8206;
	htmlcodes["&rlm;"] = 8207;
	htmlcodes["&ndash;"] = 8211;
	htmlcodes["&mdash;"] = 8212;
	htmlcodes["&lsquo;"] = 8216;
	htmlcodes["&rsquo;"] = 8217;
	htmlcodes["&sbquo;"] = 8218;
	htmlcodes["&ldquo;"] = 8220;
	htmlcodes["&rdquo;"] = 8221;
	htmlcodes["&bdquo;"] = 8222;
	htmlcodes["&dagger;"] = 8224;
	htmlcodes["&Dagger;"] = 8225;
	htmlcodes["&bull;"] = 8226;
	htmlcodes["&hellip;"] = 8230;
	htmlcodes["&permil;"] = 8240;
	htmlcodes["&prime;"] = 8242;
	htmlcodes["&Prime;"] = 8243;
	htmlcodes["&lsaquo;"] = 8249;
	htmlcodes["&rsaquo;"] = 8250;
	htmlcodes["&oline;"] = 8254;
	htmlcodes["&frasl;"] = 8260;
	htmlcodes["&euro;"] = 8364;
	htmlcodes["&image;"] = 8465;
	htmlcodes["&weierp;"] = 8472;
	htmlcodes["&real;"] = 8476;
	htmlcodes["&trade;"] = 8482;
	htmlcodes["&alefsym;"] = 8501;
	htmlcodes["&larr;"] = 8592;
	htmlcodes["&uarr;"] = 8593;
	htmlcodes["&rarr;"] = 8594;
	htmlcodes["&darr;"] = 8595;
	htmlcodes["&harr;"] = 8596;
	htmlcodes["&crarr;"] = 8629;
	htmlcodes["&lArr;"] = 8656;
	htmlcodes["&uArr;"] = 8657;
	htmlcodes["&rArr;"] = 8658;
	htmlcodes["&dArr;"] = 8659;
	htmlcodes["&hArr;"] = 8660;
	htmlcodes["&forall;"] = 8704;
	htmlcodes["&part;"] = 8706;
	htmlcodes["&exist;"] = 8707;
	htmlcodes["&empty;"] = 8709;
	htmlcodes["&nabla;"] = 8711;
	htmlcodes["&isin;"] = 8712;
	htmlcodes["&notin;"] = 8713;
	htmlcodes["&ni;"] = 8715;
	htmlcodes["&prod;"] = 8719;
	htmlcodes["&sum;"] = 8721;
	htmlcodes["&minus;"] = 8722;
	htmlcodes["&lowast;"] = 8727;
	htmlcodes["&radic;"] = 8730;
	htmlcodes["&prop;"] = 8733;
	htmlcodes["&infin;"] = 8734;
	htmlcodes["&ang;"] = 8736;
	htmlcodes["&and;"] = 8743;
	htmlcodes["&or;"] = 8744;
	htmlcodes["&cap;"] = 8745;
	htmlcodes["&cup;"] = 8746;
	htmlcodes["&int;"] = 8747;
	htmlcodes["&there4;"] = 8756;
	htmlcodes["&sim;"] = 8764;
	htmlcodes["&cong;"] = 8773;
	htmlcodes["&asymp;"] = 8776;
	htmlcodes["&ne;"] = 8800;
	htmlcodes["&equiv;"] = 8801;
	htmlcodes["&le;"] = 8804;
	htmlcodes["&ge;"] = 8805;
	htmlcodes["&sub;"] = 8834;
	htmlcodes["&sup;"] = 8835;
	htmlcodes["&nsub;"] = 8836;
	htmlcodes["&sube;"] = 8838;
	htmlcodes["&supe;"] = 8839;
	htmlcodes["&oplus;"] = 8853;
	htmlcodes["&otimes;"] = 8855;
	htmlcodes["&perp;"] = 8869;
	htmlcodes["&sdot;"] = 8901;
	htmlcodes["&lceil;"] = 8968;
	htmlcodes["&rceil;"] = 8969;
	htmlcodes["&lfloor;"] = 8970;
	htmlcodes["&rfloor;"] = 8971;
	htmlcodes["&lang;"] = 9001;
	htmlcodes["&rang;"] = 9002;
	htmlcodes["&loz;"] = 9674;
	htmlcodes["&spades;"] = 9824;
	htmlcodes["&clubs;"] = 9827;
	htmlcodes["&hearts;"] = 9829;
	htmlcodes["&diams;"] = 9830;

}

static void  Initlatintables() {
	int i = 0;

	char ch[10];
	while (latin2codetable[i] != 0) {
		latin2codes[latin2codetable[i]] = latin2codetable[i + 1];
		codes2latin[latin2codetable[i + 1]] = latin2codetable[i];
		c_unicode_to_utf8(latin2codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin2codetable[i];
		i += 2;
	}


	i = 0;
	while (latin3codetable[i] != 0) {
		latin3codes[latin3codetable[i]] = latin3codetable[i + 1];
		codes3latin[latin3codetable[i + 1]] = latin3codetable[i];
		c_unicode_to_utf8(latin3codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin3codetable[i];
		i += 2;
	}


	i = 0;
	while (latin4codetable[i] != 0) {
		latin4codes[latin4codetable[i]] = latin4codetable[i + 1];
		codes4latin[latin4codetable[i + 1]] = latin4codetable[i];
		c_unicode_to_utf8(latin4codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin4codetable[i];
		i += 2;
	}


	i = 0;
	while (latin5codetable[i] != 0) {
		latin5codes[latin5codetable[i]] = latin5codetable[i + 1];
		codes5latin[latin5codetable[i + 1]] = latin5codetable[i];
		c_unicode_to_utf8(latin5codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin5codetable[i];
		i += 2;
	}


	i = 0;
	while (latin6codetable[i] != 0) {
		latin6codes[latin6codetable[i]] = latin6codetable[i + 1];
		codes6latin[latin6codetable[i + 1]] = latin6codetable[i];
		c_unicode_to_utf8(latin6codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin6codetable[i];
		i += 2;
	}


	i = 0;
	while (latin7codetable[i] != 0) {
		latin7codes[latin7codetable[i]] = latin7codetable[i + 1];
		codes7latin[latin7codetable[i + 1]] = latin7codetable[i];
		c_unicode_to_utf8(latin7codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin7codetable[i];
		i += 2;
	}


	i = 0;
	while (latin8codetable[i] != 0) {
		latin8codes[latin8codetable[i]] = latin8codetable[i + 1];
		codes8latin[latin8codetable[i + 1]] = latin8codetable[i];
		c_unicode_to_utf8(latin8codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin8codetable[i];
		i += 2;
	}


	i = 0;
	while (latin9codetable[i] != 0) {
		latin9codes[latin9codetable[i]] = latin9codetable[i + 1];
		codes9latin[latin9codetable[i + 1]] = latin9codetable[i];
		c_unicode_to_utf8(latin9codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin9codetable[i];
		i += 2;
	}


	i = 0;
	while (latin10codetable[i] != 0) {
		latin10codes[latin10codetable[i]] = latin10codetable[i + 1];
		codes10latin[latin10codetable[i + 1]] = latin10codetable[i];
		c_unicode_to_utf8(latin10codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin10codetable[i];
		i += 2;
	}


	i = 0;
	while (latin11codetable[i] != 0) {
		latin11codes[latin11codetable[i]] = latin11codetable[i + 1];
		codes11latin[latin11codetable[i + 1]] = latin11codetable[i];
		c_unicode_to_utf8(latin11codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin11codetable[i];
		i += 2;
	}

	i = 0;
	while (latin13codetable[i] != 0) {
		latin13codes[latin13codetable[i]] = latin13codetable[i + 1];
		codes13latin[latin13codetable[i + 1]] = latin13codetable[i];
		c_unicode_to_utf8(latin13codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin13codetable[i];
		i += 2;
	}


	i = 0;
	while (latin14codetable[i] != 0) {
		latin14codes[latin14codetable[i]] = latin14codetable[i + 1];
		codes14latin[latin14codetable[i + 1]] = latin14codetable[i];
		c_unicode_to_utf8(latin14codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin14codetable[i];
		i += 2;
	}


	i = 0;
	while (latin15codetable[i] != 0) {
		latin15codes[latin15codetable[i]] = latin15codetable[i + 1];
		codes15latin[latin15codetable[i + 1]] = latin15codetable[i];
		c_unicode_to_utf8(latin15codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin15codetable[i];
		i += 2;
	}


	i = 0;
	while (latin16codetable[i] != 0) {
		latin16codes[latin16codetable[i]] = latin16codetable[i + 1];
		codes16latin[latin16codetable[i + 1]] = latin16codetable[i];
		c_unicode_to_utf8(latin16codetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latin16codetable[i];
		i += 2;
	}

	i = 0;
	while (latincodetable[i] != 0) {
		latincodes[latincodetable[i]] = latincodetable[i + 1];
		codeslatin[latincodetable[i + 1]] = latincodetable[i];
		c_unicode_to_utf8(latincodetable[i + 1], (uchar*)ch);
		utf8codes[ch] = latincodetable[i];
		i += 2;
	}
}

Exporting  void inittableutf8() {
	static bool init = false;
	if (init)
		return;

	Initlatintables();
	InitHtmlCodes();
	InitDosCodes();
	init = true;
	int unicode;
	bulongchar xs;
	bulongchar xse;
	uchar latin;
	int i;
	int maxtable;
	for (maxtable = 0; table[maxtable] != -1; maxtable++);


	for (i = 0; i < maxtable; i += 3) {
		unicode = table[i];
		int equ = table[i + 1];
		char type = table[i + 2];
		xs.clear();
		xse.clear();
		c_unicode_to_utf8(unicode, xs.ustr);
		c_unicode_to_utf8(equ, xse.ustr);
		if (unicode < 256)
			latin = unicode;
		else
			latin = 0;

		if (type == 1) {
			utf8codemin[unicode] = equ;
			if (latin != 0)
				latinmin[latin] = xse.str;
		}
		else {
			if (type == 2) {
				utf8codemaj[unicode] = equ;
				if (latin != 0)
					latinmaj[latin] = xse.str;
			}
		}
	}
	i = 0;
	while (ponctuations[i] != 0) {
		punctuations[ponctuations[i]] = true;
		i++;
	}


	alllatincodes[0] = latincodes;
	alllatincodes[1] = latincodes;
	alllatincodes[2] = latin2codes;
	alllatincodes[3] = latin3codes;
	alllatincodes[4] = latin4codes;
	alllatincodes[5] = latin5codes;
	alllatincodes[6] = latin6codes;
	alllatincodes[7] = latin7codes;
	alllatincodes[8] = latin8codes;
	alllatincodes[9] = latin9codes;
	alllatincodes[10] = latin10codes;
	alllatincodes[11] = latin11codes;
	alllatincodes[13] = latin13codes;
	alllatincodes[14] = latin14codes;
	alllatincodes[15] = latin15codes;
	alllatincodes[16] = latin16codes;

	consonants[349] = "s";
	consonants[231] = "c";
	consonants[199] = "C";
	consonants[208] = "D";
	consonants[331] = "n";
	consonants[122] = "z";
	consonants[292] = "H";
	consonants[241] = "n";
	consonants[209] = "N";
	consonants[88] = "X";
	consonants[262] = "C";
	consonants[263] = "c";
	consonants[86] = "V";
	consonants[264] = "C";
	consonants[87] = "W";
	consonants[265] = "c";
	consonants[84] = "T";
	consonants[266] = "C";
	consonants[267] = "c";
	consonants[82] = "R";
	consonants[268] = "C";
	consonants[83] = "S";
	consonants[269] = "c";
	consonants[353] = "s";
	consonants[80] = "P";
	consonants[270] = "D";
	consonants[352] = "S";
	consonants[81] = "Q";
	consonants[271] = "d";
	consonants[78] = "N";
	consonants[272] = "D";
	consonants[273] = "d";
	consonants[66] = "B";
	consonants[284] = "G";
	consonants[67] = "C";
	consonants[285] = "g";
	consonants[286] = "G";
	consonants[287] = "g";
	consonants[288] = "G";
	consonants[289] = "g";
	consonants[290] = "G";
	consonants[291] = "g";
	consonants[293] = "h";
	consonants[329] = "n";
	consonants[120] = "x";
	consonants[294] = "H";
	consonants[328] = "n";
	consonants[295] = "h";
	consonants[347] = "s";
	consonants[106] = "j";
	consonants[308] = "J";
	consonants[346] = "S";
	consonants[107] = "k";
	consonants[309] = "j";
	consonants[345] = "r";
	consonants[104] = "h";
	consonants[310] = "K";
	consonants[344] = "R";
	consonants[311] = "k";
	consonants[342] = "R";
	consonants[103] = "g";
	consonants[313] = "L";
	consonants[341] = "r";
	consonants[100] = "d";
	consonants[314] = "l";
	consonants[340] = "R";
	consonants[315] = "L";
	consonants[98] = "b";
	consonants[316] = "l";
	consonants[99] = "c";
	consonants[317] = "L";
	consonants[318] = "l";
	consonants[319] = "L";
	consonants[320] = "l";
	consonants[321] = "L";
	consonants[322] = "l";
	consonants[323] = "N";
	consonants[324] = "n";
	consonants[325] = "N";
	consonants[326] = "n";
	consonants[327] = "N";
	consonants[343] = "r";
	consonants[348] = "S";
	consonants[350] = "S";
	consonants[351] = "s";
	consonants[354] = "T";
	consonants[355] = "t";
	consonants[356] = "T";
	consonants[357] = "t";
	consonants[358] = "T";
	consonants[359] = "t";
	consonants[372] = "W";
	consonants[373] = "w";
	consonants[377] = "Z";
	consonants[378] = "z";
	consonants[379] = "Z";
	consonants[380] = "z";
	consonants[381] = "Z";
	consonants[382] = "z";
	consonants[384] = "b";
	consonants[385] = "B";
	consonants[386] = "b";
	consonants[387] = "b";
	consonants[388] = "b";
	consonants[389] = "b";
	consonants[391] = "C";
	consonants[392] = "c";
	consonants[393] = "D";
	consonants[394] = "D";
	consonants[395] = "d";
	consonants[396] = "d";
	consonants[401] = "F";
	consonants[402] = "f";
	consonants[403] = "G";
	consonants[408] = "K";
	consonants[409] = "k";
	consonants[452] = "DZ";
	consonants[454] = "dz";
	consonants[455] = "Ǉ";
	consonants[457] = "lj";
	consonants[458] = "NJ";
	consonants[460] = "nj";
	consonants[473] = "Ǚ";
	consonants[484] = "G";
	consonants[485] = "g";
	consonants[486] = "G";
	consonants[487] = "g";
	consonants[488] = "K";
	consonants[489] = "k";
	consonants[496] = "j";
	consonants[497] = "DZ";
	consonants[68] = "D";
	consonants[70] = "F";
	consonants[71] = "G";
	consonants[72] = "H";
	consonants[74] = "J";
	consonants[75] = "K";
	consonants[76] = "L";
	consonants[77] = "M";
	consonants[90] = "Z";
	consonants[102] = "f";
	consonants[108] = "l";
	consonants[109] = "m";
	consonants[110] = "n";
	consonants[112] = "p";
	consonants[113] = "q";
	consonants[114] = "r";
	consonants[115] = "s";
	consonants[116] = "t";
	consonants[118] = "v";
	consonants[119] = "w";


	vowels[200] = "E";
	vowels[277] = "e";
	vowels[192] = "A";
	vowels[201] = "E";
	vowels[276] = "E";
	vowels[193] = "A";
	vowels[73] = "I";
	vowels[279] = "e";
	vowels[194] = "A";
	vowels[278] = "E";
	vowels[195] = "A";
	vowels[196] = "A";
	vowels[197] = "A";
	vowels[275] = "e";
	vowels[198] = "AE";
	vowels[202] = "E";
	vowels[203] = "E";
	vowels[204] = "i";
	vowels[205] = "i";
	vowels[206] = "i";
	vowels[207] = "i";
	vowels[210] = "O";
	vowels[211] = "O";
	vowels[257] = "a";
	vowels[212] = "O";
	vowels[256] = "A";
	vowels[213] = "O";
	vowels[259] = "a";
	vowels[214] = "O";
	vowels[216] = "O";
	vowels[217] = "U";
	vowels[218] = "U";
	vowels[219] = "U";
	vowels[220] = "U";
	vowels[221] = "Y";
	vowels[224] = "a";
	vowels[225] = "a";
	vowels[226] = "a";
	vowels[227] = "a";
	vowels[228] = "a";
	vowels[229] = "a";
	vowels[230] = "ae";
	vowels[232] = "e";
	vowels[233] = "e";
	vowels[234] = "e";
	vowels[235] = "e";
	vowels[236] = "i";
	vowels[237] = "i";
	vowels[238] = "i";
	vowels[239] = "i";
	vowels[242] = "o";
	vowels[243] = "o";
	vowels[244] = "o";
	vowels[245] = "o";
	vowels[246] = "o";
	vowels[248] = "o";
	vowels[249] = "u";
	vowels[250] = "u";
	vowels[251] = "u";
	vowels[252] = "u";
	vowels[253] = "y";
	vowels[255] = "y";
	vowels[258] = "A";
	vowels[260] = "A";
	vowels[261] = "a";
	vowels[274] = "E";
	vowels[280] = "E";
	vowels[281] = "e";
	vowels[282] = "E";
	vowels[69] = "E";
	vowels[283] = "e";
	vowels[296] = "I";
	vowels[297] = "i";
	vowels[298] = "I";
	vowels[117] = "u";
	vowels[299] = "i";
	vowels[300] = "I";
	vowels[301] = "i";
	vowels[302] = "I";
	vowels[303] = "i";
	vowels[304] = "I";
	vowels[111] = "o";
	vowels[305] = "i";
	vowels[306] = "IJ";
	vowels[307] = "ij";
	vowels[332] = "O";
	vowels[333] = "o";
	vowels[334] = "O";
	vowels[335] = "o";
	vowels[336] = "O";
	vowels[337] = "o";
	vowels[338] = "OE";
	vowels[339] = "oe";
	vowels[360] = "U";
	vowels[361] = "u";
	vowels[362] = "U";
	vowels[363] = "u";
	vowels[364] = "U";
	vowels[365] = "u";
	vowels[366] = "U";
	vowels[367] = "u";
	vowels[368] = "U";
	vowels[369] = "u";
	vowels[370] = "U";
	vowels[371] = "u";
	vowels[374] = "Y";
	vowels[375] = "y";
	vowels[376] = "Y";
	vowels[404] = "Y";
	vowels[461] = "A";
	vowels[462] = "a";
	vowels[463] = "I";
	vowels[464] = "i";
	vowels[465] = "O";
	vowels[466] = "o";
	vowels[467] = "U";
	vowels[468] = "u";
	vowels[469] = "U";
	vowels[470] = "u";
	vowels[471] = "U";
	vowels[472] = "u";
	vowels[474] = "u";
	vowels[475] = "U";
	vowels[476] = "u";
	vowels[478] = "A";
	vowels[479] = "a";
	vowels[480] = "A";
	vowels[481] = "a";
	vowels[482] = "AE";
	vowels[483] = "ae";
	vowels[490] = "O";
	vowels[491] = "o";
	vowels[492] = "O";
	vowels[493] = "o";
	vowels[97] = "a";
	vowels[105] = "i";
	vowels[121] = "y";
	vowels[65] = "A";
	vowels[101] = "e";
	vowels[79] = "O";
	vowels[85] = "U";
	vowels[89] = "Y";

	wconsonants[208] = 68;
	wconsonants[104] = 104;
	wconsonants[264] = 67;
	wconsonants[88] = 88;
	wconsonants[349] = 115;
	wconsonants[81] = 81;
	wconsonants[241] = 110;
	wconsonants[266] = 67;
	wconsonants[231] = 99;
	wconsonants[292] = 72;
	wconsonants[199] = 67;
	wconsonants[290] = 71;
	wconsonants[209] = 78;
	wconsonants[331] = 110;
	wconsonants[291] = 103;
	wconsonants[347] = 115;
	wconsonants[486] = 71;
	wconsonants[294] = 72;
	wconsonants[98] = 98;
	wconsonants[122] = 122;
	wconsonants[77] = 77;
	wconsonants[319] = 76;
	wconsonants[262] = 67;
	wconsonants[269] = 99;
	wconsonants[357] = 116;
	wconsonants[263] = 99;
	wconsonants[112] = 112;
	wconsonants[86] = 86;
	wconsonants[103] = 103;
	wconsonants[113] = 113;
	wconsonants[87] = 87;
	wconsonants[265] = 99;
	wconsonants[308] = 74;
	wconsonants[268] = 67;
	wconsonants[284] = 71;
	wconsonants[100] = 100;
	wconsonants[84] = 84;
	wconsonants[313] = 76;
	wconsonants[379] = 90;
	wconsonants[345] = 114;
	wconsonants[267] = 99;
	wconsonants[82] = 82;
	wconsonants[83] = 83;
	wconsonants[353] = 115;
	wconsonants[80] = 80;
	wconsonants[270] = 68;
	wconsonants[352] = 83;
	wconsonants[293] = 104;
	wconsonants[78] = 78;
	wconsonants[271] = 100;
	wconsonants[288] = 71;
	wconsonants[272] = 68;
	wconsonants[273] = 100;
	wconsonants[108] = 108;
	wconsonants[66] = 66;
	wconsonants[67] = 67;
	wconsonants[285] = 103;
	wconsonants[286] = 71;
	wconsonants[341] = 114;
	wconsonants[109] = 109;
	wconsonants[309] = 106;
	wconsonants[381] = 90;
	wconsonants[287] = 103;
	wconsonants[289] = 103;
	wconsonants[329] = 110;
	wconsonants[344] = 82;
	wconsonants[120] = 120;
	wconsonants[328] = 110;
	wconsonants[295] = 104;
	wconsonants[106] = 106;
	wconsonants[314] = 108;
	wconsonants[346] = 83;
	wconsonants[107] = 107;
	wconsonants[342] = 82;
	wconsonants[310] = 75;
	wconsonants[311] = 107;
	wconsonants[340] = 82;
	wconsonants[326] = 110;
	wconsonants[315] = 76;
	wconsonants[316] = 108;
	wconsonants[99] = 99;
	wconsonants[317] = 76;
	wconsonants[318] = 108;
	wconsonants[320] = 108;
	wconsonants[355] = 116;
	wconsonants[321] = 76;
	wconsonants[322] = 108;
	wconsonants[323] = 78;
	wconsonants[324] = 110;
	wconsonants[325] = 78;
	wconsonants[327] = 78;
	wconsonants[343] = 114;
	wconsonants[348] = 83;
	wconsonants[350] = 83;
	wconsonants[351] = 115;
	wconsonants[354] = 84;
	wconsonants[356] = 84;
	wconsonants[358] = 84;
	wconsonants[359] = 116;
	wconsonants[372] = 87;
	wconsonants[373] = 119;
	wconsonants[377] = 90;
	wconsonants[378] = 122;
	wconsonants[380] = 122;
	wconsonants[382] = 122;
	wconsonants[384] = 98;
	wconsonants[385] = 66;
	wconsonants[386] = 98;
	wconsonants[387] = 98;
	wconsonants[388] = 98;
	wconsonants[389] = 98;
	wconsonants[391] = 67;
	wconsonants[392] = 99;
	wconsonants[393] = 68;
	wconsonants[488] = 75;
	wconsonants[394] = 68;
	wconsonants[395] = 100;
	wconsonants[396] = 100;
	wconsonants[401] = 70;
	wconsonants[402] = 102;
	wconsonants[403] = 71;
	wconsonants[408] = 75;
	wconsonants[409] = 107;
	wconsonants[455] = 455;
	wconsonants[473] = 473;
	wconsonants[484] = 71;
	wconsonants[485] = 103;
	wconsonants[487] = 103;
	wconsonants[489] = 107;
	wconsonants[496] = 106;
	wconsonants[90] = 90;
	wconsonants[68] = 68;
	wconsonants[70] = 70;
	wconsonants[71] = 71;
	wconsonants[72] = 72;
	wconsonants[74] = 74;
	wconsonants[115] = 115;
	wconsonants[75] = 75;
	wconsonants[76] = 76;
	wconsonants[102] = 102;
	wconsonants[110] = 110;
	wconsonants[114] = 114;
	wconsonants[116] = 116;
	wconsonants[118] = 118;
	wconsonants[119] = 119;
	wvowels[194] = 65;
	wvowels[200] = 69;
	wvowels[277] = 101;
	wvowels[252] = 117;
	wvowels[192] = 65;
	wvowels[243] = 111;
	wvowels[239] = 105;
	wvowels[256] = 65;
	wvowels[276] = 69;
	wvowels[201] = 69;
	wvowels[207] = 105;
	wvowels[233] = 101;
	wvowels[73] = 73;
	wvowels[193] = 65;
	wvowels[279] = 101;
	wvowels[242] = 111;
	wvowels[202] = 69;
	wvowels[275] = 101;
	wvowels[278] = 69;
	wvowels[219] = 85;
	wvowels[195] = 65;
	wvowels[196] = 65;
	wvowels[218] = 85;
	wvowels[259] = 97;
	wvowels[197] = 65;
	wvowels[258] = 65;
	wvowels[217] = 85;
	wvowels[216] = 79;
	wvowels[228] = 97;
	wvowels[203] = 69;
	wvowels[260] = 65;
	wvowels[204] = 105;
	wvowels[226] = 97;
	wvowels[210] = 79;
	wvowels[205] = 105;
	wvowels[249] = 117;
	wvowels[246] = 111;
	wvowels[225] = 97;
	wvowels[206] = 105;
	wvowels[227] = 97;
	wvowels[211] = 79;
	wvowels[257] = 97;
	wvowels[244] = 111;
	wvowels[232] = 101;
	wvowels[280] = 69;
	wvowels[212] = 79;
	wvowels[213] = 79;
	wvowels[214] = 79;
	wvowels[235] = 101;
	wvowels[220] = 85;
	wvowels[221] = 89;
	wvowels[224] = 97;
	wvowels[69] = 69;
	wvowels[253] = 121;
	wvowels[229] = 97;
	wvowels[234] = 101;
	wvowels[236] = 105;
	wvowels[237] = 105;
	wvowels[298] = 73;
	wvowels[238] = 105;
	wvowels[250] = 117;
	wvowels[245] = 111;
	wvowels[376] = 89;
	wvowels[248] = 111;
	wvowels[251] = 117;
	wvowels[261] = 97;
	wvowels[255] = 121;
	wvowels[274] = 69;
	wvowels[281] = 101;
	wvowels[282] = 69;
	wvowels[283] = 101;
	wvowels[364] = 85;
	wvowels[296] = 73;
	wvowels[297] = 105;
	wvowels[117] = 117;
	wvowels[299] = 105;
	wvowels[300] = 73;
	wvowels[301] = 105;
	wvowels[302] = 73;
	wvowels[303] = 105;
	wvowels[304] = 73;
	wvowels[111] = 111;
	wvowels[305] = 105;
	wvowels[332] = 79;
	wvowels[333] = 111;
	wvowels[334] = 79;
	wvowels[335] = 111;
	wvowels[85] = 85;
	wvowels[336] = 79;
	wvowels[337] = 111;
	wvowels[360] = 85;
	wvowels[361] = 117;
	wvowels[362] = 85;
	wvowels[363] = 117;
	wvowels[365] = 117;
	wvowels[366] = 85;
	wvowels[367] = 117;
	wvowels[368] = 85;
	wvowels[369] = 117;
	wvowels[370] = 85;
	wvowels[371] = 117;
	wvowels[374] = 89;
	wvowels[375] = 121;
	wvowels[404] = 89;
	wvowels[461] = 65;
	wvowels[462] = 97;
	wvowels[463] = 73;
	wvowels[480] = 65;
	wvowels[464] = 105;
	wvowels[465] = 79;
	wvowels[466] = 111;
	wvowels[467] = 85;
	wvowels[468] = 117;
	wvowels[469] = 85;
	wvowels[470] = 117;
	wvowels[471] = 85;
	wvowels[479] = 97;
	wvowels[472] = 117;
	wvowels[474] = 117;
	wvowels[475] = 85;
	wvowels[476] = 117;
	wvowels[478] = 65;
	wvowels[481] = 97;
	wvowels[490] = 79;
	wvowels[491] = 111;
	wvowels[492] = 79;
	wvowels[493] = 111;
	wvowels[97] = 97;
	wvowels[105] = 105;
	wvowels[121] = 121;
	wvowels[65] = 65;
	wvowels[101] = 101;
	wvowels[79] = 79;
	wvowels[89] = 89;

}

//===================================================================

Exporting bool valid_latin_table(int table) {
	if (!alllatincodes.check(table))
		return false;
	return true;
}

//===================================================================
BLONG conversionintegerhexa(char* number) {
	int sign = 1;
	if (number[0] == '-') {
		++number;
		sign = -1;
	}
	int l = strlen(number);

	if (number[0] != '0' || number[1] != 'x') {
		BLONG v = 0;
		int i = 0;
		int m = 1;
		if (*number == '-') {
			i = 1;
			m = -1;
		}
		for (; i < l; i++) {
			if (number[i]<48 || number[i]>57)
				return (v*m);
			v = v * 10 + (number[i] - 48);
		}
		v *= m;
		return v*sign;
	}

	BLONG v = 0;
	for (int i = 2; i < l; i++) {
		v <<= 4;
		switch (number[i]) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			v |= number[i] - 48;
			break;
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
			v |= number[i] - 55;
			break;
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
			v |= number[i] - 87;
			break;
		default:
			return v*sign;
		}
	}
	return v*sign;
}
//===================================================================
double conversionfloat(char* s) {
	double v = 0;
	double point = 0;
	double mantissa = 0;
	double power = 0;
	bool epres = false;
	char sign = 0;
	bool stop = false;

	for (int i = 0; s[i] != 0 && !stop; i++) {
		switch (s[i]) {
		case '-':
			if (epres)
				sign |= 2;
			else
				sign = 1;
			break;
		case 'e':
			if (epres)
				stop = true;
			epres = true;
			break;
		case '.':
			if (mantissa)
				stop = false;
			else
				mantissa = 1;
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			if (epres) {
				power *= 10;
				power += s[i] - 48;
				break;
			}
			if (!mantissa) {
				v *= 10;
				v += s[i] - 48;
				break;
			}
			point *= 10;
			point += s[i] - 48;
			mantissa *= 10;
			break;
		default:
			stop = true;
		}
	}

	v += point / mantissa;
	if ((sign & 1) == 1)
		v *= -1;
	if (epres) {
		if ((sign & 2) == 2)
			power *= -1;
		power = pow(10, power);
		v *= power;
	}
	return v;
}
//===================================================================
//Conversion from string to double...
double convertfloat(char* s) {
	char* end;
	return strtod(s, &end);
}

double convertfloat(wstring value) {
	string v;
	sc_unicode_to_utf8(v, value);
	return convertfloat(STR(v));
}

long convertinteger(wstring value) {
	string v;
	sc_unicode_to_utf8(v, value);
	return conversionintegerhexa(STR(v));
}
//===================================================================

Exporting void c_HTMLcode(string& s, BULONG code) {
	if (codeshtml.check(code))
		s = codeshtml[code];
	else {
		char ch[10];
		sprintf(ch, "&%d;", code);
		s = ch;
	}
}

void s_EvaluateMetaCharacters(string& s) {
	BULONG cd;

	switch (s[0]) {
	case '\\':
		switch (s.size()) {
		case 0:
		case 1:
			return;
		case 2:// \n \r \t \" etc...
			if (metacodes.find(s) != metacodes.end())
				s = metacodes[s];
			else
				s = s[1];
			return;
		case 4://ASCII decimal: \234
			if (s[1] == 'x') {
				s[0] = '0';
				cd = conversionintegerhexa(STR(s));
				break;
			}
			s[0] = ' ';
			cd = atoi(STR(s));
			break;
		case 6://unicode  \u00FE
			s[0] = '0'; s[1] = 'x';
			cd = conversionintegerhexa(STR(s));
		}
		break;
	case 'u':
		s[0] = '0'; s[1] = 'x';
		cd = conversionintegerhexa(STR(s));
		break;
	case '&':
		if (s[1] == '#') {
			s = s.substr(2, s.size() - 3);
			cd = atoi(STR(s));
		}
		else
		if (htmlcodes.find(s) != htmlcodes.end())
			cd = htmlcodes[s];
		else
			return;
		break;
	case '%': //%CC
		s[0] = 'x';
		s = '0' + s;
		cd = conversionintegerhexa(STR(s));
		s = (char)cd;
		return;
	}

	uchar inter[10];
	c_unicode_to_utf8(cd, inter);
	s = (char*)inter;
}


Exporting int c_unicode_to_utf8(BULONG code, unsigned char* utf) {
	if (code < 0x0080) {
		utf[0] = (unsigned char)code;
		utf[1] = 0;
		return 1;
	}
	if (code < 0x0800) {
		utf[0] = 0xc0 | ((code) >> 6);
		utf[1] = 0x80 | ((code)& 0x3f);
		utf[2] = 0;
		return 2;
	}
	if (code < 0x10000) {
		utf[0] = 0xe0 | ((code) >> 12);
		utf[1] = 0x80 | (((code) >> 6) & 0x3f);
		utf[2] = 0x80 | ((code)& 0x3f);
		utf[3] = 0;
		return 3;
	}
	if (code < 0x200000) {
		utf[0] = 0xF0 | ((code) >> 18);
		utf[1] = 0x80 | (((code) >> 12) & 0x3f);
		utf[2] = 0x80 | (((code) >> 6) & 0x3f);
		utf[3] = 0x80 | ((code)& 0x3f);
		utf[4] = 0;
		return 4;
	}
	if (code < 0x4000000) {
		utf[0] = 0xF8 | ((code) >> 24);
		utf[1] = 0x80 | (((code) >> 18) & 0x3f);
		utf[2] = 0x80 | (((code) >> 12) & 0x3f);
		utf[3] = 0x80 | (((code) >> 6) & 0x3f);
		utf[4] = 0x80 | ((code)& 0x3f);
		utf[5] = 0;
		return 5;
	}
	utf[0] = 0xFC | ((code) >> 30);
	utf[1] = 0x80 | (((code) >> 24) & 0x3f);
	utf[2] = 0x80 | (((code) >> 18) & 0x3f);
	utf[3] = 0x80 | (((code) >> 12) & 0x3f);
	utf[4] = 0x80 | (((code) >> 6) & 0x3f);
	utf[5] = 0x80 | ((code)& 0x3f);
	utf[6] = 0;
	return 6;
}

Exporting string c_unicode_to_utf8(wchar_t code) {
	char utf[10];
	if (code < 0x0080) {
		utf[0] = (unsigned char)code;
		utf[1] = 0;
		return utf;
	}
	if (code < 0x0800) {
		utf[0] = 0xc0 | ((code) >> 6);
		utf[1] = 0x80 | ((code)& 0x3f);
		utf[2] = 0;
		return utf;
	}
	if (code < 0x10000) {
		utf[0] = 0xe0 | ((code) >> 12);
		utf[1] = 0x80 | (((code) >> 6) & 0x3f);
		utf[2] = 0x80 | ((code)& 0x3f);
		utf[3] = 0;
		return utf;
	}
	if (code < 0x200000) {
		utf[0] = 0xF0 | ((code) >> 18);
		utf[1] = 0x80 | (((code) >> 12) & 0x3f);
		utf[2] = 0x80 | (((code) >> 6) & 0x3f);
		utf[3] = 0x80 | ((code)& 0x3f);
		utf[4] = 0;
		return utf;
	}
	if (code < 0x4000000) {
		utf[0] = 0xF8 | ((code) >> 24);
		utf[1] = 0x80 | (((code) >> 18) & 0x3f);
		utf[2] = 0x80 | (((code) >> 12) & 0x3f);
		utf[3] = 0x80 | (((code) >> 6) & 0x3f);
		utf[4] = 0x80 | ((code)& 0x3f);
		utf[5] = 0;
		return utf;
	}
	utf[0] = 0xFC | ((code) >> 30);
	utf[1] = 0x80 | (((code) >> 24) & 0x3f);
	utf[2] = 0x80 | (((code) >> 18) & 0x3f);
	utf[4] = 0x80 | (((code) >> 12) & 0x3f);
	utf[5] = 0x80 | (((code) >> 6) & 0x3f);
	utf[6] = 0x80 | ((code)& 0x3f);
	utf[7] = 0;
	return utf;
}

Exporting string s_unicode_to_utf8(BULONG code) {
	char utf[10];
	if (code < 0x0080) {
		utf[0] = (unsigned char)code;
		utf[1] = 0;
		return utf;
	}
	if (code < 0x0800) {
		utf[0] = 0xc0 | ((code) >> 6);
		utf[1] = 0x80 | ((code)& 0x3f);
		utf[2] = 0;
		return utf;
	}
	if (code < 0x10000) {
		utf[0] = 0xe0 | ((code) >> 12);
		utf[1] = 0x80 | (((code) >> 6) & 0x3f);
		utf[2] = 0x80 | ((code)& 0x3f);
		utf[3] = 0;
		return utf;
	}
	if (code < 0x200000) {
		utf[0] = 0xF0 | ((code) >> 18);
		utf[1] = 0x80 | (((code) >> 12) & 0x3f);
		utf[2] = 0x80 | (((code) >> 6) & 0x3f);
		utf[3] = 0x80 | ((code)& 0x3f);
		utf[4] = 0;
		return utf;
	}
	if (code < 0x4000000) {
		utf[0] = 0xF8 | ((code) >> 24);
		utf[1] = 0x80 | (((code) >> 18) & 0x3f);
		utf[2] = 0x80 | (((code) >> 12) & 0x3f);
		utf[3] = 0x80 | (((code) >> 6) & 0x3f);
		utf[4] = 0x80 | ((code)& 0x3f);
		utf[5] = 0;
		return utf;
	}
	utf[0] = 0xFC | ((code) >> 30);
	utf[1] = 0x80 | (((code) >> 24) & 0x3f);
	utf[2] = 0x80 | (((code) >> 18) & 0x3f);
	utf[4] = 0x80 | (((code) >> 12) & 0x3f);
	utf[5] = 0x80 | (((code) >> 6) & 0x3f);
	utf[6] = 0x80 | ((code)& 0x3f);
	utf[7] = 0;
	return utf;
}

Exporting void s_unicode_to_utf8(BULONG code, char* utf) {
	if (code < 0x0080) {
		utf[0] = (unsigned char)code;
		utf[1] = 0;
		return;
	}
	if (code < 0x0800) {
		utf[0] = 0xc0 | ((code) >> 6);
		utf[1] = 0x80 | ((code)& 0x3f);
		utf[2] = 0;
		return;
	}
	if (code < 0x10000) {
		utf[0] = 0xe0 | ((code) >> 12);
		utf[1] = 0x80 | (((code) >> 6) & 0x3f);
		utf[2] = 0x80 | ((code)& 0x3f);
		utf[3] = 0;
		return;
	}
	if (code < 0x200000) {
		utf[0] = 0xF0 | ((code) >> 18);
		utf[1] = 0x80 | (((code) >> 12) & 0x3f);
		utf[2] = 0x80 | (((code) >> 6) & 0x3f);
		utf[3] = 0x80 | ((code)& 0x3f);
		utf[4] = 0;
		return;
	}
	if (code < 0x4000000) {
		utf[0] = 0xF8 | ((code) >> 24);
		utf[1] = 0x80 | (((code) >> 18) & 0x3f);
		utf[2] = 0x80 | (((code) >> 12) & 0x3f);
		utf[3] = 0x80 | (((code) >> 6) & 0x3f);
		utf[4] = 0x80 | ((code)& 0x3f);
		utf[5] = 0;
		return;
	}
	utf[0] = 0xFC | ((code) >> 30);
	utf[1] = 0x80 | (((code) >> 24) & 0x3f);
	utf[2] = 0x80 | (((code) >> 18) & 0x3f);
	utf[4] = 0x80 | (((code) >> 12) & 0x3f);
	utf[5] = 0x80 | (((code) >> 6) & 0x3f);
	utf[6] = 0x80 | ((code)& 0x3f);
	utf[7] = 0;
}

Exporting  BULONG c_latin_table_to_unicode(int table, BULONG c) {
	if (c < 128 || c > 255 || !alllatincodes.check(table))
		return c;

	if (alllatincodes[table].check(c))
		return alllatincodes[table][c];

	return c;
}

Exporting void c_latin_to_utf8(unsigned char code, unsigned char* utf) {
	if (code < 0x0080) {
		utf[0] = (unsigned char)code;
		utf[1] = 0;
		return;
	}
	if (latincodes.check(code))
		c_unicode_to_utf8(latincodes[code], utf);
	else {
		utf[0] = 0xc0 | ((code) >> 6);
		utf[1] = 0x80 | ((code)& 0x3f);
		utf[2] = 0;
	}
}

Exporting BULONG c_unicode_to_latin(BULONG u) {
	if (u < 0x0080)
		return u;

	if (codeslatin.check(u))
		return codeslatin[u];

	return 0;
}

Exporting bool c_utf8_to_latin(unsigned char* utf, unsigned char& code) {
	if (utf[0] < 0x0080) {
		code = utf[0];
		return true;
	}

	if (utf8codes.find((char*)utf) != utf8codes.end()) {
		int x = utf8codes[(char*)utf];
		code = (unsigned char)x;
		return true;
	}

	unsigned char c = utf[0];
	if ((c & 0xE0) == 0xC0) {
		//We take two bytes
		if ((utf[1] & 0xC0) != 0x80)
			return false;
		code = (c ^ 0xc0) << 6;
		code |= utf[1] ^ 0x80;
		return true;
	}
	//we take three
	if ((c & 0xF0) == 0xE0) {
		if ((utf[1] & 0xC0) != 0x80 || (utf[2] & 0xC0) != 0x80)
			return false;
		code = (c ^ 0xE0) << 12;
		code |= (utf[1] ^ 0x80) << 6;
		code |= (utf[2] ^ 0x80);
		return true;
	}
	return false;
}

Exporting int c_utf8_to_unicode(unsigned char* utf, BULONG& code) {
	code = utf[0];
	if (utf[0] < 0x0080)
		return 0;

	unsigned char c = utf[0];
	if ((c & 0xE0) == 0xC0) {
		//We take two bytes
		if ((utf[1] & 0xC0) != 0x80)
			return 0;
		code = (c ^ 0xc0) << 6;
		code |= utf[1] ^ 0x80;
		return 1;
	}
	//we take three
	if ((c & 0xF0) == 0xE0) {
		if ((utf[1] & 0xC0) != 0x80 || (utf[2] & 0xC0) != 0x80)
			return 0;
		code = (c ^ 0xE0) << 12;
		code |= (utf[1] ^ 0x80) << 6;
		code |= (utf[2] ^ 0x80);
		return 2;
	}

	int i;
	//we take four
	if ((c & 0xF8) == 0xF0) {
		for (i = 1; i <= 3; i++)
		if ((utf[i] & 0xC0) != 0x80)
			return 0;
		code = (c ^ 0xF0) << 18;
		code |= (utf[1] ^ 0x80) << 12;
		code |= (utf[2] ^ 0x80) << 6;
		code |= (utf[3] ^ 0x80);
		return 3;
	}

	//we take five
	if ((c & 0xFC) == 0xF8) {
		for (i = 1; i <= 4; i++)
		if ((utf[i] & 0xC0) != 0x80)
			return 0;
		code = (c ^ 0xF8) << 24;
		code |= (utf[1] ^ 0x80) << 18;
		code |= (utf[2] ^ 0x80) << 12;
		code |= (utf[3] ^ 0x80) << 6;
		code |= (utf[4] ^ 0x80);
		return 4;
	}

	//we take six
	if ((c & 0xFF) == 0xFC) {
		for (i = 1; i <= 5; i++)
		if ((utf[i] & 0xC0) != 0x80)
			return 0;
		code = (c ^ 0xFC) << 30;
		code |= (utf[1] ^ 0x80) << 24;
		code |= (utf[2] ^ 0x80) << 18;
		code |= (utf[3] ^ 0x80) << 12;
		code |= (utf[4] ^ 0x80) << 6;
		code |= (utf[5] ^ 0x80);
		return 5;
	}
	return 0;
}

Exporting void s_unicode_to_utf8(string& s, wstring& str) {
	int i = 0;
	char inter[10];

	while (i < str.size()) {
		if (str[i] < 0x0080)
			s += (char)str[i];
		else {
			c_unicode_to_utf8(str[i], (uchar*)inter);
			s += inter;
		}
		i++;
	}
}

Exporting void sc_unicode_to_utf8(string& s, wstring& str) {
	int i = 0;
	char inter[10];
	s = "";

	while (i < str.size()) {
		if (str[i] < 0x0080)
			s += (char)str[i];
		else {
			c_unicode_to_utf8(str[i], (uchar*)inter);
			s += inter;
		}
		i++;
	}
}


Exporting void s_unicode_to_utf8(string& s, wchar_t* str) {
	int i = 0;
	char inter[10];

	while (str[i] != 0) {
		if (str[i] < 0x0080)
			s += (char)str[i];
		else {
			c_unicode_to_utf8(str[i], (uchar*)inter);
			s += inter;
		}
		i++;
	}
}

Exporting void s_utf8_to_unicode(wstring& s, char* str) {
	int i = 0;
	BULONG c;
	while (str[i] != 0) {
		i += c_utf8_to_unicode((uchar*)str + i, c) + 1;
		s += (wchar_t)c;
	}
}

Exporting void sc_utf8_to_unicode(wstring& s, char* str) {
	int i = 0;
	BULONG c;
	s = L"";
	while (str[i] != 0) {
		i += c_utf8_to_unicode((uchar*)str + i, c) + 1;
		s += (wchar_t)c;
	}
}

Exporting void s_doubleutf8_to_unicode(wstring& s, wchar_t* str, long l) {
	string sutf8;
	for (int i = 0; i < l; i++) {
		char lc = str[i] & 0xFF;
		char lr = (str[i] & 0xFF00) >> 8;
		sutf8 += lc;
		sutf8 += lr;
	}
	s_utf8_to_unicode(s, STR(sutf8));
}


Exporting void s_doubleutf8_to_unicode(wstring& s, wchar_t* str) {
	int i = 0;
	string sutf8;
	while (str[i] != 0) {
		char lc = str[i] & 0xFF;
		char lr = (str[i] & 0xFF00) >> 8;
		sutf8 += lc;
		sutf8 += lr;
		i++;
	}
	s_utf8_to_unicode(s, STR(sutf8));
}

Exporting char c_test_utf8(unsigned char* utf) {
	if (utf == NULL || utf[0] < 0x0080)
		return 0;
	unsigned char c = utf[0];
	if ((c & 0xE0) == 0xC0) {
		//We take two bytes
		if ((utf[1] & 0xC0) != 0x80)
			return 0;
		return 1;
	}
	//we take three
	if ((c & 0xF0) == 0xE0) {
		if ((utf[1] & 0xC0) != 0x80 || (utf[2] & 0xC0) != 0x80)
			return 0;
		return 2;
	}

	int i;
	//we take four
	if ((c & 0xF8) == 0xF0) {
		for (i = 1; i <= 3; i++)
		if ((utf[i] & 0xC0) != 0x80)
			return 0;
		return 3;
	}

	//we take five
	if ((c & 0xFC) == 0xF8) {
		for (i = 1; i <= 4; i++)
		if ((utf[i] & 0xC0) != 0x80)
			return 0;
		return 4;
	}

	//we take six
	if ((c & 0xFF) == 0xFC) {
		for (i = 1; i <= 5; i++)
		if ((utf[i] & 0xC0) != 0x80)
			return 0;
		return 5;
	}
	return 0;
}


Exporting  char c_detect_utf8(unsigned char* utf) {
	if (utf == NULL || utf[0] < 0x0080)
		return 0;

	unsigned char c = utf[0];
	if ((c & 0xE0) == 0xC0)
		return 1;

	//we take three
	if ((c & 0xF0) == 0xE0)
		return 2;

	int i;
	//we take four
	if ((c & 0xF8) == 0xF0)
		return 3;

	//we take five
	if ((c & 0xFC) == 0xF8)
		return 4;

	//we take six
	if ((c & 0xFF) == 0xFC)
		return 5;

	return 0;
}


Exporting  int conversion_utf8_to_fat(unsigned char* contenu, vector<string>& l) {
	int firstmul = -1;
	int lg = strlen((char*)contenu);
	l.reserve(lg);
	string res;
	for (int i = 0; i<lg; i++) {
		res = c_char_get(contenu, i);
		if (firstmul == -1 && res.size()>1)
			firstmul = res.size();
		l.push_back(res);
	}
	return firstmul;
}

Exporting void c_get_utf8_char(short code, string& v) {
	bulongchar xs;
	c_unicode_to_utf8(code, xs.ustr);
	v = xs.str;
}

Exporting unsigned char conversion_utf8_to_latin(short x) {
	if (x >= 32)
		return x;
	return 32;
}


//convert a character position into a byte position
Exporting  int c_chartobyteposition(unsigned char* contenu, int charpos) {
	int i = 0;
	while (charpos > 0) {
		i += 1 + c_test_utf8(contenu + i);
		charpos--;
	}
	return i;
}

Exporting  int c_bytetocharposition(unsigned char* contenu, int charpos) {
	int i = 0;
	int nb = 0;
	while (i < charpos) {
		i += 1 + c_test_utf8(contenu + i);
		nb++;
	}
	return nb;
}

Exporting int c_bytetocharpositionidx(unsigned char* contenu, int charpos, int& nb, int& i) {
	while (i<charpos) {
		i += 1 + c_test_utf8(contenu + i);
		nb++;
	}
	return nb;
}

Exporting  int c_chartobytepositionidx(unsigned char* contenu, int charpos, int& nb, int& i) {
	while (charpos>0) {
		i += 1 + c_test_utf8(contenu + i);
		nb++;
		charpos--;
	}
	return i;
}

Exporting  void conversion_utf8_to_fatOne(unsigned char* contenu, string& s) {
	int i = 0;
	s = c_char_get(contenu, i);
}


Exporting  int conversion_utf8_to_fat(string contenu, vector<string>& l) {
	return conversion_utf8_to_fat((unsigned char*)contenu.c_str(), l);
}

Exporting  void conversion_utf8_to_fatOne(string contenu, string& s) {
	conversion_utf8_to_fatOne((unsigned char*)contenu.c_str(), s);
}

Exporting char* s_utf8_to_latin(char* str) {
	static char local[2048];
	unsigned char* contenu = (unsigned char*)str;
	string res;
	int pos = 0;
	int longueur = strlen((char*)contenu);
	char cc = 0;
	uchar codelatin;
	int nb;
	for (int i = 0; i < longueur; i++) {
		nb = c_test_utf8(contenu + i);
		if (nb == 0)
			res += contenu[i];
		else {
			cc = contenu[i + nb + 1];
			contenu[i + nb + 1] = 0;
			c_utf8_to_latin(contenu + i, codelatin);
			res += (char)codelatin;
			contenu[i + nb + 1] = cc;
			i += nb;
		}
	}

	strcpy(local, STR(res));
	return local;
}

Exporting  string conversion_utf8_to_latin(unsigned char* contenu) {
	int longueur = strlen((char*)contenu);
	string res;
	char cc = 0;
	uchar codelatin;
	int nb;
	for (int i = 0; i < longueur; i++) {
		nb = c_test_utf8(contenu + i);
		if (nb == 0)
			res += contenu[i];
		else {
			cc = contenu[i + nb + 1];
			contenu[i + nb + 1] = 0;
			c_utf8_to_latin(contenu + i, codelatin);
			if (nb == 1 && codelatin == 83)
				res += "oe";
			else
			if (nb == 1 && codelatin == 82)
				res += "OE";
			else
				res += (char)codelatin;

			contenu[i + nb + 1] = cc;
			i += nb;
		}
	}
	return res;
}

Exporting  string conversion_latin_to_utf8(unsigned char* contenu) {
	int longueur = strlen((char*)contenu);
	string res;
	int nb;
	bulongchar xs;
	for (int i = 0; i < longueur; i++) {
		if (contenu[i] < 128)
			res += contenu[i];
		else {
			nb = c_test_utf8(contenu + i);
			if (nb != 0) {
				char cc = contenu[i + nb + 1];
				contenu[i + nb + 1] = 0;
				res += (char*)(contenu + i);
				contenu[i + nb + 1] = cc;
				i += nb;
			}
			else {
				xs.clear();
				c_latin_to_utf8(contenu[i], xs.ustr);
				res += xs.str;
			}
		}
	}
	return res;
}

Exporting  string conversion_latin_table_to_utf8(int table, unsigned char* contenu) {

	if (!alllatincodes.check(table))
		return "";

	hash_bin<unsigned short, int>& thetable = alllatincodes[table];

	int longueur = strlen((char*)contenu);
	string res;
	int nb;
	bulongchar xs;
	char ch[10];
	for (int i = 0; i < longueur; i++) {
		if (contenu[i] < 128)
			res += contenu[i];
		else {
			if (thetable.check(contenu[i])) {
				c_unicode_to_utf8(thetable[contenu[i]], (uchar*)ch);
				res += ch;
			}
			else {
				nb = c_test_utf8(contenu + i);
				if (nb != 0) {
					char cc = contenu[i + nb + 1];
					contenu[i + nb + 1] = 0;
					res += (char*)(contenu + i);
					contenu[i + nb + 1] = cc;
					i += nb;
				}
				else {
					xs.clear();
					c_latin_to_utf8(contenu[i], xs.ustr);
					res += xs.str;
				}
			}
		}
	}
	return res;
}

Exporting  wstring conversion_latin_table_to_unicode(int table, unsigned char* contenu) {

	if (!alllatincodes.check(table))
		return L"";

	hash_bin<unsigned short, int>& thetable = alllatincodes[table];

	int longueur = strlen((char*)contenu);
	wstring res;
	int nb;
	BULONG bu;
	for (int i = 0; i < longueur; i++) {
		if (contenu[i] < 128)
			res += contenu[i];
		else {
			if (thetable.check(contenu[i]))
				res += thetable[contenu[i]];
			else {
				nb = c_test_utf8(contenu + i);
				if (nb != 0) {
					char cc = contenu[i + nb + 1];
					contenu[i + nb + 1] = 0;
					c_utf8_to_unicode(contenu + i, bu);
					res += bu;
					contenu[i + nb + 1] = cc;
					i += nb;
				}
				else
					res += latincodes[contenu[i]];
			}
		}
	}
	return res;
}

Exporting string s_utf8_to_dos(unsigned char* contenu) {
	int longueur = strlen((char*)contenu);
	string res;
	string utf;
	char cc = 0;
	int nb;
	for (int i = 0; i < longueur; i++) {
		nb = c_test_utf8(contenu + i);
		if (nb == 0) {
			nb = contenu[i];
			if (nb <= 127 || !unicode2dos.check(nb))
				res += nb;
			else
				res += (char)unicode2dos[nb];
		}
		else {
			cc = contenu[i + nb + 1];
			contenu[i + nb + 1] = 0;
			utf = (char*)contenu + i;
			if (utf8_to_dos.find(utf) != utf8_to_dos.end())
				res += (unsigned char)utf8_to_dos[utf];
			else {
				utf = s_deaccentuate(USTR(utf));
				res += utf;
			}
			contenu[i + nb + 1] = cc;
			i += nb;
		}
	}
	return res;
}

Exporting string s_utf8_to_dos(const char* contenu) {
	string c(contenu);
	return s_utf8_to_dos(USTR(c));
}

Exporting string s_dos_to_utf8(unsigned char* contenu) {
	int longueur = strlen((char*)contenu);
	string res;
	int nb;
	bulongchar xs;
	for (int i = 0; i < longueur; i++) {
		if (contenu[i] <= 127)
			res += contenu[i];
		else
			res += dos_to_utf8[contenu[i]];
	}
	return res;
}

Exporting string s_dos_to_utf8(const char* contenu) {
	string c(contenu);
	return s_dos_to_utf8(USTR(c));
}

Exporting void s_latin_to_utf8(string& res, unsigned char* contenu) {
	res.clear();
	int longueur = strlen((char*)contenu);
	int nb;
	bulongchar xs;
	for (int i = 0; i < longueur; i++) {
		if (contenu[i] < 127)
			res += contenu[i];
		else {
			nb = c_test_utf8(contenu + i);
			if (nb != 0) {
				char cc = contenu[i + nb + 1];
				contenu[i + nb + 1] = 0;
				res += (char*)(contenu + i);
				contenu[i + nb + 1] = cc;
				i += nb;
			}
			else {
				xs.clear();
				c_latin_to_utf8(contenu[i], xs.ustr);
				res += xs.str;
			}
		}
	}
}

Exporting  string conversion_utf8_to_latin(string contenu) {
	return conversion_utf8_to_latin((unsigned char*)contenu.c_str());
}

Exporting  string conversion_latin_to_utf8(string contenu) {
	return conversion_latin_to_utf8((unsigned char*)contenu.c_str());
}

Exporting string s_replacestring(string& s, string& reg, string& rep) {
	int gsz = reg.size();
	if (!gsz)
		return s;

	int rsz = s.size();
	size_t foundHere;
	string neo;
	size_t from = 0;

	while ((foundHere = s.find(reg, from)) != string::npos) {
		if (foundHere != from)
			neo += s.substr(from, foundHere - from);
		neo += rep;
		from = foundHere + gsz;
	}

	if (from < rsz)
		neo += s.substr(from, rsz - from);

	return neo;
}

Exporting string s_replacestrings(string& s, string reg, string rep) {
	int gsz = reg.size();
	if (!gsz)
		return s;

	int rsz = s.size();
	size_t foundHere;
	string neo;
	size_t from = 0;

	while ((foundHere = s.find(reg, from)) != string::npos) {
		if (foundHere != from)
			neo += s.substr(from, foundHere - from);
		neo += rep;
		from = foundHere + gsz;
	}

	if (from < rsz)
		neo += s.substr(from, rsz - from);

	return neo;
}

Exporting wstring s_replacestring(wstring& s, wstring reg, wstring rep) {
	int gsz = reg.size();
	if (!gsz)
		return s;

	int rsz = s.size();
	size_t foundHere;
	wstring neo;
	size_t from = 0;

	while ((foundHere = s.find(reg, from)) != string::npos) {
		if (foundHere != from)
			neo += s.substr(from, foundHere - from);
		neo += rep;
		from = foundHere + gsz;
	}

	if (from < rsz)
		neo += s.substr(from, rsz - from);

	return neo;
}

Exporting int c_char_next(unsigned char* m, int& i) {

	int nb = c_test_utf8(m + i);
	i += nb;
	return (nb + 1);
}

Exporting int c_code_get(unsigned char* m, int& i, BULONG& code) {
	int nb = c_utf8_to_unicode(m + i, code);
	i += nb;
	return nb;
}

Exporting string c_char_get_next(unsigned char* m, int& i) {
	int nb = c_test_utf8(m + i);
	char str[] = { (char)m[i], 0, 0, 0, 0, 0, 0, 0 };

	if (nb == 0) {
		i++;
		return str;
	}

	char cc = m[i + nb + 1];
	m[i + nb + 1] = 0;
	strcpy(str, (char*)(m + i));
	m[i + nb + 1] = cc;
	i += nb + 1;
	return str;
}

Exporting  string c_char_get(unsigned char* m, int& i) {
	int nb = c_test_utf8(m + i);
	char str[] = { (char)m[i], 0, 0, 0, 0, 0, 0, 0 };

	if (nb == 0)
		return str;

	char cc = m[i + nb + 1];
	m[i + nb + 1] = 0;
	strcpy(str, (char*)(m + i));
	m[i + nb + 1] = cc;
	i += nb;
	return str;
}

Exporting  short c_char_get_wide(unsigned char* m, int& i) {
	BULONG code;
	i += c_utf8_to_unicode(m + i, code);
	return code;
}

Exporting  int size_c(string& s) {
	if (s == "")
		return 0;
	int lg = s.size();
	int sz = 0;
	uchar* contenu = USTR(s);
	for (int i = 0; i < lg; i++) {
		i += c_test_utf8(contenu + i);
		sz++;
	}
	return sz;
}

Exporting  int size_c(const char* s) {
	if (s == NULL || s[0] == 0)
		return 0;
	int lg = strlen((char*)s);
	int sz = 0;
	for (int i = 0; i < lg; i++) {
		i += c_test_utf8((uchar*)s + i);
		sz++;
	}
	return sz;
}

Exporting  string s_left(string& s, int nb) {
	if (nb < 0)
		return s;
	int lg = s.size();
	string res;
	for (int i = 0; i<lg && nb>0; i++) {
		res += c_char_get(USTR(s), i);
		nb--;
	}
	return res;
}

Exporting  wstring s_left(wstring& s, int nb) {
	if (nb < 0 || nb >= s.size())
		return s;
	return s.substr(0, nb);
}

Exporting  wstring s_right(wstring& s, int nb) {
	if (nb < 0 || nb >= s.size())
		return s;
	return s.substr(nb, nb);
}


Exporting  string s_right(string& s, int nb) {
	if (nb < 0)
		return s;
	int lg = s.size();
	int l = size_c(s);
	if (nb >= l)
		nb = 0;
	else
		l = l - nb;
	string res;
	//we position on the first character
	int i;
	uchar* contenu = USTR(s);
	for (i = 0; i<lg && l>0; i++) {
		i += c_test_utf8(contenu + i);
		l--;
	}

	for (; i < lg && nb >= 0; i++) {
		res += c_char_get(contenu, i);
		nb--;
	}
	return res;
}

Exporting  string s_middle(string& s, int l, int nb) {
	int lg = s.size();
	string res;
	//we position on the first character
	int i;
	uchar* contenu = USTR(s);
	for (i = 0; i<lg && l>0; i++) {
		i += c_test_utf8(contenu + i);
		l--;
	}

	for (; i<lg && nb>0; i++) {
		res += c_char_get(contenu, i);
		nb--;
	}
	return res;
}

Exporting  wstring s_middle(wstring& s, int l, int nb) {
	if (l + nb >= s.size())
		return L"";
	return s.substr(l, nb);
}


Exporting  bool c_char_index_assign(string& s, string c, int x) {
	if (x > s.size())
		return false;
	int i;
	uchar* contenu = USTR(s);
	int lg = s.size();
	for (i = 0; i<lg && x>0; i++) {
		i += c_test_utf8(contenu + i);
		x--;
	}
	if (i == lg)
		s += c;
	else {
		x = i;
		s.erase(i, c_test_utf8(contenu + x) + 1);
		s.insert(i, c);
	}
	return true;
}

Exporting  bool c_char_index_insert(string& s, string c, size_t x) {
	if (x > s.size())
		return false;
	int i;
	int lg = s.size();
	uchar* contenu = USTR(s);
	for (i = 0; i<lg && x>0; i++) {
		i += c_test_utf8(contenu + i);
		x--;
	}
	if (i == lg)
		s += c;
	else
		s.insert(i, c);
	return true;
}

Exporting  string c_char_index_remove(string& s, size_t i) {
	int lg = s.size();
	if (i >= lg)
		return "";
	string res;
	int pos = 0;
	int x;
	uchar* contenu = USTR(s);
	for (x = 0; x < lg && pos != i; x++) {
		x += c_test_utf8(contenu + x);
		pos++;
	}
	pos = x;
	res = c_char_get(USTR(s), pos);
	s.erase(x, res.size());
	return res;
}


Exporting  string c_char_index(string& s, size_t i) {
	int lg = s.size();
	if (i >= lg)
		return "";
	int x;
	uchar* contenu = USTR(s);
	for (x = 0; x<lg && i>0; x++) {
		x += c_test_utf8(contenu + x);
		i--;
	}
	if (x == lg)
		return "";

	return c_char_get(USTR(s), x);
}

Exporting  string s_char_reverse(string& s, int& length) {
	int lg = s.size();
	string res = "";
	string x;
	length = 0;
	for (int i = 0; i < lg; i++) {
		x = c_char_get(USTR(s), i);
		res.insert(0, x);
		length++;
	}
	return res;
}

Exporting string s_revert(string& s) {
	int lg = s.size();
	string res = "";
	string x;
	for (int i = 0; i < lg; i++) {
		x = c_char_get(USTR(s), i);
		res.insert(0, x);
	}
	return res;
}

wstring s_revert(wstring& s) {
	wstring res = L"";
	for (int i = s.size() - 1; i >= 0; i--)
		res += s[i];
	return res;
}

Exporting  char c_is_alpha(unsigned char* m, int& i) {
	BULONG v;
	c_utf8_to_unicode(m + i, v);

	if (utf8codemin.check(v))
		return 1;
	if (utf8codemaj.check(v))
		return 2;

	return 0;
}

Exporting  string s_insert_sep_byte(string& s, string sep) {
	string res;
	int lg = s.size();
	for (int i = 0; i < lg; i++) {
		if (i)
			res += sep;
		res += s[i];
	}
	return res;
}


Exporting  string s_insert_sep(string s, string sep) {
	string res;
	int lg = s.size();
	bool beg = true;
	for (int i = 0; i < lg; i++) {
		if (beg == false)
			res += sep;
		beg = false;
		res += c_char_get(USTR(s), i);
	}
	return res;
}

Exporting  string c_to_utf8(unsigned char* m) {
	return conversion_latin_to_utf8(m);
}

Exporting bool s_is_utf8(unsigned char* contenu, int longueur) {
	for (int i = 0; i < longueur; i++) {
		if (contenu[i] < 0xC0)
			continue;
		if (!c_test_utf8(contenu + i))
			continue;
		return true;
	}
	return false;
}

//return:
//0: if it is latin
//1: if it is pure ASCII
//2: if it is UTF8

Exporting char s_is_pure_utf8(unsigned char* contenu, int longueur) {
	char pure = 1;
	for (int i = 0; i < longueur; i++) {
		if (contenu[i] < 0xC0) {
			if (contenu[i] >= 0x80)
				pure = 0;
			continue;
		}
		if (!c_test_utf8(contenu + i))
			continue;
		return 2;
	}
	return pure;
}


Exporting  BULONG c_char_index_code(string& s, size_t i) {
	BULONG lg = s.size();
	uchar* contenu = USTR(s);
	int x;
	for (x = 0; x<lg && i>0; x++) {
		x += c_test_utf8(contenu + x);
		i--;
	}
	c_utf8_to_unicode(contenu + x, lg);
	return lg;
}

Exporting  void c_char_index_code_all(string& s, vector<int>& vect) {
	int lg = s.size();
	uchar* contenu = USTR(s);
	vect.reserve(lg);
	BULONG code;
	for (int i = 0; i < lg; i++) {
		i += c_utf8_to_unicode(contenu + i, code);
		vect.push_back(code);
	}
}

Exporting  void c_char_index_code_all_long(string& s, vector<long>& vect) {
	int lg = s.size();
	uchar* contenu = USTR(s);
	vect.reserve(lg);
	BULONG code;
	for (int i = 0; i < lg; i++) {
		i += c_utf8_to_unicode(contenu + i, code);
		vect.push_back(code);
	}
}


//On renvoie le code LATIN correspondant, 0 sinon
Exporting  unsigned char c_utf8_latin(string s) {
	BULONG v;
	c_utf8_to_unicode(USTR(s), v);
	if (v > 255)
		return 0;
	return (uchar)v;
}

//On renvoie la chaine UTF8 correspondante, 0 sinon
string c_latin_utf8(int c) {
	bulongchar xs;
	c_latin_to_utf8(c, xs.ustr);
	return xs.str;
}

Exporting bool s_is_punctuation(wstring& str) {
	for (int i = 0; i < str.size(); i++) {
		if (!punctuations.check(str[i]))
			return false;
	}
	return true;
}

Exporting bool c_is_space(BULONG code) {
	static unsigned char spaces[] = { 9, 10, 13, 32, 160 };
	if (strchr((char*)spaces, (char)code) || code == 0x202F)
		return true;
	return false;
}

Exporting bool s_is_space(string& str) {
	static unsigned char spaces[] = { 9, 10, 13, 32, 160 };
	int lg = str.size();
	uchar* contenu = USTR(str);
	BULONG code;
	for (int i = 0; i < lg; i++) {
		i += c_utf8_to_unicode(contenu + i, code);
		if (!strchr((char*)spaces, (char)code) && code != 0x202F)
			return false;
	}
	return true;
}

Exporting bool c_is_punctuation(BULONG code) {
	return punctuations.check(code);
}


Exporting bool s_is_punctuation(string& str) {
	int lg = str.size();
	uchar* contenu = USTR(str);
	BULONG code;
	for (int i = 0; i < lg; i++) {
		i += c_utf8_to_unicode(contenu + i, code);
		if (!punctuations.check(code))
			return false;
	}
	return true;
}

Exporting  bool s_is_upper(string s) {
	if (s == "")
		return false;
	int lg = s.size();
	for (int i = 0; i < lg; i++) {
		char ty = c_is_alpha(USTR(s), i);
		if (ty != 2)
			return false;
	}
	return true;
}

Exporting  bool s_is_alpha(wstring& s) {
	if (s == L"")
		return false;
	for (int i = 0; i < s.size(); i++) {
		if (!utf8codemaj.check(s[i]) && !utf8codemin.check(s[i]))
			return false;
	}
	return true;
}


Exporting  bool s_is_upper(wstring& s) {
	if (s == L"")
		return false;
	for (int i = 0; i < s.size(); i++) {
		if (!utf8codemaj.check(s[i]))
			return false;
	}
	return true;
}

Exporting  bool s_is_lower(wstring& s) {
	if (s == L"")
		return false;
	for (int i = 0; i < s.size(); i++) {
		if (!utf8codemin.check(s[i]))
			return false;
	}
	return true;
}

Exporting  bool s_is_consonant(wstring& s) {
	if (s == L"")
		return false;
	for (int i = 0; i < s.size(); i++) {
		if (!consonants.check(s[i]))
			return false;
	}
	return true;
}

Exporting  bool s_is_vowel(wstring& s) {
	if (s == L"")
		return false;
	for (int i = 0; i < s.size(); i++) {
		if (!vowels.check(s[i]))
			return false;
	}
	return true;
}


Exporting bool s_is_consonant(unsigned char* s) {
	if (s[0] == 0)
		return false;
	int lg = strlen((char*)s);
	BULONG code;

	for (int i = 0; i < lg; i++) {
		c_code_get(s, i, code);
		if (!consonants.check(code))
			return false;
	}

	return true;
}

Exporting  bool s_is_vowel(unsigned char* s) {
	if (s[0] == 0)
		return false;
	int lg = strlen((char*)s);
	BULONG code;

	for (int i = 0; i < lg; i++) {
		c_code_get(s, i, code);
		if (!vowels.check(code))
			return false;
	}

	return true;
}

static inline bool addbit(BULONG& code, BULONG& v, int& I, int& nb, int mx, int mxsz, char add) {
	if (add == 1)
		code |= v;
	v <<= 1;
	nb++;
	if (nb >= mxsz) {
		I++;
		nb = 0;
		v = 1;
		if (I >= mx)
			return false;
	}
	return true;
}

Exporting void s_binary(unsigned char* s, int mx, int lg, BULONG* codes) {
	static hash_bin<unsigned short, bool> rares;
	static bool init = false;

	if (!init) {
		rares['k'] = true;
		rares['z'] = true;
		rares['w'] = true;
		rares['x'] = true;
		rares['q'] = true;
		rares['h'] = true;
		rares['j'] = true;
		rares['K'] = true;
		rares['Z'] = true;
		rares['W'] = true;
		rares['X'] = true;
		rares['Q'] = true;
		rares['H'] = true;
		rares['J'] = true;
		init = false;
	}

	BULONG code;
	int I = 0;
	BULONG v = 1;
	int nb;
	int mxsz = sizeof(BULONG);
	//z,w,x,q,h,j,k
	string c;

	for (int i = 0; i < lg; i++) {
		c_code_get(s, i, code);
		if (code <= 32)
			continue;
		if (vowels.check(code)) { //0001
			if (!addbit(codes[I], v, I, nb, mx, mxsz, 1))
				break;
			if (!addbit(codes[I], v, I, nb, mx, mxsz, 0))
				break;
			if (!addbit(codes[I], v, I, nb, mx, mxsz, 0))
				break;
			if (!addbit(codes[I], v, I, nb, mx, mxsz, 0))
				break;
		}
		else {
			if (consonants.check(code)) {//0010
				c = consonants[code];

				if (!addbit(codes[I], v, I, nb, mx, mxsz, 0))
					break;

				if (!addbit(codes[I], v, I, nb, mx, mxsz, 1))
					break;

				if (rares.check(c[0])) {//0110
					if (!addbit(codes[I], v, I, nb, mx, mxsz, 1))
						break;
				}
				else
				if (!addbit(codes[I], v, I, nb, mx, mxsz, 0))
					break;

				if (!addbit(codes[I], v, I, nb, mx, mxsz, 0))
					break;
			}
			else { //1000
				if (!addbit(codes[I], v, I, nb, mx, mxsz, 0))
					break;
				if (!addbit(codes[I], v, I, nb, mx, mxsz, 0))
					break;
				if (!addbit(codes[I], v, I, nb, mx, mxsz, 0))
					break;
				if (!addbit(codes[I], v, I, nb, mx, mxsz, 1))
					break;
			}
		}
	}
}

Exporting wstring s_deaccentuate(wstring& s) {
	if (s == L"")
		return L"";

	int lg = s.size();
	BULONG code;
	wstring v;

	for (int i = 0; i < lg; i++) {
		code = s[i];
		if (wvowels.check(code)) {
			v += wvowels[code];
			continue;
		}
		if (wconsonants.check(code)) {
			v += wconsonants[code];
			continue;
		}
		v += code;
	}
	return v;
}
Exporting  string s_deaccentuate(unsigned char* s) {
	if (s[0] == 0)
		return "";

	int lg = strlen((char*)s);
	BULONG code;
	string v;
	int nb, I;
	char m[10];
	unsigned char c;

	for (int i = 0; i < lg; i++) {
		I = i + 1;
		nb = c_code_get(s, i, code);
		if (vowels.check(code)) {
			v += vowels[code];
			continue;
		}
		if (consonants.check(code)) {
			v += consonants[code];
			continue;
		}
		if (!nb)
			v += s[i];
		else {
			c = s[I + nb];
			s[I + nb] = 0;
			strcpy(m, (char*)s + I - 1);
			s[I + nb] = c;
			v += m;
		}
	}
	return v;
}

Exporting  bool s_is_alpha(string s) {
	if (s == "")
		return false;
	int lg = s.size();
	for (int i = 0; i < lg; i++) {
		char ty = c_is_alpha(USTR(s), i);
		if (ty == 0)
			return false;
	}
	return true;
}

Exporting  bool s_is_lower(string s) {
	if (s == "")
		return false;

	int lg = s.size();
	for (int i = 0; i < lg; i++) {
		char ty = c_is_alpha(USTR(s), i);
		if (ty != 1)
			return false;
	}
	return true;
}

Exporting BULONG c_to_lower(BULONG c) {
	if (utf8codemaj.check(c))
		return utf8codemaj[c];
	return c;
}

Exporting BULONG c_to_upper(BULONG c) {
	if (utf8codemin.check(c))
		return utf8codemin[c];
	return c;
}

Exporting bool b_alpha(BULONG c) {
	if (utf8codemaj.check(c) || utf8codemin.check(c))
		return true;
	return false;
}

//return 0 (not alpha), 1 (lower), 2 (upper)
Exporting char c_is_alpha(BULONG code) {
	if (utf8codemin.check(code))
		return 1;

	if (utf8codemaj.check(code))
		return 2;
	return 0;
}

Exporting bool c_is_lower(BULONG code) {
	return utf8codemin.check(code);
}

Exporting bool c_is_upper(BULONG code) {
	return utf8codemaj.check(code);
}

Exporting  wstring s_to_lower(wstring& s) {
	wstring res;
	int lg = s.size();
	for (int i = 0; i < lg; i++)
		res += c_to_lower(s[i]);
	return res;
}

Exporting  wstring s_to_upper(wstring& s) {
	wstring res;
	int lg = s.size();
	for (int i = 0; i < lg; i++)
		res += c_to_upper(s[i]);
	return res;
}


Exporting  string s_to_lower(string s) {
	string res;
	BULONG v;
	int lg = s.size();
	for (int i = 0; i < lg; i++) {
		i += c_utf8_to_unicode(USTR(s) + i, v);
		if (utf8codemaj.check(v))
			v = utf8codemaj[v];

		res += s_unicode_to_utf8(v);
	}
	return res;
}

Exporting  string s_to_upper(string s) {
	string res;
	BULONG v;
	int lg = s.size();
	for (int i = 0; i < lg; i++) {
		i += c_utf8_to_unicode(USTR(s) + i, v);
		if (utf8codemin.check(v))
			v = utf8codemin[v];

		res += s_unicode_to_utf8(v);
	}
	return res;
}

Exporting  void c_to_lower(string& res, unsigned char* s, int lg) {
	res = "";
	BULONG v;
	for (int i = 0; i < lg; i++) {
		i += c_utf8_to_unicode(s + i, v);
		if (utf8codemaj.check(v))
			v = utf8codemaj[v];

		res += s_unicode_to_utf8(v);
	}	
}

Exporting  void c_to_upper(string& res, unsigned char* s, int lg) {
	res = "";
	BULONG v;
	for (int i = 0; i < lg; i++) {
		i += c_utf8_to_unicode(s + i, v);
		if (utf8codemin.check(v))
			v = utf8codemin[v];

		res += s_unicode_to_utf8(v);
	}
}

//we are looking for the substring substr in s
Exporting int s_find(uchar* s, string substr, int i) {
	int nb = 0, ps = 0;
	i = c_chartobytepositionidx(s, i, nb, ps);

	char* pt = strstr((char*)s + i, STR(substr));
	if (pt == NULL)
		return -1;
	i = pt - (char*)s;
	return c_bytetocharpositionidx(s, i, nb, ps);
}


//we are looking for the substring substr in s
Exporting int s_rfind(uchar* sx, string substr, int i) {
	string s = (char*)sx;
	i = c_chartobyteposition(sx, i);
	i = s.rfind(substr, i);
	if (i == string::npos)
		return -1;
	return c_bytetocharposition(sx, i);
}

//we are looking for the substring substr in s
Exporting int s_find(string& s, string substr, int i) {
	int nb = 0, ps = 0;
	i = c_chartobytepositionidx(USTR(s), i, nb, ps);
	i = s.find(substr, i);
	if (i == string::npos)
		return -1;
	return c_bytetocharpositionidx(USTR(s), i, nb, ps);
}


//we are looking for the substring substr in s
Exporting int s_rfind(string& s, string substr, int i) {
	i = c_chartobyteposition(USTR(s), i);
	i = s.rfind(substr, i);
	if (i == string::npos)
		return -1;
	return c_bytetocharposition(USTR(s), i);
}

Exporting bool c_is_digit(BULONG code) {
	if (code >= '0' && code <= '9')
		return true;
	return false;
}

Exporting bool s_threedigits(wstring& s, int i) {
	if (i > s.size() - 3)
		return false;
	if (s[i] >= 48 && s[i] <= 57 && s[i + 1] >= 48 && s[i + 1] <= 57 && s[i + 2] >= 48 && s[i + 2] <= 57) {
		if (i < s.size() - 3)
		if (s[i + 3] >= 48 && s[i + 3] <= 57)
			return false;
		return true;
	}
	return false;
}

string& Trim(string& chaine) {
	int d, f;
	for (d = 0; d<chaine.size(); d++) {
		if ((uchar)chaine[d]>32)
			break;
	}

	for (f = chaine.size() - 1; f >= 0; f--) {
		if ((uchar)chaine[f] > 32)
			break;
	}
	int lg = f - d + 1;
	if (lg >= 1)
		chaine = chaine.substr(d, lg);
	else
		chaine = "";
	return chaine;
}

string& Trimleft(string& chaine) {
	int d, f;
	f = chaine.size() - 1;
	for (d = 0; d<chaine.size(); d++) {
		if ((uchar)chaine[d]>32)
			break;
	}

	int lg = f - d + 1;
	if (lg >= 1)
		chaine = chaine.substr(d, lg);
	else
		chaine = "";
	return chaine;
}

string& Trimright(string& chaine) {
	int d = 0, f;

	for (f = chaine.size() - 1; f >= 0; f--) {
		if ((uchar)chaine[f] > 32)
			break;
	}

	int lg = f - d + 1;
	if (lg >= 1)
		chaine = chaine.substr(d, lg);
	else
		chaine = "";
	return chaine;
}

wstring& Trim(wstring& chaine) {
	int d, f;
	for (d = 0; d<chaine.size(); d++) {
		if (chaine[d]>32)
			break;
	}

	for (f = chaine.size() - 1; f >= 0; f--) {
		if (chaine[f] > 32)
			break;
	}
	int lg = f - d + 1;
	if (lg >= 1)
		chaine = chaine.substr(d, lg);
	else
		chaine = L"";
	return chaine;
}

wstring& Trimleft(wstring& chaine) {
	int d, f;
	f = chaine.size() - 1;
	for (d = 0; d<chaine.size(); d++) {
		if (chaine[d]>32)
			break;
	}

	int lg = f - d + 1;
	if (lg >= 1)
		chaine = chaine.substr(d, lg);
	else
		chaine = L"";
	return chaine;
}

wstring& Trimright(wstring& chaine) {
	int d = 0, f;

	for (f = chaine.size() - 1; f >= 0; f--) {
		if (chaine[f] > 32)
			break;
	}

	int lg = f - d + 1;
	if (lg >= 1)
		chaine = chaine.substr(d, lg);
	else
		chaine = L"";
	return chaine;
}

void v_split(string& thestr, string thesplitter, vector<string>& v) {
	size_t pos = 0;
	size_t found = 0;
	size_t nxt;
	string value;

	pos = 0;
	found = 0;

	while (pos != string::npos) {
		found = thestr.find(thesplitter, pos);
		if (found != string::npos) {
			value = thestr.substr(pos, found - pos);
			Trim(value);
			if (value != "")
				v.push_back(value);
			else
			if (thesplitter == "\n")
				v.push_back(thesplitter);
			pos = found + thesplitter.size();
		}
		else
			break;
	}

	value = thestr.substr(pos, thestr.size() - pos);
	Trim(value);
	if (value != "")
		v.push_back(value);
}

static bool comparing(wstring& w, wstring s) {
	if (w == s)
		return true;
	return false;
}

void s_tokenize(vector<wstring>& vect, wstring& ustr, map<wstring, bool>& wkeeps) {

	//First we split along spaces
	int i;


	BULONG c;
	wstring thesplitter;
	wstring punct;
	//we split along space characters...
	for (i = 0; i < ustr.size(); i++) {
		c = ustr[i];
		if (c <= 32) {
			if (thesplitter.size()) {
				if (wkeeps.find(thesplitter) == wkeeps.end()) {
					if (punct.size()) {
						thesplitter = thesplitter.substr(0, thesplitter.size() - punct.size());
						vect.push_back(thesplitter);
						for (int j = 0; j < punct.size(); j++) {
							thesplitter = punct[j];
							vect.push_back(thesplitter);
						}
					}
					else
						vect.push_back(thesplitter);
				}
				else
					vect.push_back(thesplitter);
				thesplitter = L"";
				punct = L"";
			}
		}
		else {
			thesplitter += c;
			if (c_is_punctuation(c))
				punct += c;
			else
				punct = L"";
		}
	}

	if (thesplitter.size()) {
		if (wkeeps.find(thesplitter) == wkeeps.end()) {
			if (punct.size()) {
				thesplitter = thesplitter.substr(0, thesplitter.size() - punct.size());
				vect.push_back(thesplitter);
				for (int j = 0; j < punct.size(); j++) {
					thesplitter = punct[j];
					vect.push_back(thesplitter);
				}
			}
			else
				vect.push_back(thesplitter);
		}
		else
			vect.push_back(thesplitter);
	}
}

void vw_tokenize(vector<wstring>& vect, wstring& ustr, short flags) {

	bool comma, separator, periodseparator, keepwithdigit, keeprc;

	if ((flags&token_comma) == token_comma)
		comma = true;
	else
		comma = false;

	if ((flags&token_separator) == token_separator)
		separator = true;
	else
		separator = false;

	if ((flags&token_period) == token_period)
		periodseparator = true;
	else
		periodseparator = false;

	if ((flags&token_keepwithdigit) == token_keepwithdigit)
		keepwithdigit = true;
	else
		keepwithdigit = false;

	if ((flags&token_keepwithdigit) == token_keepwithdigit)
		keepwithdigit = true;
	else
		keepwithdigit = false;

	if ((flags&token_keeprc) == token_keeprc)
		keeprc = true;
	else
		keeprc = false;

	wchar_t decimal[] = { '.', ',' };

	if (comma) {
		decimal[0] = ',';
		decimal[1] = '.';
	}

	wstring token;
	wstring digits;

	short fcomma = 0;
	BULONG c, cnext, csupnext, csupsupnext;
	bool store;
	int i;
	int sz = ustr.size();
	int nbdigits = 0;
	bool accumulateuptospace = false;

	for (i = 0; i < sz; i++) {
		c = ustr[i];
		cnext = 0;
		csupnext = 0;
		csupsupnext = 0;
		if (i + 1 < sz) {
			cnext = ustr[i + 1];
			if (i + 2 < sz) {
				csupnext = ustr[i + 2];
				if (i + 3 < sz)
					csupsupnext = ustr[i + 3];
			}
		}

		if (keeprc && (c == 10 || c == 13)) {
			if (vect.size()) {
				token = vect.back();
				if (!token.size() || (token[0] != 10 && token[0] != 13)) {
					token = c;
					vect.push_back(token);
				}
			}
			else {
				token = c;
				vect.push_back(token);
			}

			fcomma = 0;
			digits.clear();
			token.clear();
			nbdigits = 0;
			accumulateuptospace = false;
			continue;
		}

		//digit
		store = true;
		if (accumulateuptospace) {
			if (c > 32) {
				if (c > 127 || !strchr("[]{}()|,;:'\"", (char)c)) {
					token += c;
					store = false;
				}
			}
			else
				store = false;
		}
		else {
			if (c_is_digit(c)) {
				store = false;
				if (token.size() == 0) {
					digits += c;
					nbdigits++;
				}
				else
					token += c;
			}
			else {
				//punctuation		
				if (c_is_punctuation(c)) {
					switch (c) {
					case '#':
						if (digits.size() != 0) {
							token = digits;
							digits.clear();
						}
						token += c;
						store = false;
						break;
					case '@':
						if (digits.size() != 0) {
							token = digits;
							digits.clear();
						}
						if (cnext > 32 && !c_is_punctuation(cnext)) {
							token += c;
							store = false;
							accumulateuptospace = true;
						}
						break;
					case '_':
						if (cnext > 32 && !c_is_punctuation(cnext)) {
							token += c;
							store = false;
						}
						break;
					case '+':
						if (digits.size() == 0 && c_is_digit(cnext)) {
							digits = '+';
							store = false;
						}
						break;
					case '-':
						if (digits.size() == 0 && c_is_digit(cnext) && token.size() == 0) {
							digits = '-';
							store = false;
						}
						else
						if (token.size() && cnext > 32 && !c_is_punctuation(cnext)) {
							token += c;
							store = false;
						}
						break;
					case '/': //UNIX path
						if (!keeprc && digits.size() == 0 && token.size() == 0 && (cnext == '/' || !c_is_punctuation(cnext))) {
							token = c;
							store = false;
							accumulateuptospace = true;
						}
						break;
					case ':': //Windows path
						if (!keeprc && token.size() == 1 && cnext == '\\' && ((token[0] >= 'A' && token[0] <= 'Z') || (token[0] >= 'a' && token[0] <= 'z'))) {
							token += c;
							store = false;
							accumulateuptospace = true;
						}
						break;
					case ',':
					case '.':
						if (digits.size() != 0 && c_is_digit(cnext)) {
							if (c == decimal[1]) {
								if (!separator || nbdigits != 3)
									break;
								nbdigits = 0;
							}
							else
								fcomma++;
							digits += c;
							store = false;
						}
						else {
							if (periodseparator == true && c == '.' && token.size() && cnext > 32 && !c_is_punctuation(cnext)) {
								store = false;
								token += c;
							}
						}
						break;
					}
				}
				else {
					store = false;
					if (c > 32) {
						if (keepwithdigit && digits.size())
							digits += c;
						else {
							if ((c == 'e' || c == 'E') && digits.size() && fcomma == 1 && (c_is_digit(cnext) || (cnext == '-' && c_is_digit(csupnext)))) {
								digits += c;
								if (cnext == '-') {
									digits += cnext;
									i++;
								}
							}
							else {
								if (digits.size() != 0) {
									vect.push_back(digits);
									fcomma = 0;
									digits.clear();
									nbdigits = 0;
								}
								token += c;
								if (token == L"http" && cnext == ':' && csupnext == '/' && csupsupnext == '/') {
									token += L"://";
									i += 3;
									accumulateuptospace = true;
								}
							}
						}
					}
				}
			}
		}

		if (store || c <= 32) {
			if (token.size() != 0)
				vect.push_back(token);
			else {
				if (digits.size() != 0)
					vect.push_back(digits);
			}
			if (store) {
				token = c;
				vect.push_back(token);
			}
			fcomma = 0;
			digits.clear();
			token.clear();
			nbdigits = 0;
			accumulateuptospace = false;
		}
	}

	if (token.size() != 0)
		vect.push_back(token);
	else
	if (digits.size() != 0)
		vect.push_back(digits);
}

void s_tokenize(vector<string>& vect, string& thestr, map<string, bool>& keeps) {

	//First we split along spaces
	int i;
	map<wstring, bool> wkeeps;

	wstring ustr;
	string s;
	map<string, bool>::iterator it;
	for (it = keeps.begin(); it != keeps.end(); it++) {
		s = it->first;
		ustr = L"";
		if (!s_is_pure_utf8(USTR(s), s.size())) {
			string fstr;
			s_latin_to_utf8(fstr, USTR(s));
			s_utf8_to_unicode(ustr, STR(fstr));
		}
		else
			s_utf8_to_unicode(ustr, STR(s));
		wkeeps[ustr] = true;
	}

	ustr = L"";
	if (!s_is_pure_utf8(USTR(thestr), thestr.size())) {
		s = "";
		s_latin_to_utf8(s, USTR(thestr));
		s_utf8_to_unicode(ustr, STR(s));
	}
	else
		s_utf8_to_unicode(ustr, STR(thestr));


	BULONG c;
	wstring thesplitter;
	wstring punct;
	//we split along space characters...
	for (i = 0; i < ustr.size(); i++) {
		c = ustr[i];
		if (c <= 32) {
			if (thesplitter.size()) {
				if (wkeeps.find(thesplitter) == wkeeps.end()) {
					if (punct.size()) {
						thesplitter = thesplitter.substr(0, thesplitter.size() - punct.size());
						s = "";
						s_unicode_to_utf8(s, (wchar_t*)thesplitter.c_str());
						vect.push_back(s);
						for (int j = 0; j < punct.size(); j++) {
							s = "";
							thesplitter = punct[j];
							s_unicode_to_utf8(s, (wchar_t*)thesplitter.c_str());
							vect.push_back(s);
						}
					}
					else {
						s = "";
						s_unicode_to_utf8(s, (wchar_t*)thesplitter.c_str());
						vect.push_back(s);
					}
				}
				else {
					s = "";
					s_unicode_to_utf8(s, (wchar_t*)thesplitter.c_str());
					vect.push_back(s);
				}
				thesplitter = L"";
				punct = L"";
			}
		}
		else {
			thesplitter += c;
			if (c_is_punctuation(c))
				punct += c;
			else
				punct = L"";
		}
	}

	if (thesplitter.size()) {
		if (wkeeps.find(thesplitter) == wkeeps.end()) {
			if (punct.size()) {
				thesplitter = thesplitter.substr(0, thesplitter.size() - punct.size());
				s = "";
				s_unicode_to_utf8(s, (wchar_t*)thesplitter.c_str());
				vect.push_back(s);
				for (int j = 0; j < punct.size(); j++) {
					s = "";
					thesplitter = punct[j];
					s_unicode_to_utf8(s, (wchar_t*)thesplitter.c_str());
					vect.push_back(s);
				}
			}
			else {
				s = "";
				s_unicode_to_utf8(s, (wchar_t*)thesplitter.c_str());
				vect.push_back(s);
			}
		}
		else {
			s = "";
			s_unicode_to_utf8(s, (wchar_t*)thesplitter.c_str());
			vect.push_back(s);
		}
	}
}

void v_tokenize(vector<string>& vect, string& thestr, short flags) {

	bool comma, separator, periodseparator, keepwithdigit;

	if ((flags&token_comma) == token_comma)
		comma = true;
	else
		comma = false;

	if ((flags&token_separator) == token_separator)
		separator = true;
	else
		separator = false;

	if ((flags&token_period) == token_period)
		periodseparator = true;
	else
		periodseparator = false;

	if ((flags&token_keepwithdigit) == token_keepwithdigit)
		keepwithdigit = true;
	else
		keepwithdigit = false;

	char decimal[] = { '.', ',' };

	if (comma) {
		decimal[0] = ',';
		decimal[1] = '.';
	}

	//first we convert into unicode

	wstring ustr;
	if (!s_is_pure_utf8(USTR(thestr), thestr.size())) {
		string fstr;
		s_latin_to_utf8(fstr, USTR(thestr));
		s_utf8_to_unicode(ustr, STR(fstr));
	}
	else
		s_utf8_to_unicode(ustr, STR(thestr));

	thestr.clear();
	wstring token;
	wstring digits;
	string localstring;
	short fcomma = 0;
	BULONG c, cnext, csupnext, csupsupnext;
	bool store;
	int i;
	int sz = ustr.size();
	int nbdigits = 0;
	bool accumulateuptospace = false;

	for (i = 0; i < sz; i++) {
		c = ustr[i];
		cnext = 0;
		csupnext = 0;
		csupsupnext = 0;
		if (i + 1 < sz) {
			cnext = ustr[i + 1];
			if (i + 2 < sz) {
				csupnext = ustr[i + 2];
				if (i + 3<sz)
					csupsupnext = ustr[i + 3];
			}
		}

		//digit
		store = true;
		if (accumulateuptospace) {
			if (c > 32) {
				if (c > 32 && (c > 127 || !strchr("[]{}()|,;:'\"", (char)c))) {
					token += c;
					store = false;
				}
			}
			else
				store = false;
		}
		else {
			if (c_is_digit(c)) {
				store = false;
				if (token.size() == 0) {
					digits += c;
					nbdigits++;
				}
				else
					token += c;
			}
			else {
				//punctuation		
				if (c_is_punctuation(c)) {
					switch (c) {
					case '#':
						if (digits.size() != 0) {
							token = digits;
							digits.clear();
						}
						token += c;
						store = false;
						break;
					case '@':
						if (digits.size() != 0) {
							token = digits;
							digits.clear();
						}
						if (cnext > 32 && !c_is_punctuation(cnext)) {
							token += c;
							store = false;
							accumulateuptospace = true;
						}
						break;
					case '_':
						if (cnext > 32 && !c_is_punctuation(cnext)) {
							token += c;
							store = false;
						}
						break;
					case '+':
						if (digits.size() == 0 && c_is_digit(cnext)) {
							digits = '+';
							store = false;
						}
						break;
					case '-':
						if (digits.size() == 0 && c_is_digit(cnext) && token.size() == 0) {
							digits = '-';
							store = false;
						}
						else
						if (token.size() && cnext > 32 && !c_is_punctuation(cnext)) {
							token += c;
							store = false;
						}
						break;
					case '/': //UNIX path
						if (digits.size() == 0 && token.size() == 0 && (cnext == '/' || !c_is_punctuation(cnext))) {
							token = c;
							store = false;
							accumulateuptospace = true;
						}
						break;
					case ':': //Windows path
						if (token.size() == 1 && cnext == '\\' && ((token[0] >= 'A' && token[0] <= 'Z') || (token[0] >= 'a' && token[0] <= 'z'))) {
							token += c;
							store = false;
							accumulateuptospace = true;
						}
						break;
					case ',':
					case '.':
						if (digits.size() != 0 && c_is_digit(cnext)) {
							if (c == decimal[1]) {
								if (!separator || nbdigits != 3)
									break;
								nbdigits = 0;
							}
							else
								fcomma++;
							digits += c;
							store = false;
						}
						else {
							if (periodseparator == true && c == '.' && token.size() && cnext > 32 && !c_is_punctuation(cnext)) {
								store = false;
								token += c;
							}
						}
						break;
					}
				}
				else {
					store = false;
					if (c > 32) {
						if (keepwithdigit && digits.size())
							digits += c;
						else {
							if ((c == 'e' || c == 'E') && digits.size() && fcomma == 1 && (c_is_digit(cnext) || (cnext == '-' && c_is_digit(csupnext)))) {
								digits += c;
								if (cnext == '-') {
									digits += cnext;
									i++;
								}
							}
							else {
								if (digits.size() != 0) {
									localstring.clear();
									s_unicode_to_utf8(localstring, (wchar_t*)digits.c_str());
									vect.push_back(localstring);
									fcomma = 0;
									digits.clear();
									nbdigits = 0;
								}
								token += c;
								if (token == L"http" && cnext == ':' && csupnext == '/' && csupsupnext == '/') {
									token += L"://";
									i += 3;
									accumulateuptospace = true;
								}
							}
						}
					}
				}
			}
		}

		if (store || c <= 32) {
			if (token.size() != 0) {
				localstring.clear();
				s_unicode_to_utf8(localstring, (wchar_t*)token.c_str());
				vect.push_back(localstring);
			}
			else {
				if (digits.size() != 0) {
					localstring.clear();
					s_unicode_to_utf8(localstring, (wchar_t*)digits.c_str());
					vect.push_back(localstring);
				}
			}
			if (store) {
				localstring.clear();
				token = c;
				s_unicode_to_utf8(localstring, (wchar_t*)token.c_str());
				vect.push_back(localstring);
			}
			fcomma = 0;
			digits.clear();
			token.clear();
			nbdigits = 0;
			accumulateuptospace = false;
		}
	}

	localstring.clear();
	if (token.size() != 0) {
		s_unicode_to_utf8(localstring, (wchar_t*)token.c_str());
		vect.push_back(localstring);
	}
	else
	if (digits.size() != 0) {
		s_unicode_to_utf8(localstring, (wchar_t*)digits.c_str());
		vect.push_back(localstring);
	}
}

Exporting bool s_is_digit(string& str) {
	static char tabs[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
	int lg = str.size();
	int i = 0;
	if (str[0] == '-' || str[0] == '.')
		i++;
	bool digit = false;
	bool dot = false;
	int countdigits = 0;
	for (; i < lg; i++) {
		if (str[i] == '.' || str[i] == ',') {
			if (!digit)
				return false;

			if (str[i] == '.') {
				if (dot)
					return false;
				dot = true;
			}
			else {
				if (countdigits != 3)
					return false;
			}
			countdigits = 0;
			continue;
		}

		if (strchr(tabs, str[i]) == NULL)
			return false;
		countdigits++;
		digit = true;
	}

	if (!digit)
		return false;
	return true;
}

Exporting bool s_is_digit(wstring& str) {
	int lg = str.size();
	int i = 0;
	if (str[0] == '-' || str[0] == '.')
		i++;
	bool digit = false;
	bool dot = false;
	int countdigits = 0;
	for (; i < lg; i++) {
		if (str[i] == '.' || str[i] == ',') {
			if (!digit)
				return false;

			if (str[i] == '.') {
				if (dot)
					return false;
				dot = true;
			}
			else {
				if (countdigits != 3)
					return false;
			}
			countdigits = 0;
			continue;
		}

		if (str[i]<'0' || str[i]>'9')
			return false;

		countdigits++;
		digit = true;
	}

	if (!digit)
		return false;
	return true;
}

Exporting char s_is_number(uchar* str, char decimal, long& l, double& f) {
	size_t sz = strlen((char*)str);
	double nbdecimal = 1;
	bool founddecimalpoint = false;
	l = 0;
	f = 0;
	for (int i = 0; i < sz; i++) {
		if (str[i] >= '0' && str[i] <= '9') {
			if (!founddecimalpoint)
				l = l * 10 + (str[i] - 48);
			else {
				f = f * 10 + (str[i] - 48);
				nbdecimal *= 10;
			}
			continue;
		}
		if (str[i] == decimal) {
			if (founddecimalpoint)
				return 0;
			founddecimalpoint = true;
			continue;
		}
		return 0;
	}
	if (founddecimalpoint) {
		f = l + (f / nbdecimal);
		return 2;
	}
	return 1;
}

void cr_normalise(string& code) {
	code = s_replacestrings(code, "\r\n", "\n");
	code = s_replacestrings(code, "\r", "\n");
}

char laccolade(string& ligne) {
	int i;
	char trouve = 0;
	int mx = ligne.size();
	unsigned char c;
	bool acc = false;
	for (i = 0; i < mx; i++) {
		c = ligne[i];
		if (c <= 32)
			continue;
		switch (c) {
		case '{':
			acc = true;
			trouve = '{';
			break;
		case '}':
			if (acc)
				return 0;
			return c;
		case ',':
			trouve = ',';
			break;
		case ':':
			if (i + 1 < mx && ligne[i + 1] == '-') { //inference rules
				i++;
				trouve = '-';
				break;
			}
		case ')':
			trouve = ')';
			break;
		case '"':
			if (trouve != '{')
				trouve = 0;
			i++;
			while (i < mx && ligne[i] != '"') {
				if (ligne[i] == '\\')
					i++;
				i++;
			}
			break;
		case '\'':
			if (trouve != '{')
				trouve = 0;
			i++;
			while (i < mx && ligne[i] != '\'')
				i++;
			break;
		case ';':
			if (trouve != '{')
				trouve = 0;
			break;
		case '/':
			if (i < mx - 1 && ligne[i + 1] == '/')
				return trouve;
		default:
			if (trouve != '{')
				trouve = 0;
		}
	}
	if (acc && !trouve)
		return '{';
	return trouve;
}

bool TestChaine(string& s, const char* ch, char fin) {
	bool tr = true;
	int i = 0;
	int ln = strlen(ch);
	if (s.size() < ln)
		return false;
	for (; i < ln; i++) {
		if (s[i] != ch[i])
			return false;
	}
	if (i == s.size() || s[i] <= 32 || s[i] == fin || s[i] == '/')
		return true;
	return false;
}

static int blanksize = 4;
void SetBlankSize(int sz) {
	if (sz >= 1)
		blanksize = sz;
}

int GetBlankSize() {
	return blanksize;
}

void IndentationCode(string& codeindente, vector<string>& code, vector <int>& blancs, int mxbase, bool construit, const char* kifelse, const char* kifelif, const char* kifif) {
	int x, i, compte = 0;
	int mx = mxbase;
	int sz = code.size();
	bool firstcomma = true;
	blancs.reserve(sz);
	for (i = 0; i < sz; i++)
		blancs.push_back(-1);
	int curly = 0;

	vector<int> decalages;
	vector<char> types;
	vector<int> curlies;

	blancs[0] = 0;
	x_readstring xr("");
	for (i = 0; i < sz; i++) {

		if (code[i] == "") {
			if (blancs[i] == -1)
				blancs[i] = blancs[i - 1];
			continue;
		}

		xr.pos = 0;
		xr.parcours = code[i];
		xr.length = xr.parcours.size();
		xr.loadtoken();

		bool toadd = false;
		char lookforif = 0;
		if (xr.stack.size()) {
			if (xr.stack[0] == kifif || xr.stack[0] == kifelif) {
				types.push_back('i');
				toadd = true;
			}
			else {
				if (xr.stack[0] == kifelse) {
					types.push_back('e');
					lookforif = 1;
					toadd = true;
				}
			}

			if (xr.stack.back() == ")") {
				if (!toadd)
					types.push_back(')');
				lookforif = 2;
				toadd = true;
			}
		}

		//If the next element has been predicted and it is not an if or an else
		if (blancs[i] == -1) {
			x = decalages.size() - 1;
			int cpt = 0;
			int shift = blanksize;
			while (x >= 0) {
				if (lookforif == 1 && types[x] == 'i') {
					if (!cpt) {
						shift = 0;
						break;
					}
				}
				if (types[x] == '}')
					cpt++;
				else {
					if (types[x] == '{') {
						if (!cpt)
							break;
						cpt--;
					}
				}
				x--;
			}
			if (x >= 0)
				blancs[i] = decalages[x] + shift;
			else
				blancs[i] = 0;
		}

		if (toadd)
			decalages.push_back(blancs[i]);

		if (!xr.stack.size())
			continue;

		curly = 0;
		for (x = 0; x<xr.stack.size(); x++) {
			if (xr.stack[x] == "{")
				curly++;

			if (xr.stack[x] == "}")
				curly--;
		}

		if (curly >= 1) {
			lookforif = 0;
			while (curly>0) {
				decalages.push_back(blancs[i]);
				types.push_back('{');
				if (i + 1 < sz) {
					curlies.push_back(blancs[i]);
					blancs[i + 1] = blancs[i] + blanksize;
					if (blancs[i + 1] > mx)
						mx = blancs[i + 1];
				}
				curly--;
			}
		}

		if (curly <= -1) {
			while (curly<0) {
				decalages.push_back(-blancs[i]);
				types.push_back('}');
				if (curlies.size()>0) {
					blancs[i] = curlies.back();
					curlies.pop_back();
				}
				curly++;
			}

			if (blancs[i] == 0) {
				decalages.clear();
				types.clear();
				curlies.clear();
			}
		}

		if (xr.stack.back() == "," || xr.stack.back() == "|" || xr.stack.back() == "&") {
			if (i + 1 < sz) {
				if (firstcomma) {
					blancs[i + 1] = blancs[i] + blanksize;
					if (blancs[i + 1] > mx)
						mx = blancs[i + 1];
				}
				else
					blancs[i + 1] = blancs[i];
			}
			firstcomma = false;
			continue;
		}

		if (xr.stack.size() > 1 && xr.stack.back() == "-" && xr.stack[xr.stack.size() - 2] == ":") {
			if (i + 1 < sz) {
				blancs[i + 1] = blancs[i] + blanksize;
				if (blancs[i + 1] > mx)
					mx = blancs[i + 1];
			}
			firstcomma = false;
			continue;
		}

		firstcomma = true;
		if (i + 1 < sz && lookforif) {
			blancs[i + 1] = blancs[i] + blanksize;
			if (blancs[i + 1] > mx)
				mx = blancs[i + 1];
			continue;
		}
	}

	if (construit) {
		mx++;
		char* blanc = new char[mx + 1];
		memset(blanc, ' ', mx);
		blanc[mx] = 0;
		for (i = 0; i < sz; i++) {
			if (code[i].size() == 1 && code[i][0] == '\n') {
				codeindente += "\n";
				continue;
			}
			x = blancs[i];
			if (x == -1)
				x = 0;
			blanc[x] = 0;
			codeindente += blanc;
			blanc[x] = ' ';
			codeindente += code[i];
			codeindente += "\n";
		}
		delete[] blanc;
	}
}

class x_forindent : public x_readstring {
public:
	x_forindent(string& s) : x_readstring(s) {}

	void loadtoken(bool keepspace = false) {
		unsigned char s, c;
		Initable();
		char ch[] = { 0, 0 };
		string token;
		stack.clear();
		stackln.clear();
		stacktype.clear();

		long locpos = Length();

		if (locpos != -1)
			stack.reserve(locpos / 2);
		char decimal = 0;
		bool digit = false;
		bool exposant = false;

		s = get();

		while (!eof()) {
			if (s == '/' && token == "") {
				token = s;
				locpos = tell();
				s = get();
				token += s;
				if (s == '/') {
					//this is a comment
					s = get();
					token += s;
					while (s != 10 && s != 13) {
						if (eof())
							return;
						s = get();
						token += s;
					}
					stack.push_back(token);
					token = "";
					continue;
				}

				if (s == '@') {
					//this is a long comment up to */
					while (1) {
						if (eof())
							return;
						s = get();
						token += s;
						if (s == '@') {
							s = get();
							token += s;
							if (s == '/')
								break;
						}
					}
					stack.push_back(token);
					token.clear();
					s = get();
					continue;
				}
				token = "";
				seek(locpos);
				s = '/';
			}

			c = s;
			if (token == "" && readstrings) {
				if (c == '@') {
					locpos = tell();
					s = get();
					if (s == '"') {
						token += "@";
						token += s;
						c = get();
						while (!eof()) {
							token += c;
							bool fd = false;
							if (c == '"')
								fd = true;
							c = get();
							if (fd && c == '@')
								break;
						}
						token += c;
						stack.push_back(token);
						token.clear();
						s = get();

						continue;
					}
					seek(locpos);
				}
				else {
					if (c == '"') {
						token += c;
						c = get();
						while (c != '"' && !eof()) {
							if (c == '\\') {
								token += c;
								c = get();
							}
							token += c;
							c = get();
						}
						token += '"';
						stack.push_back(token);
						token.clear();
						s = get();

						continue;
					}
					if (c == '\'') {
						token += c;
						c = get();
						while (c != '\'' && !eof()) {
							token += c;
							c = get();
						}
						token += "'";
						stack.push_back(token);
						token.clear();
						s = get();

						continue;
					}
				}
			}
			if (strchr((char*)table, c)) {
				token += c;
				if (c == 'e' && decimal)
					exposant = true;
			}
			else {
				bool normaltoken = true;
				if (digit) {
					switch (c) {
					case 48:
					case 49:
					case 50:
					case 51:
					case 52:
					case 53:
					case 54:
					case 55:
					case 56:
					case 57:
						token += c;
						normaltoken = false;
						if (decimal)
							decimal = 2;
						break;
					case '.':
						if (!decimal) {
							token += c;
							decimal = 1;
							normaltoken = false;
						}
						break;
					case '+':
					case '-':
						if (exposant) {
							token += c;
							normaltoken = false;
						}
					}
				}
				else {
					if (c >= 48 && c <= 57) {
						normaltoken = false;
						if (token == "")
							digit = true;
						token += c;
					}
				}

				if (normaltoken) {
					if (token != "") {
						if (digit) {
							if (decimal == 1)
								token = token.substr(0, token.size() - 1);
							stack.push_back(token);
							if (decimal == 1) {
								ch[0] = '.';
								stack.push_back(ch);
							}
						}
						else {
							stack.push_back(token);
						}
						token.clear();
						digit = false;
						exposant = false;
						decimal = false;
					}
					ch[0] = c;
					stack.push_back(ch);
				}
			}
			s = get();
		}

		if (token != "")
			stack.push_back(token);
	}

};

void v_split_indent(string& thestr, vector<string>& v) {
	string value;

	x_forindent xr(thestr);
	xr.loadtoken(true);

	for (int i = 0; i < xr.stack.size(); i++) {
		if (xr.stack[i] == "\n") {
			if (value == "")
				v.push_back("\n");
			else
				v.push_back(Trim(value));
			value = "";
		}
		else
			value += xr.stack[i];
	}

	Trim(value);
	if (value != "")
		v.push_back(value);
	else
		v.push_back("\n");
}

void IndentCode(string& codestr, string& codeindente, int blancs, const char* kifelse, const char* kifelif, const char* kifif) {
	vector<string> vargs;
	vector <int> iblancs;
	cr_normalise(codestr);
	v_split_indent(codestr, vargs);
	codeindente = "";
	IndentationCode(codeindente, vargs, iblancs, blancs, true, kifelse, kifelif, kifif);
	if (codeindente.find("/@") != string::npos || codeindente.find("@\"") != string::npos)
		cr_normalise(codeindente);

	Trimright(codeindente);
	codeindente += "\n";
}

int VirtualIndentation(string& codestr, const char* kifelse, const char* kifelif, const char* kifif) {
	vector <int> iblancs;
	vector<string> vargs;
	v_split_indent(codestr, vargs);
	codestr.clear();
	IndentationCode(codestr, vargs, iblancs, 0, false, kifelse, kifelif, kifif);
	if (iblancs.size() == 0)
		return 0;
	return iblancs.back();
}

