/*
 * Xerox Research Centre Europe - Grenoble Laboratory
 *
 * Copyright (C) 2003 - 2010 Xerox Corporation, XRCE-Grenoble, All Rights Reserved.
 * This file can only be used with the XIP library, 
 * it should not and cannot be used otherwise.
 */
/* --- CONTENTS ---
   Project    : XIP
   Version    : 10.00
   filename   : kif.h
   Date       : 09/09/2010
   Purpose    : Implementation of the KiF language
   Programmer : Claude ROUX
   Reviewer   : 
*/


#ifndef i_kif
#define i_kif

#define KIFVERSION "1.00 build 92"

#include <ostream>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <list>
#include <vector>
#include <map>
#include <locale>
#ifdef KIF_HASH_MAP
#ifdef WIN32
#include <unordered_map>
#define hmap unordered_map
#define Rend()	rend()
#define Rbegin()	rbegin()
#else
#include <tr1/unordered_map>
#define hmap tr1::unordered_map
#define Rend()	end()
#define Rbegin()	begin()
#endif
#else
#define hmap map
#define Rend()	rend()
#define Rbegin()	rbegin()
#endif

#ifdef KIF_REGEX
#ifdef WIN32 
#include <regex>
#else
#include <boost/regex.hpp>
#endif
#endif

using namespace std;
#ifdef KIF_REGEX
#ifdef WIN32
using namespace std::tr1;
#else
using namespace boost;
#endif
#endif


#ifdef WIN32
#define threadhandle DWORD
#define KIFLONG unsigned __int64
#else
#include <pthread.h>
#include <semaphore.h>
#define threadhandle pthread_t
#define KIFLONG unsigned long long
#endif

#include "xipvecta.h"
#include "conversion.h"

#define ckifInteger 1
#define ckifFloat 2
#define ckifString 3
#define ckifInstance 4
#define ckifInstruction 5

#define kifNoOwner -2
#define kifStringOwner 1
#define kifIntegerOwner 2
#define kifFloatOwner 4
#define kifVectorOwner 8
#define kifListOwner 16
#define kifMapOwner 32
#define kifGarbageOwner 64

Exported short KifNewId(string n);

Exported extern short idsequence;
Exported extern short idcatch;

typedef double (*mathFunc)(double);


class KifDomain;
class KifString;
class KifInteger;
class KifFloat;
class KifChild;
class KifNumber;
class KifRoot;
class KifVector;
class KifMap;
class KifList;
class KifElement;
class KifFunction;
class KifCallFunction;
class KifPredefined;
class x_node;
class x_reading;
class KifCallMethod;
class KifVariable;
class KifTree;
class TestFonctionXML;
class VariableXML;
class KifXipRule;
class VectTestFonction;
class KifVariableDeclaration;
class KifDomainInstruction;
//We define the basic KIF element, which is KifObject
class KifCode;
class KifError;
class KifBoolean;
class KifObject;
class KifFrame;
class KifFraction;
class bnf_kif;

#ifdef WIN32
#define Exported __declspec(dllexport)
#define Imported __declspec(dllimport)
#include <WinSock.h>
#else
#define Exported
#define Imported
#endif

typedef KifElement* (*Predefined)(KifElement*,KifDomain*,KifCallFunction*);
//Needed to use external libraries
typedef KifElement* (*KifExternalParse)(KifCode*,x_node*,KifElement*);
typedef bool (*KifExternalModule)(KifCode*,string);

class KifRaiseError {
public:

	string message;
	string filename;
	long left;
	long right;

	KifRaiseError(string mes,string file="",long l=0,long r=0);
};

typedef enum {kifVOID,kifnull,kifthis,kifAny,kifBaseString,kifStringPtr,kifString,kifInteger,kifFloat,kifBoolean,kifFraction,
	kifCouple,kifDomain,kifRootString,kifRootInteger,kifRootFloat, kifLoquet,kifLoquetThread,
	kifVariableDeclaration,kifFrameDeclaration,kifFunctionDeclaration,
	kifFile,kifIndex,kifPredefined,kifSelf,kifXipRule,
	kifFrame,kifSubframe,kifMap,kifList,kifVector,kifIterator,
	kifVariable,kifError,kifIteration,kifCall,kifDate,kifTime,kifMatrix,
	kifCallMethod,kifLOOPITERATOR,kifKiF,kifTree,kifGarbage,kifTemporary,kifThreading,kifSignal,kifStack,kifThreadId,kifInputchr,
	kifInstruction,kifInstructionPARAMETER,kifInstructionIF,kifInstructionSWITCH,kifInstructionTRY,kifInstructionWHILE,
	kifInstructionFOR,kifInstructionSEQUENCE,kifXPathExpression,kifInstanceFunction,
	kifCallFunction,kifCallFunctionBCR,kifCallExecuteThreadExternal,kifCallFunctionExternal,kifCallExecuteThreadPredefined,kifCallFunctionPredefined,
	kifCallExecuteThread,kifCallFunctionThread,kifCallFunctionCall,kifCallFunctionGeneral,kifInstance,
	kifFunction,kifPolynomial,kifThread,kifLASTYPE} KifType;

//typedef enum  {kifNOTYPE,kifEQU,kifFULLINTEGER,kifFULLFLOAT,kifFULLSTRING} KifInstructionType;
#define kifNOTYPE 0
#define kifEQU 1
#define kifFULLINTEGER 2
#define kifFULLFLOAT 3
#define kifFULLSTRING 4
#define KifInstructionType char

//typedef enum {kinUnknown,kinKnown,kinFrame,kinKnownFrame,kinFunction,kinGlobal} KifOrigin;
#define kinUnknown 0
#define kinKnown 1
#define kinFrame 2
#define kinKnownFrame 3
#define kinFunction 4
#define kinGlobal 5
#define kinGlobalValue 6
#define KifOrigin char

typedef enum  {
	kifNONE,
	kifINITIALISATION,

	kifAFFECTATION,
	kifPLUSEQU,
	kifMINUSEQU,
	kifMULTIPLYEQU,
	kifDIVIDEEQU,
	kifMODEQU,
	kifPOWEREQU,
	kifSHIFTLEFTEQU,
	kifSHIFTRIGHTEQU,
	kifUNIONEQU,
	kifXOREQU,
	kifINTERSECTIONEQU,	

	kifEQUAL,
	kifSUPERIOR,
	kifINFERIOR,
	kifSUPEQU,
	kifINFEQU,
	kifDIFFERENT,

	kifPLUS,
	kifMINUS,
	kifMULTIPLY,
	kifDIVIDE,
	kifMOD,
	kifPOWER,
	kifSHIFTLEFT,
	kifSHIFTRIGHT,
	kifUNION,
	kifXOR,
	kifINTERSECTION,

	kifPLUSPLUS,
	kifMINUSMINUS,

	kifIN,
	kifNOTIN,

	
	kifBLOC,
	kifBLOCLOOPIN,
	kifFILEIN,
	kifBLOCBOOLEAN,
	kifPARAMETER,
	kifSEQUENCE,
	kifOR,
	kifAND,
	kifIF,
	kifTRY,
	kifSWITCH,
	kifWHILE,
	kifFOR,
	kifCATCHBLOC,
	kifLASTDECLARATION
} KifOperator;




//Very specific case, if you link a KiF library extension with the XIP dll
#ifdef KIF_DLL
Imported extern KifElement* kifNULL;
Imported extern KifElement* kifTRUE;
Imported extern KifElement* kifFALSE;
Imported extern KifElement* kifMINUSONE;
Imported extern KifElement* kifDEFAULT;
Imported extern KifElement* kifBREAK;
Imported extern KifElement* kifBREAKPOINT;
Imported extern KifElement* kifCONTINUE;
Imported extern KifElement* kifNEG;
Imported extern short idthis;
Imported extern short idsize;

Imported extern short idstring;
Imported extern short idfloat;
Imported extern short idint;
Imported extern short idboolean;
Imported extern short idfraction;

Imported extern short idinferior;
Imported extern short idsuperior;
Imported extern short idequal;
Imported extern short iddifferent;
Imported extern short idinferiorequal;
Imported extern short idsuperiorequal;
Imported extern short idmethods;
Imported extern short idvector;
Imported extern short idmap;

Imported short idorset;
Imported short idxorset;
Imported short idandset;
Imported short idplusplus;
Imported short idminusminus;
Imported short idplus;
Imported short idminus;
Imported short idmultiply;
Imported short iddivide;
Imported short idpower;
Imported short idshiftleft;
Imported short idshiftright;
Imported short idmod;
Imported short idinterval;
Imported short idindex;


#else
Exported extern KifElement* kifNULL;
Exported extern KifElement* kifTRUE;
Exported extern KifElement* kifFALSE;
Exported extern KifElement* kifMINUSONE;
Exported extern KifElement* kifDEFAULT;
Exported extern KifElement* kifBREAK;
Exported extern KifElement* kifBREAKPOINT;
Exported extern KifElement* kifCONTINUE;
Exported extern KifElement* kifNEG;
Exported extern short idthis;
Exported extern short idsize;

Exported extern short idstring;
Exported extern short idfloat;
Exported extern short idint;
Exported extern short idboolean;
Exported extern short idfraction;

Exported extern short idinferior;
Exported extern short idsuperior;
Exported extern short idequal;
Exported extern short iddifferent;
Exported extern short idinferiorequal;
Exported extern short idsuperiorequal;
Exported extern short idmethods;
Exported extern short idvector;
Exported extern short idmap;

Exported extern short idorset;
Exported extern short idxorset;
Exported extern short idandset;
Exported extern short idplusplus;
Exported extern short idminusminus;
Exported extern short idplus;
Exported extern short idminus;
Exported extern short idmultiply;
Exported extern short iddivide;
Exported extern short idpower;
Exported extern short idshiftleft;
Exported extern short idshiftright;
Exported extern short idmod;

Exported extern short idinterval;
Exported extern short idindex;

#endif


//------------------------------------------------------------------------------------------
#ifdef WIN32
class ThreadLock {
public:
	int relax;
	Exported static HANDLE table[100];

	Exported void Initialise();
	Exported ThreadLock(KifType i);

	Exported static void Clean();

	Exported ~ThreadLock();
};

#define kifmutex(x) static HANDLE x
#define KifCreateMutex(x) x=CreateMutex(NULL,FALSE,NULL)
#define KifDeleteMutex(x) CloseHandle(x)

class KifThreadLock {
public:
	HANDLE lock;
	bool locked;
	Exported KifThreadLock(HANDLE l,bool run=true);
	Exported void Locking();
	Exported void Unlocking();
	Exported ~KifThreadLock();
};

class LockedThread {
public:
	HANDLE lock;
	bool blocked;
	Exported LockedThread();
	Exported ~LockedThread();
	Exported void Blocked();
	Exported void Released();
};


#else
class ThreadLock {
public:

	static pthread_mutex_t table[100];
	int relax;
	Exported void Initialise();
	ThreadLock(KifType i);
	static void Clean() {}
	~ThreadLock();
};

void KifInitialisationMutex(pthread_mutex_t* mut);
#define kifmutex(x) pthread_mutex_t _x; pthread_mutex_t* x=&_x
#define KifCreateMutex(x) KifInitialisationMutex(x)
#define KifDeleteMutex(x)

class KifThreadLock {
public:
	pthread_mutex_t* lock;
	bool locked;
	Exported KifThreadLock(pthread_mutex_t* l,bool run=true);
	Exported void Locking();
	Exported void Unlocking();
	Exported ~KifThreadLock();
};

#ifdef APPLE
class LockedThread {
public:
	static int naming;
	char name[10];
	sem_t* lock;
	bool blocked;

	Exported LockedThread();
	Exported ~LockedThread();
	Exported void Blocked();
	Exported void Released();
};
#else
class LockedThread {
public:
	sem_t lock;
	bool blocked;

	Exported LockedThread();
	Exported ~LockedThread();
	Exported void Blocked();
	Exported void Released();
};
#endif
#endif
//------------------------------------------------------------------------------------------
class KifWaitState {
public:
	LockedThread* loquet;
	string lastcast;
	bool killed;
	KifWaitState() {
		loquet=NULL;
		killed=false;
	}

	virtual bool multiple() {
		return false;
	}
	virtual ~KifWaitState() {}
};


class KifWaitStates : public KifWaitState {
public:
	vector<string> flags;
	KifCode* kifcode;

	KifWaitStates(KifCode* kcode) : KifWaitState() {
		kifcode=kcode;
	}

	bool multiple() {
		return true;
	}
	
	~KifWaitStates();	
};

//------------------------------------------------------------------------------------------
class KifCode {
public:	
	x_reading* current;
	bool prive;
	bool common;
	bool compile;
	long current_start;
	long current_end;
	KifFrame* kstart;
	short idkifmain;
	ostream* os;
	int basegarbage;
	void* data;
	KifFunction* kcallsyncronous;
	VECTA<KifElement*> garbage;
	int cursor;
	int cursormax;
	hmap<short,bool> kifAllTypes;
	hmap<short,bool> kifDeclaredFunction;
	int insidecall;
	KifError* errorptr;
	bool error;
	long currentline;
	bool debugging;
	bool debug;
	bool infunction;
	int breakpoint;
	vector<string> watches;
	bnf_kif* bnfkif;
	long linereference;
	long gotoline;
	int trigger;
	bool utf8;	
	vector<string> lwidestring;
	char buffer[4096];
	hmap<string,KifThreadLock*> locktables;
	hmap<long,long> tabledebugline;
	map<long,string> tabledebugfilename;
	map<long,string> tabledebug;
	hmap<short,KifPredefined*> kifBaseFunctions;
	hmap<short,KifPredefined*> kifBaseTreeFunctions;
	vector<string> arguments;
	
	vector<KifString*> stringlist;
	int cursorstring;
	int sizestring;
	Exported KifString* Providestring(string& z);
	Exported KifString* Providestringraw(string z);

	vector<KifInteger*> integerlist;
	int cursorinteger;
	int sizeinteger;
	Exported KifInteger* Provideinteger(long val);

	vector<KifFloat*> floatlist;
	int cursorfloat;
	int sizefloat;
	Exported KifFloat* Providefloat(double val);

	vector<KifVector*> vectorlist;
	int cursorvector;
	int sizevector;
	Exported KifVector* Providevector();

	vector<KifMap*> maplist;
	int cursormap;
	int sizemap;
	Exported KifMap* Providemap();

	vector<KifList*> listlist;
	int cursorlist;
	int sizelist;
	Exported KifList* Providelist();

	Exported void Setbaseline(int i);
	Exported int Setthreadid(int);
	Exported void Setutf8(bool encoding);

	KifElement* Provide(KifType ktype);
	vector<bool> operations;
	vector<bool> operationboolean;

	KifFunction* garbagefunction;
	hmap<string,short>* kkifStringId;
	hmap<short,string>* kkifIdString;
	map<int,LockedThread*> loquets;
	KifElement* kkifNULL;
	KifElement* kkifTRUE;
	KifElement* kkifFALSE;
	KifElement* kkifMINUSONE;
	KifElement* kkifDEFAULT;
	KifElement* kkifBREAK;
	KifElement* kkifBREAKPOINT;
	KifElement* kkifCONTINUE;
	KifElement* kkifNEG;
	
	KifElement* kifTypeSTRING;
	KifElement* kifTypeINTEGER;
	KifElement* kifTypeFLOAT;
	KifElement* kifTypeBOOLEAN;

	KifElement* current_wait;
	bool current_wait_all;
	int* kkifLastType;
	vector<string> history;
	map<KifType,string>* kkifStringType;
	map<string,KifExternalParse> kifExternalTypes;
	map<string,vector<KifWaitState*> > kifWaitstates;

	void Setdebug(bool d) {
		debugging=d;
		debug=d;
		infunction=false;
	}
	void Gets();
	
	map<threadhandle,int> threads;
	vector<KifDomain*> stacking;
	hmap<int,vector<KifDomain*> > threadstacks;
	int threadalloc;
	bool nogarbage;

	VECTA<KifCode*>* kifsvector;
	Exported void KifInitLib();
	Exported bool Trigger();

	Exported KifVariableDeclaration* Createvariable(string name);
	Exported long GetCurrentLine(int inc,x_node*);

	Exported vector<KifWaitState*>* Freestate(string& flag);
	Exported void Setloader(KifCode* k);
	Exported void ObjectInitialisation(int);

	KifElement* KifParseXipRule(x_node* xn,KifElement* kf);
	KifElement* KifParseXPath(x_node* xn,KifElement* kf);

	Exported KifElement* EvaluateVector(KifElement*,string s);
	Exported KifElement* EvaluateMap(KifElement*,string s);
	Exported KifType KifAddNewType(string name,KifExternalParse func);
	Exported KifType KifNewType();
	bool KifLoadModule(x_node* xn ,string name);
	bool KifConversion(string n);
	Exported void SetArguments(vector<string>& args);
	KifElement* KifParseVarKifKiF(x_node* xn ,KifElement* kf);
	KifElement* KifBaseFunctionTest(short name);
	bool KifDeclaredFunctionTest(short name);
	bool KifCreatePredefined(string name,Predefined func,bool tree=false);
	Exported KifElement* KifInitVariable(x_node* xn ,KifElement* base);
	Exported KifElement* KifTerminateVariable(x_node* xn,KifElement* local,KifElement* variable,KifElement* base);
	KifElement* KifParseDico(x_node* xn,KifElement* kf);
	KifElement* KifParseList(x_node* xn ,KifElement* kf);
	KifElement* KifParseValVector(x_node* xn ,KifElement* kf);
	KifElement* KifParseValList(x_node* xn ,KifElement* kf);
	KifElement* KifParsePlusPlus(x_node* xn ,KifElement* kf);
	KifElement* KifParseValMap(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarFrame(x_node* xn ,KifElement* kf);
	KifElement* KifParseAString(x_node* xn ,KifElement* kf);
	KifElement* KifParseANumber(x_node* xn ,KifElement* kf);
	KifElement* KifParseOperation(x_node* xn ,KifElement* kf);
	KifElement* KifParseOperationIn(x_node* xn ,KifElement* kf);
	KifElement* KifParseOperator(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarSelf(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarDate(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarTime(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarInt(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarFraction(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarCall(x_node* xn ,KifElement* kf);
	KifElement* KifParseSubFunc(x_node* xn ,KifElement* kf);
	KifElement* KifParseSubVar(x_node* xn ,KifElement* kf);
	KifElement* KifParseIncrement(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarString(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarFloat(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarVector(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarList(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarMap(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarMatrix(x_node* xn ,KifElement* kf);
	KifElement* KifParseComparison(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarBoolean(x_node* xn ,KifElement* kf);
	KifElement* KifParseVarFile(x_node* xn ,KifElement* kf);
	KifElement* KifParseVariable(x_node* xn ,KifElement* kf);
	KifElement* KifParseDeclaration(x_node* xn,KifElement* kf);
	KifElement* KifParseMultiDeclaration(x_node* xn,KifElement* kf);
	KifElement* KifParseIndexes(x_node* xn,KifElement* kf);
	KifElement* KifParseInterval(x_node* xn,KifElement* kf);
	KifElement* KifParseCall(x_node* xn,KifElement* kf);
	KifElement* KifNonLimited(x_node* xn,KifElement* kf);
	KifElement* KifParseUniqueCall(x_node* xn,KifElement* kf);
	KifElement* KifParseBloc(x_node* xn,KifElement* kf);
	KifElement* KifParseTryCatch(x_node* xn,KifElement* kf);
	KifElement* KifParseTest(x_node* xn,KifElement* kf);
	KifElement* KifParseWhile(x_node* xn,KifElement* kf);
	KifElement* KifParseFor(x_node* xn,KifElement* kf);
	KifElement* KifParseBoolean(x_node* xn,KifElement* kf);
	KifElement* KifParseABoolean(x_node* xn,KifElement* kf);
	KifElement* KifParseVarTree(x_node* xn,KifElement* kf);
	KifElement* KifParseVarIterator(x_node* xn,KifElement* kf);
	KifElement* KifParseVarRIterator(x_node* xn,KifElement* kf);
	KifElement* KifParseNegation(x_node* xn,KifElement* kf);
	KifElement* KifParseSwitch(x_node* xn,KifElement* kf);
	KifElement* KifParseTestSwitch(x_node* xn,KifElement* kf);
	void ComputeParameters(x_node* xn,KifCallFunction* kcf);
	//Function creation
	KifElement* KifParseFunction(x_node* xn,KifElement* kf);	
	KifElement* KifParseAffectation(x_node* xn,KifElement* kf);
	KifElement* KifParseFrame(x_node* frame,KifElement* kf);
	KifElement* CreateVariable(x_node* xn,short name,KifElement* kf,KifInstructionType instype);
	KifElement* KifBrowse(x_node* xn,KifElement* kf);
	Exported void Loadfile(string filename,KifCode* loader=NULL);
	Exported void Loadfile(ifstream* fichier,string filename,long pos,KifCode* loader=NULL);
	Exported KifElement* Evaluate(KifElement*,string,bool commandline);
	KifElement* FindFrameForSequence(KifElement* ktop,x_node* xn,short);

	Exported KifCode(int trig,bool encoding=false,void* d=NULL,ostream* o=NULL);
	bool Debugging(KifObject* func,KifElement* ke,KifDomain* dom,KifCallFunction*);

	hmap<int,unsigned char> used;
	void Used(int id,unsigned char x) {
		ThreadLock _lock(kifThreadId);
		if (id!=-1)
			used[id]|=x;
	}

	Exported void RemoveThreadidReference(int idthread);
	Exported KifElement* Returnerror(string message);
	int GetThreadid();
	void SetThreadid(threadhandle tid,int thid);
	void EraseThreadid(threadhandle tid);

	Exported void Push(KifDomain* ke) {	
		ThreadLock _lock(kifStack);
		int id=GetThreadid();
		if (id==-1) 
			stacking.push_back(ke);
		else 
			threadstacks[id].push_back(ke);
	}

	Exported bool Pushlocal(KifDomain* ke) {
		ThreadLock _lock(kifStack);
		int id=GetThreadid();

		if (id==-1) {
			if (ke==(KifDomain*)kstart && stacking.size()!=0)
				return false;
			stacking.push_back(ke);
		}
		else {
			if (ke==(KifDomain*)kstart && threadstacks[id].size()!=0)
				return false;
			threadstacks[id].push_back(ke);
		}
		return true;
	}

	inline void Pop() {
		ThreadLock _lock(kifStack);
		int id=GetThreadid();
		if (id==-1) {
			if (stacking.size()>0)
				stacking.pop_back();
		}
		else {
			if (threadstacks[id].size()>0)
				threadstacks[id].pop_back();
		}
	}

	KifDomain* Top() {
		ThreadLock _lock(kifStack);
		int id=GetThreadid();

		if (id==-1) {
			if (stacking.size()==0)
				return NULL;
			return stacking[stacking.size()-1];
		}
		int sz=threadstacks[id].size();
		if (sz==0)
			return NULL;
		
		return threadstacks[id][sz-1];
	}

	inline KifDomain* Beforetop() {
		ThreadLock _lock(kifStack);
		int id=GetThreadid();
		if (id==-1) {
			if (stacking.size()<=1)
				return NULL;
			return stacking[stacking.size()-2];
		}

		if (threadstacks[id].size()<=1)
			return NULL;
		int sz=threadstacks[id].size();
		return threadstacks[id][sz-2];
	}



	Exported KifElement* Get(short n,KifDomain* dom);
	Exported KifElement* Getbasic(short n,KifElement*);
	KifElement* Getframe(short n,KifElement* dom);

	void Load(x_reading* xr);
	Exported void Run(int from=7);
	Exported KifElement* Execute(KifFunction*,vector<KifElement*>& paramaters);
	KifElement* Search(string name);
	KifElement* Searchraw(string name);
	void FinalGarbage();

	void garbage_initialisation();

	Exported int Add(KifElement*);
	Exported void garbage_collector(bool force,int from);
	Exported void Garbage();

	void garbage_xip();
	void garbage_xml();
	Exported void Clean();

	Exported ~KifCode();
};
//------------------------------------------------------------------------------------------
extern Exported VECTA<KifCode*> kifCodeVector;
//------------------------------------------------------------------------------------------

class KifElement {
public:
	KifCode* kifcode;
	short reference;
	KifType type;	
	int idgarbage;
	int threadowner;
	bool popped;

	KifElement(KifCode* klc,KifElement* kp,KifType k=kifAny) {
		type=k;
		idgarbage=-1;
		popped=false;
		threadowner=kifNoOwner;
		if (klc!=NULL)
			idgarbage=klc->Add(this);
		kifcode=klc;
		reference=0;		
		if (kp!=NULL)
			kp->Add(this);
	}
	
	virtual Exported KifElement* Declaration(short s) {
		return NULL;
	}
	virtual Exported void Setdeclaration(short n,KifElement*,hmap<short,KifElement*>* stacks) {}	
	virtual Exported void Resetdeclaration(hmap<short,KifElement*>& stacks) {}
	bool Error() {
		return false;
	}

	virtual bool Simple() {
		return false;
	}

	short Returnowner() {
		return threadowner;
	}

	virtual Exported void callfunction(KifElement* a,KifElement* b,KifDomain* dom) {}
	virtual bool Basic() {
		return false;
	}
	
	virtual KifFunction* Functioncall(KifDomain*) {
		return NULL;
	}
	
	virtual void Setlocalvariable() {}
	
	virtual bool Localvariable() {
		return false;
	}
	
	virtual Exported string Type();

	virtual Exported KifType inType() {
		return type;
	}
	
	virtual Exported int Depth() {
		return -1;
	}
	virtual Exported void Setreference() {
		reference++;
	}

	virtual Exported void Setpopped() {
		popped=true;
	}

	virtual bool Predeclared() {
		return false;
	}

	virtual bool isFunction() {
		return false;
	}
	
	virtual bool isUsed() {
		return true;
	}
	
	virtual void Setused() {}

	virtual void Addfunction(KifFunction* kfunc) {}
	virtual bool Subframe(KifFrame*) {
		return false;
	}

	virtual Exported void Resetreference() {
		reference--;
		if (reference<=0) {
			if (popped)
				popped=false;
			else {				
				if (idgarbage!=-1) {
					ThreadLock* _lock=new ThreadLock(kifGarbage);
					kifcode->garbage.affecte(idgarbage,NULL);
					if (idgarbage<kifcode->cursor)
						kifcode->cursor=idgarbage;
					delete _lock;
					delete this;
				}
			}
		}
	}

	virtual Exported void Clean() {
		reference--;
		if (reference<=0) {
			if (idgarbage!=-1) {
				ThreadLock* _lock=new ThreadLock(kifGarbage);
				kifcode->garbage.affecte(idgarbage,NULL);
				if (idgarbage<kifcode->cursor)
					kifcode->cursor=idgarbage;
				delete _lock;
				delete this;
			}
		}
	}

	
	virtual Exported void Clear() {}



	virtual Exported KifElement* Next() {
		return kifNULL;
	}

	virtual Exported KifElement* End() {
		return kifTRUE;
	}

	virtual KifElement* Initialisation() {
		return kifNULL;
	}

	virtual void Setselfinsert(bool) {};

	virtual int InstructionSize() {
		return 0;
	}
	virtual void Setnegation(bool v) {}

	virtual Exported int Threadid() {
		return -1;
	}

	virtual Exported int Parentthreadid() {
		return -1;
	}
	
	virtual Exported bool Unlimited() {
		return false;
	}

	virtual Exported void Setlimited(bool l) {}
	

	virtual KifElement* Instruction(int i) {
		return kifNULL;
	}
	
	virtual KifElement* InstructionRemoveLast() {
		return kifNULL;
	}

	virtual KifElement* Lastinstruction() {
		return kifNULL;
	}

	virtual string Keyvalue() {return "";}
	virtual void Setstringvalue(string& k) {}

	virtual bool Autorun() {
		return false;
	}

	virtual void Addinstruction(int i,KifElement* ke) {}
	virtual void InstructionClear() {}

	virtual Exported KifElement* Begin() {
		return kifNULL;
	}

	virtual Exported KifElement* IteratorKey() {
		return kifNULL;
	}

	virtual Exported KifElement* IteratorValue() {
		return kifNULL;
	}

	virtual Exported long Size() {return 0;}
	
	virtual KifElement* Parent() { 
		return kifNULL;
	}

	virtual void Addparent(KifElement* p) {}

	//------------------------TREE---------------------------------
	virtual Exported KifElement* TreeChild() {
		return kifNULL;
	}

	virtual Exported KifElement* TreePrevious() {
		return kifNULL;
	}

	virtual Exported KifElement* TreeParent() {
		return kifNULL;
	}
	virtual Exported KifElement* TreeLast() {
		return kifNULL;
	}
	virtual Exported KifElement* TreeNext() {
		return kifNULL;
	}

	virtual Exported KifElement* TreeAddchild(KifTree* t) {
		return kifFALSE;
	}
	virtual Exported KifElement* TreeAddnext(KifTree* t) {
		return kifFALSE;
	}
	virtual Exported KifElement* TreeAddprevious(KifTree* t) {
		return kifFALSE;
	}
	virtual Exported KifElement* TreeRemove() {
		return kifFALSE;
	}
	
	Exported KifElement* TreeExtract(KifTree* with) {
		return kifNULL;
	}
	
	virtual Exported bool Private() {
		return false;
	}
	virtual void Setprivate(bool v) {}

	virtual Exported KifElement* TreeValue() {return kifNULL;}
	virtual KifChild* BuildNumericalExpression(char) {
		return NULL;
	}

	//--------------END TREE---------------------------------

	virtual Exported KifElement* Pop(KifElement* ke) {return kifNULL;}
	virtual Exported KifElement* Argument(int i) {return NULL;}
	virtual Exported void Save(string& filename,string& ty) {}
	virtual Exported KifElement* Last() {return kifNULL;}
	virtual Exported KifElement* First() {return kifNULL;}
	virtual Exported void Push(KifElement*) {}
	virtual Exported void Add(KifElement*) {}
	virtual KifElement* Values(string s) {return kifNULL;}
	virtual KifElement* ValueOnIndex(size_t i) {return kifNULL;};
	virtual bool Predefinedtype() {return false;}
	virtual void Toassign(bool v) {}
	virtual bool Assigning(KifType ty) {return false;}
	virtual void Setfunction(KifElement* f) {}
	virtual KifElement* Returnfunction() {return NULL;}
	virtual void CleanXIP() {}
	virtual void CleanXML() {}
	virtual long Line() {return -1;}
	virtual void Setline(long l) {}
	virtual bool Function() {return false;}
	virtual Exported void Methods(KifVector* fcts) {}
	virtual Exported KifElement* Information(KifElement*) {
		return kifNULL;
	}
	virtual bool Variable() {return false;}
	virtual bool XIP() {return false;}
	virtual Exported KifElement* applyinitial(KifDomain*,KifElement*) {return kifNULL;}
	virtual Exported bool initialapplyied() {return false;}
	virtual Exported KifElement* Newinstance() {return NULL;}
	virtual Exported KifElement* Newiterator(bool rev) {return kifNULL;}
	virtual KifElement* Returnvalue() {return this;}
	virtual Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false) {return kifNULL;}
	virtual Exported void Set(short s,KifElement* k,hmap<short,KifElement*>* stacks) {}
	virtual void Setinitialisation(KifElement* ke) {};
	virtual Exported KifElement* Copy(KifDomain*,KifElement* dom=kifNULL) {return kifNULL;}
	virtual Exported KifElement* Atom() {return this;}
	virtual bool isDomain() {return false;}
	virtual Exported short Name() {return -1;}
	virtual Exported KifElement*  Linkedvalue() {return kifNULL;}
	virtual KifElement*  Frame() {return kifNULL;}
	virtual void  Setframe(KifElement* fr) {}
	virtual void Disableadding() {}
	virtual Exported string String() {return "";}
	virtual Exported long Integer() {return 0;}
	virtual Exported double Float() {return 0;}
	virtual Exported KifFraction* Fraction();
	virtual Exported bool Boolean() {return false;}
	virtual Exported KifElement* Vector(KifElement*) {
		return kifNULL;
	}
	virtual Exported KifElement* Map(KifElement*) {
		return kifNULL;
	}

	virtual Exported bool Setvalue(KifElement* k,KifElement* index=NULL,KifElement* dom=NULL) {
		return true;
	}
	virtual void Initvalue(KifElement* k) {}
	virtual void Setreturnvalue(KifElement* k) {}
	virtual Exported void Sharedeclaration(KifDomain* k) {}
	virtual Exported void SetInstances(KifElement* dom,hmap<short,KifElement*>* stacks) {}
	virtual void* Node() {return NULL;}

	virtual void Setpostpone(bool v) {}
	virtual bool Postpone() {return false;}
	virtual short Delayed() {return false;}
	virtual void Setdelayed() {}
	virtual void ApplyDelayedInitial() {}

	Exported KifElement* applyfunc(KifElement* a,KifElement* b,KifDomain* kfunc);
	Exported KifElement* applyfuncvariable(KifVariable*,KifElement* a,KifElement* b,KifDomain* kfunc);
	Exported KifElement* applyfuncinframe(KifVariable*,KifElement* dom,KifElement* a,KifElement* b,KifDomain* kfunc);

	virtual Exported KifElement* Euclidian() {
		return kifNULL;
	}

	virtual Exported KifElement* FractionSimplify(bool) {
		return this;
	}

	virtual Exported KIFLONG D() {
		return 1;
	}

	virtual Exported KIFLONG N() {
		return Integer();
	}

	virtual Exported void ND(KIFLONG n,KIFLONG d) {
		double f=(double)n/(double)d;
		Setvalue((KifElement*)kifcode->Providefloat(f));
	}

	virtual Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
		return kifNULL;
	}

	virtual Exported KifElement* orset(KifElement* a,KifElement* b,bool autoself) {
		return kifNULL;
	}
	virtual Exported KifElement* xorset(KifElement* a,KifElement* b,bool autoself) {
		return kifNULL;
	}
	virtual Exported KifElement* andset(KifElement* a,KifElement* b,bool autoself) {
		return kifNULL;
	}
	
	Exported virtual void plusplus() {}
	Exported virtual void minusminus() {}

	virtual Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself) {
		return kifNULL;
	}
	virtual Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself) {
		return kifNULL;
	}
	virtual Exported KifElement* multiply(KifElement* a,KifElement* b,bool autoself) {
		return kifNULL;
	}
	virtual Exported KifElement* divide(KifElement* a,KifElement* b,bool autoself) {
		return kifNULL;
	}
	virtual Exported KifElement* mod(KifElement* a,KifElement* b,bool autoself) {
		return kifNULL;
	}
	virtual Exported KifElement* shiftright(KifElement* a,KifElement* b,bool autoself) {
		return kifNULL;
	}
	virtual Exported KifElement* shiftleft(KifElement* a,KifElement* b,bool autoself) {
		return kifNULL;
	}
	virtual Exported KifElement* power(KifElement* a,KifElement* b,bool autoself) {
		return kifNULL;
	}

	
	virtual Exported KifElement* less(KifElement* a) {
		return kifFALSE;
	}
	virtual Exported KifElement* more(KifElement* a) {
		return kifFALSE;
	}
	virtual Exported KifElement* same(KifElement* a) {
		if (a==this)
			return kifTRUE;
		return kifFALSE;
	}
	
	virtual Exported KifElement* different(KifElement* a) {
		if (same(a)==kifFALSE)
			return kifTRUE;
		return kifFALSE;
	}

	virtual Exported KifElement* lessequal(KifElement* a) {
		return kifFALSE;
	}
	virtual Exported KifElement* moreequal(KifElement* a) {
		return kifFALSE;
	}

	virtual void Setaction(KifOperator a) {}
	virtual KifOperator Action() {
		return kifNONE;
	}

	virtual KifElement* ExecuteMethod(short name,KifElement* contextualpattern,KifDomain* domain,KifCallFunction* callfunc) {
		return kifNULL;
	}

	Exported KifElement* Kifpredefined(short n);
	Exported KifElement* Kifpredefined(string n);
	Exported KifCode* KifCurrent();
	virtual ~KifElement() {}
};



class KifCallMethod : public KifElement {
public:
	short name;
	
	KifCallMethod(short n) : KifElement(NULL,NULL,kifCallMethod) {
		name=n;
	}
	KifCallMethod() : KifElement(NULL,NULL,kifCallMethod) {}
	void Setname(short n) {
		name=n;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* domain,KifElement* value,KifCallFunction* func) {
		return value->ExecuteMethod(name,contextualpattern,domain,func);
	}
	Exported KifElement* Copy(KifDomain*,KifElement* ke=kifNULL) {
		return this;
	}
};

class KifBasic : public KifElement {
public:

	KifBasic(KifCode* klc,KifElement* kp,KifType k) : KifElement(klc,kp,k) {}
	//Return the predefined function bodies: type, list or isa	
		//What happens when a KifPerso element is evaluated
	virtual Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* idx,bool rcouple=false) {
		return this;
	}


	bool Basic() {
		return true;
	}
};


class KifSelf : public KifElement {
public:
	KifElement* value;
	KifElement* parameter;

	KifSelf(KifCode* klc,KifElement* kp,KifElement* v) : KifElement(klc,kp,kifSelf) {
		value=v;
		parameter=kifNULL;
	}
	bool Variable() {
		return true;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false) {
		return value;
	}

	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL);
	Exported bool Setvalue(KifElement* ke,KifElement* index,KifElement* dom);
	KifElement* Returnvalue() {
		return value;
	}
	Exported KifElement* Declaration(short n);
};



class KifDate : public KifElement {
public:
	time_t value;

	Exported KifDate(KifCode* klc,KifElement* kp,time_t v=0);

	Exported KifElement* Atom() {return new KifDate(kifcode,NULL,value);}
	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL);
	Exported KifElement* applyinitial(KifDomain*,KifElement*);
	Exported bool initialapplyied() {return true;}

	Exported KifElement* Declaration(short n);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);


	bool Basic() {
		return true;
	}
	bool Simple() {
		return true;
	}	

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool rcouple=false) {
		ThreadLock _lock(type);
		return this;
	}

	bool Predefinedtype() {return true;}	
	virtual Exported bool Setvalue(KifElement* ke,KifElement* index=NULL,KifElement* dom=NULL);

	Exported KifElement* Newinstance();

	Exported string String();
	Exported long Integer() {
		return value;
	}
	Exported double Float() {
		return value;
	}

	Exported bool Boolean() {
		if (value==0)
			return false;
		return true;
	}

	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
		if (kfunc==NULL) {
			if (b->type==kifInteger)
				return b->same(a);
			return b->in(a,b,NULL,contextualpattern,true);
		}
		else
			return applyfunc(a,b,kfunc);
	}

	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself);


	Exported KifElement* less(KifElement* a) {
		if (value<a->Integer())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* more(KifElement* a) {
		if (value>a->Integer())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* same(KifElement* a) {
		if (value==a->Integer())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* different(KifElement* a) {
		if (value!=a->Integer())
			return kifTRUE;
		return kifFALSE;
	}

	Exported KifElement* lessequal(KifElement* a) {
		if (value<=a->Integer())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* moreequal(KifElement* a) {
		if (value>=a->Integer())
			return kifTRUE;
		return kifFALSE;
	}
	Exported long Size() {
		return value;
	}
};

class KifTime : public KifElement {
public:
	timeval value;

	Exported KifTime(KifCode* klc,KifElement* kp);

	Exported KifElement* Atom() {
		KifTime* tim=new KifTime(kifcode,NULL);
		tim->value=value;
		return tim;
	}
	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL);

	Exported KifElement* Declaration(short n);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);

	bool Basic() {
		return true;
	}
	bool Simple() {
		return true;
	}	

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool rcouple=false) {
		ThreadLock _lock(type);
		return this;
	}
	bool Predefinedtype() {return true;}	
	virtual Exported bool Setvalue(KifElement* ke,KifElement* index=NULL,KifElement* dom=NULL);

	Exported KifElement* Newinstance();

	Exported string String();
	
	Exported double Float() {
		double mt=(((unsigned long)value.tv_sec)*1000 + ((unsigned long)value.tv_usec)/1000.0) + 0.5;
		return mt;
	}

	Exported long Integer() {
		return Float();
	}

	Exported bool Boolean() {
		return true;
	}

	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
		if (kfunc==NULL) {
			if (b->type==kifInteger)
				return b->same(a);
			return b->in(a,b,NULL,contextualpattern,true);
		}
		else
			return applyfunc(a,b,kfunc);
	}

	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself);


	Exported KifElement* less(KifElement* a) {
		double mt=(((unsigned long)value.tv_sec)*1000 + ((unsigned long)value.tv_usec)/1000.0) + 0.5;
		if (mt<a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* more(KifElement* a) {
		if (Float()>a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* same(KifElement* a) {
		if (Float()==a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* different(KifElement* a) {
		if (Float()!=a->Float())
			return kifTRUE;
		return kifFALSE;
	}

	Exported KifElement* lessequal(KifElement* a) {
		if (Float()<=a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* moreequal(KifElement* a) {
		if (Float()>=a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported long Size() {
		return Integer();
	}
};

class KifInteger : public KifElement {
public:
	long value;
	KifInteger(KifCode* klc,KifElement* kp,long v=0,KifType t=kifInteger) : KifElement(klc,kp,t) {value=v;}
	Exported KifElement* Atom() {
		return kifcode->Provideinteger(value);
	}

	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		return kifcode->Provideinteger(value);
	}

	Exported KifFraction* Fraction();

	Exported void Resetreference() {
		reference--;
		if (reference<=0) {
			if (popped)
				popped=false;
			else {				
				ThreadLock _lock(type);
				if (idgarbage!=-1 && idgarbage<kifcode->cursorinteger)
					kifcode->cursorinteger=idgarbage;
			}
		}
	}

	Exported KifElement* Declaration(short n);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);

	bool Basic() {
		return true;
	}
	bool Simple() {
		return true;
	}	

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool rcouple=false) {
		ThreadLock _lock(type);
		return this;
	}

	bool Predefinedtype() {return true;}	
	virtual Exported bool Setvalue(KifElement* ke,KifElement* index=NULL,KifElement* dom=NULL);

	virtual Exported KifElement* Newinstance() {
		return kifcode->Provideinteger(0);
	}

	Exported string String();
	Exported long Integer() {
		return value;
	}
	Exported double Float() {
		return value;
	}
	Exported bool Boolean() {
		if (value==0)
			return false;
		return true;
	}

	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
		if (kfunc==NULL) {
			if (b->type==kifInteger)
				return b->same(a);
			return b->in(a,b,NULL,contextualpattern,true);
		}
		else
			return applyfunc(a,b,kfunc);
	}

	Exported KifElement* andset(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value&=b->Integer();
			return this;
		}
		long i=a->Integer() & b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);
		return kv;

	}

	Exported KifElement* orset(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value|=b->Integer();
			return this;
		}
		long i=a->Integer() | b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);
		return kv;

	}

	Exported KifElement* xorset(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value^=b->Integer();
			return this;
		}
		long i=a->Integer() ^ b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);
		return kv;

	}

	Exported void plusplus() {
		ThreadLock _lock(type);
		value++;
	}
	Exported void minusminus() {
		ThreadLock _lock(type);
		value--;
	}

	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value+=b->Integer();
			return this;
		}
		long i=a->Integer()+b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);
		return kv;

	}
	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value-=b->Integer();
			return this;
		}
		long i=a->Integer()-b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);
		return kv;
	}
	Exported KifElement* multiply(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value*=b->Integer();
			return this;
		}
		long i=a->Integer()*b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);
		return kv;
	}

	Exported KifElement* divide(KifElement* a,KifElement* b,bool autoself);

	Exported KifElement* mod(KifElement* a,KifElement* b,bool autoself) {
		long ib=b->Integer();
		if (ib==0)
			return kifNULL;
		if (autoself) {
			value%=ib;
			return this;
		}
		long i=a->Integer()%ib;
		KifElement* kv= kifcode->Provideinteger(i);
		return kv;
	}
	Exported KifElement* shiftleft(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value<<=b->Integer();
			return this;
		}
		long i=a->Integer()<<b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);

		return kv;
	}


	Exported KifElement* shiftright(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value>>=b->Integer();
			return this;
		}
		long i=a->Integer()>>b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);

		return kv;
	}
	Exported KifElement* power(KifElement* a,KifElement* b,bool autoself);

	Exported KifElement* less(KifElement* a) {
		if (value<a->Integer())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* more(KifElement* a) {
		if (value>a->Integer())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* same(KifElement* a) {
		if (value==a->Integer())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* different(KifElement* a) {
		if (value!=a->Integer())
			return kifTRUE;
		return kifFALSE;
	}

	Exported KifElement* lessequal(KifElement* a) {
		if (value<=a->Integer())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* moreequal(KifElement* a) {
		if (value>=a->Integer())
			return kifTRUE;
		return kifFALSE;
	}
	Exported long Size() {
		return value;
	}
};

class KifFraction : public KifElement {
public:
	KIFLONG numerator;
	KIFLONG denominator;

	KifFraction(KifCode* klc,KifElement* kp,KIFLONG n,KIFLONG d,KifType t=kifFraction) : KifElement(klc,kp,t) {
		numerator=n;
		denominator=d;
	}

	Exported KifElement* Atom() {
		return new KifFraction(kifcode,NULL,numerator,denominator);
	}

	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		return new KifFraction(kifcode,NULL,numerator,denominator);
	}

	Exported KifElement* applyinitial(KifDomain*,KifElement*);
	Exported bool initialapplyied() {return true;}

	Exported KifElement* Declaration(short n);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);

	bool Basic() {
		return true;
	}
	bool Simple() {
		return true;
	}	

	Exported KifFraction* Fraction() {
		return this;
	}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool rcouple=false) {
		ThreadLock _lock(type);
		return this;
	}
	bool Predefinedtype() {return true;}	
	
	Exported bool Setvalue(KifElement* ke,KifElement* index=NULL,KifElement* dom=NULL) {
		if (ke->type!=kifFraction)
			ke=ke->Fraction();
		
		if (ke->D()==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return true;
		}				
		denominator=ke->D();
		numerator=ke->N();
		return true;
	}

	virtual Exported KifElement* Newinstance() {
		return kifcode->Provideinteger(0);
	}

	Exported string String();
	Exported long Integer() {
		if (denominator==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return 0;
		}
		double v=(double)numerator/(double)denominator;
		return ((long)v);
	}

	Exported double Float() {
		if (denominator==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return 0;
		}
		double v=(double)numerator/(double)denominator;
		return (v);
	}
	Exported bool Boolean() {
		if (denominator==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return false;
		}
		long v=numerator/denominator;
		if (v==0)
			return false;
		return true;
	}

	virtual Exported void ND(KIFLONG n,KIFLONG d) {
		numerator=n;
		denominator=d;
	}

	KIFLONG euclidian(KIFLONG a,KIFLONG b) {
		if (b==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return 0;
		}
		if (a<b)
			return 1;
		KIFLONG remain=a%b;
		if (remain==0)
			return b;
		return euclidian(b,remain);
	}

	Exported KifElement* Euclidian() {
		if (denominator==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return 0;
		}
		KIFLONG res;
		if (denominator>numerator)
			res=euclidian(denominator,numerator);
		else
			res=euclidian(numerator,denominator);
		return kifcode->Provideinteger(res);
	}

	Exported KifElement* FractionSimplify(bool s) {
		if (denominator==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return 0;
		}
		if (denominator==1 || numerator==0)
			return this;
		if (denominator==numerator)
			return new KifFraction(kifcode,NULL,1,1);
		
		KIFLONG res;
		if (denominator>numerator)
			res=euclidian(denominator,numerator);
		else
			res=euclidian(numerator,denominator);
		if (res==1)		
			return this;
		if (s==true) {
			numerator/=res;
			denominator/=res;
			return this;
		}
		KIFLONG n=numerator/res;
		KIFLONG d=denominator/res;
		return new KifFraction(kifcode,NULL,n,d);
	}

	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
		if (kfunc==NULL) {
			if (b->type==kifInteger)
				return b->same(a);
			return b->in(a,b,NULL,contextualpattern,true);
		}
		else
			return applyfunc(a,b,kfunc);
	}

	Exported KIFLONG D() {
		return denominator;
	}

	Exported KIFLONG N() {
		return numerator;
	}

	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself) {
		KIFLONG dea=a->D();
		if (dea==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return kifFALSE;
		}
		KIFLONG nua=a->N();
		if (b->type!=kifFraction)
			b=b->Fraction();
		
		KIFLONG nub=b->N();
		KIFLONG deb=b->D();
		if (deb==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return kifFALSE;
		}
		
		nub=b->N();
		if (deb!=dea) {
			nua*=deb;
			nub*=dea;
			dea*=deb;
		}
		
		nua+=nub;
		if (autoself) {
			numerator=nua;
			denominator=dea;
			return this;
		}

		return new KifFraction(kifcode,NULL,nua,dea);
	}

	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself) {
		KIFLONG dea=a->D();
		if (dea==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return kifFALSE;
		}
		KIFLONG nua=a->N();
		if (b->type!=kifFraction)
			b=b->Fraction();
		
		KIFLONG nub=b->N();
		KIFLONG deb=b->D();
		if (deb==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return kifFALSE;
		}
		
		nub=b->N();
		if (deb!=dea) {
			nua*=deb;
			nub*=dea;
			dea*=deb;
		}
		
		nua-=nub;
		if (autoself) {
			numerator=nua;
			denominator=dea;
			return this;
		}

		return new KifFraction(kifcode,NULL,nua,dea);
	}

	Exported KifElement* multiply(KifElement* a,KifElement* b,bool autoself) {
		KIFLONG dea=a->D();
		if (dea==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return kifFALSE;
		}
		KIFLONG nua=a->N();

		if (b->type!=kifFraction)
			b=b->Fraction();
			
		if (b->D()==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return kifFALSE;
		}
		
		nua*=b->N();
		dea*=b->D();
		
		if (autoself) {
			numerator=nua;
			denominator=dea;
			return this;
		}

		return new KifFraction(kifcode,NULL,nua,dea);
	}

	Exported KifElement* divide(KifElement* a,KifElement* b,bool autoself) {
		KIFLONG dea=a->D();
		if (dea==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return kifFALSE;
		}
		KIFLONG nua=a->N();

		if (b->type!=kifFraction)
			b=b->Fraction();
		
		KIFLONG deb=b->D();
		if (deb==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return kifFALSE;
		}
		nua*=deb;
		dea*=b->N();
		if (dea==0) {
			kifcode->Returnerror("MATH(100): Error wrong fraction: denominator is 0");
			return kifFALSE;
		}
		
		if (autoself) {
			numerator=nua;
			denominator=dea;
			return this;
		}

		return new KifFraction(kifcode,NULL,nua,dea);
	}

	Exported KifElement* mod(KifElement* a,KifElement* b,bool autoself) {
		long ib=b->Integer();
		if (ib==0)
			return kifNULL;
		long i=a->Integer()%ib;
		KifElement* kv= kifcode->Provideinteger(i);
		return kv;
	}
	Exported KifElement* shiftleft(KifElement* a,KifElement* b,bool autoself) {
		long i=a->Integer()<<b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);

		return kv;
	}


	Exported KifElement* shiftright(KifElement* a,KifElement* b,bool autoself) {
		long i=a->Integer()>>b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);
		return kv;
	}

	Exported KifElement* power(KifElement* a,KifElement* b,bool autoself);

	Exported KifElement* less(KifElement* a) {
		if (Float()<a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* more(KifElement* a) {
		if (Float()>a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* same(KifElement* a) {
		if (Float()==a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* different(KifElement* a) {
		if (Float()!=a->Float())
			return kifTRUE;
		return kifFALSE;
	}

	Exported KifElement* lessequal(KifElement* a) {
		if (Float()<=a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* moreequal(KifElement* a) {
		if (Float()>=a->Float())
			return kifTRUE;
		return kifFALSE;
	}

	Exported long Size() {
		return Integer();
	}
};

//Then KifString
class KifString : public KifElement {
public:
	string value;	

	KifString(KifCode* klc,KifElement* kp,string v="",KifType t=kifString) : KifElement(klc,kp,t) {value=v;}
	Exported KifElement* Atom() {
		return kifcode->Providestring(value);
	}
	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		return kifcode->Providestring(value);
	}
	virtual inline void update() {}
	virtual Exported void Clean() {
		reference--;
		value="";
		if (reference<=0) {
			ThreadLock _lock(type);
			if (idgarbage!=-1 && idgarbage<kifcode->cursorstring)
				kifcode->cursorstring=idgarbage;
		}
	}

	virtual Exported void Clear() {
		value="";
	}


	bool Basic() {
		return true;
	}
	bool Simple() {
		return true;
	}	
	Exported KifElement* Newiterator(bool);
	
	virtual Exported void Resetreference() {
		reference--;
		if (reference<=0) {
			if (popped)
				popped=false;
			else {	
				ThreadLock _lock(type);
				if (idgarbage!=-1 && idgarbage<kifcode->cursorstring)
					kifcode->cursorstring=idgarbage;
			}
		}
	}

	virtual Exported KifElement* Newinstance() {
		return kifcode->Providestringraw("");
	}

	KifElement* Pop(KifElement* ke) {
		ThreadLock _lock(type);
		if (value.size()==0)
			return kifNULL;
		int i=ke->Integer();
		if (i==-1)
			i=value.size()-1;
		else
			if (i>=value.size() || i<0)
				return kifNULL;

		string res=c_char_index_remove(value,i,kifcode->utf8);
		return kifcode->Providestring(res);
	}


	KifElement* Last() {
		if (value.size()==0)
			return kifNULL;
		int i=value.size()-1;
		string res=c_char_index(value,i,kifcode->utf8);
		return kifcode->Providestring(res);
	}


	Exported bool Setvalue(KifElement* ke,KifElement* idx=NULL,KifElement* dom=NULL);

	Exported long Size();

	bool Predefinedtype() {return true;}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke=NULL,bool rcouple=false);
	Exported string String() {
		return value;
	}
	Exported long Integer();
	Exported double Float();
	Exported bool Boolean() {
		if (value=="" || value=="false")
			return false;
		return true;
	}


	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx);

	Exported KifElement* Declaration(short n);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);


	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value+=b->String();
			update();
			return this;
		}
		string s=a->String()+b->String();
		KifElement* kv= kifcode->Providestring(s);

		return kv;
	}

	Exported KifElement* less(KifElement* a) {
		if (value<a->String())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* more(KifElement* a) {
		if (value>a->String())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* same(KifElement* a) {
		if (value==a->String())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* different(KifElement* a) {
		if (value!=a->String())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* lessequal(KifElement* a) {
		if (value<=a->String())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* moreequal(KifElement* a) {
		if (value>=a->String())
			return kifTRUE;
		return kifFALSE;
	}
	
	Exported KifElement* Vector(KifElement*);
	Exported KifElement* Map(KifElement*);

};

class KifBaseString : public KifString {
public:
	KifBaseString(KifCode* klc,KifElement* kp,string v="") : KifString(klc,kp,v) {}
	Exported void Resetreference() {
		KifElement::Resetreference();
	}
};

class KifError : public KifString {
public:

	KifError(KifCode* klc,KifElement* kp,string message) : KifString(klc,kp,message,kifError) {}
	Exported double Float() {
		return -1;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple);
};


class KifFloat : public KifElement {
public:
	double value;
	KifFloat(KifCode* klc,KifElement* kp,double v=0,KifType t=kifFloat) : KifElement(klc,kp,t) {value=v;}
	Exported KifElement* Atom() {
		return kifcode->Providefloat(value);
	}
	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		return kifcode->Providefloat(value);
	}
	
	Exported KifFraction* Fraction();

	Exported void Resetreference() {
		reference--;
		if (reference<=0) {
			if (popped)
				popped=false;
			else {	
				ThreadLock _lock(type);
				if (idgarbage!=-1 && idgarbage<kifcode->cursorfloat)
					kifcode->cursorfloat=idgarbage;
			}
		}
	}

	Exported KifElement* Declaration(short n);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);

	bool Simple() {
		return true;
	}	
	bool Basic() {
		return true;
	}

	virtual Exported KifElement* Newinstance() {
		return kifcode->Providefloat(0);
	}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool rcouple=false) {
		ThreadLock _lock(type);
		return this;
	}

	bool Predefinedtype() {return true;}

	Exported long Size() {
		return value;
	}
	virtual Exported bool Setvalue(KifElement* ke,KifElement* index=NULL,KifElement* dom=NULL);
	Exported string String();
	Exported long Integer() {
		return value;
	}
	Exported double Float() {
		return value;
	}
	Exported bool Boolean() {
		if (value==0)
			return false;
		return true;
	}
	virtual inline void update() {}

	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
		if (kfunc==NULL) {
			if (b->type==kifFloat)
				return b->same(a);
			return b->in(a,b,NULL,contextualpattern,true);
		}
		else
			return applyfunc(a,b,kfunc);
	}


	Exported KifElement* andset(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value=(long)value & b->Integer();
			update();
			return this;
		}
		long i=a->Integer() & b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);
		return kv;

	}

	Exported KifElement* orset(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value=(long)value | b->Integer();
			update();
			return this;
		}
		long i=a->Integer() | b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);
		return kv;

	}

	Exported KifElement* xorset(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value=(long)value^b->Integer();
			update();
			return this;
		}
		long i=a->Integer()^b->Integer();
		KifElement* kv= kifcode->Provideinteger(i);
		return kv;

	}

	Exported void plusplus() {
		ThreadLock _lock(type);
		value++;
	}
	Exported void minusminus() {
		ThreadLock _lock(type);
		value--;
	}

	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value+=b->Float();
			update();
			return this;
		}
		double i=a->Float()+b->Float();
		KifElement* kv= kifcode->Providefloat(i);
		return kv;

	}
	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value-=b->Float();
			update();
			return this;
		}
		double i=a->Float()-b->Float();
		KifElement* kv= kifcode->Providefloat(i);

		return kv;
	}
	Exported KifElement* multiply(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value*=b->Float();
			update();
			return this;
		}
		double i=a->Float()*b->Float();
		KifElement* kv= kifcode->Providefloat(i);

		return kv;
	}
	Exported KifElement* divide(KifElement* a,KifElement* b,bool autoself);

	Exported KifElement* mod(KifElement* a,KifElement* b,bool autoself) {
		long ib=b->Integer();
		if (ib==0)
			return kifNULL;

		if (autoself) {
			value=(long)value % ib;
			update();
			return this;
		}
		double i=a->Integer()%ib;
		KifElement* kv= kifcode->Providefloat(i);
		return kv;
	}

	Exported KifElement* shiftleft(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value=(long)value << b->Integer();
			update();
			return this;
		}
		double i=a->Integer()<<b->Integer();
		KifElement* kv= kifcode->Providefloat(i);

		return kv;
	}
	Exported KifElement* shiftright(KifElement* a,KifElement* b,bool autoself) {
		if (autoself) {
			value=(long)value >> b->Integer();
			update();
			return this;
		}
		double i=a->Integer()>>b->Integer();
		KifElement* kv= kifcode->Providefloat(i);

		return kv;
	}
	Exported KifElement* power(KifElement* a,KifElement* b,bool autoself);

	Exported KifElement* less(KifElement* a) {
		if (value<a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* more(KifElement* a) {
		if (value>a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* same(KifElement* a) {
		if (value==a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* different(KifElement* a) {
		if (value!=a->Float())
			return kifTRUE;
		return kifFALSE;
	}

	Exported KifElement* lessequal(KifElement* a) {
		if (value<=a->Float())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* moreequal(KifElement* a) {
		if (value>=a->Float())
			return kifTRUE;
		return kifFALSE;
	}
};


class KifBoolean : public KifElement {
public:
	bool value;
	KifBoolean(KifCode* klc,KifElement* kp,bool v=false,KifType ty=kifBoolean) : KifElement(klc,kp,ty) {value=v;}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool rcouple=false) {
		ThreadLock _lock(type);
		return this;
	}

	virtual Exported bool Setvalue(KifElement* ke,KifElement* index=NULL,KifElement* dom=NULL);

	Exported KifElement* Newinstance() {
		return new KifBoolean(kifcode,NULL);
	}
	Exported KifElement* Atom() {
		return new KifBoolean(kifcode,NULL,value);
	}

	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		return new KifBoolean(kifcode,(KifElement*)kp,value);
	}

	bool Basic() {
		return true;
	}
	bool Simple() {
		return true;
	}	

	bool Predefinedtype() {return true;}

	Exported string String() {
		if (value)
			return "true";
		return "false";
	}
	Exported long Integer() {
		if (value)
			return 1;
		return 0;
	}
	Exported double Float() {
		if (value)
			return 1;
		return 0;
	}
	Exported bool Boolean() {
		return value;
	}

	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
		KifElement* res=b->in(a,b,kfunc,this,idx);
		if (res->Boolean()==false || res==kifNULL)
			return kifFALSE;
		return kifTRUE;
	}

	Exported KifElement* orset(KifElement* a,KifElement* b,bool autoself) {
		bool va=a->Boolean();
		bool vb=b->Boolean();
		if (va || vb)
			return kifTRUE;
		return kifFALSE;
	}

	Exported KifElement* xorset(KifElement* a,KifElement* b,bool autoself) {
		bool va=a->Boolean();
		bool vb=b->Boolean();
		if ((va && !vb) || (!va && vb))
			return kifTRUE;
		return kifFALSE;
	}

	Exported KifElement* andset(KifElement* a,KifElement* b,bool autoself) {
		bool va=a->Boolean();
		bool vb=b->Boolean();
		if (va && vb)
			return kifTRUE;
		return kifFALSE;
	}

	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself) {
		bool va=a->Boolean();
		bool vb=b->Boolean();
		if (va || vb)
			return kifTRUE;
		return kifFALSE;
	}

	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself) {
		bool va=a->Boolean();
		bool vb=b->Boolean();
		if (va && vb)
			return kifFALSE;
		if (va)
			return kifTRUE;
		return kifFALSE;
	}
	
	Exported KifElement* less(KifElement* a) {
		if (value<a->Boolean())
			return kifTRUE;
		return kifFALSE;
	}

	Exported KifElement* more(KifElement* a) {
		if (value>a->Boolean())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* same(KifElement* a) {
		if (value==a->Boolean())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* different(KifElement* a) {
		if (value!=a->Boolean())
			return kifTRUE;
		return kifFALSE;
	}	
	Exported KifElement* lessequal(KifElement* a) {
		if (value<=a->Boolean())
			return kifTRUE;
		return kifFALSE;
	}
	Exported KifElement* moreequal(KifElement* a) {
		if (value>=a->Boolean())
			return kifTRUE;
		return kifFALSE;
	}

};


class KifList : public KifElement {
public:
	list<KifElement*> values;
	bool evaluate;

	KifList(KifCode* klc,KifElement* kp) : KifElement(klc,kp,kifList) {evaluate=false;}

	Exported KifElement* Newinstance() {
		return new KifList(kifcode,NULL);
	}

	Exported KifElement* Newiterator(bool);
	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL);
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* idx,bool rcouple=false);
	Exported KifElement* Evalue(KifElement* contextualpattern,KifDomain* dom,KifElement* idx);
	Exported KifElement* Vector(KifElement*);
	Exported KifElement* Map(KifElement*);
	Exported bool Setvalue(KifElement* ke,KifElement* idx,KifElement* dom=NULL);


	Exported void Add(KifElement* e) {
		ThreadLock _lock(type);
		values.push_back(e);
	}


	Exported void Insert(int idx,KifElement* ke) {
		int nb=reference;
		ke=ke->Atom();
		while (nb>=0) {
			ke->Setreference();
			nb--;
		}
		list<KifElement*>::iterator itl=values.begin();
		for (nb=0;nb<idx;nb++)
			itl++;
		values.insert(itl,ke);
	}

	Exported void PushLast(KifElement* ke) {
		ThreadLock _lock(type);
		int nb=reference;
		ke=ke->Atom();
		while (nb>=0) {
			ke->Setreference();
			nb--;
		}
		values.push_back(ke);
	}

	Exported void Push(KifElement* ke) {
		ThreadLock _lock(type);
		int nb=reference;
		ke=ke->Atom();
		while (nb>=0) {
			ke->Setreference();
			nb--;
		}
		values.push_back(ke);
	}

	Exported void PushFirst(KifElement* ke) {
		ThreadLock _lock(type);
		int nb=reference;
		ke=ke->Atom();
		while (nb>=0) {
			ke->Setreference();
			nb--;
		}
		values.push_front(ke);
	}


	KifElement* PopLast() {
		if (values.size()==0)
			return kifNULL;
		KifElement* kres=values.back();
		int nb=reference;
		kres->popped=true;
		while (nb>=0) {
			kres->Resetreference();
			nb--;
		}
		values.pop_back();
		return kres;
	}

	KifElement* Pop(KifElement* ke) {
		ThreadLock _lock(type);
		if (values.size()==0)
			return kifNULL;
		
		int nb=ke->Integer();		
		if (nb==-1)
			return PopLast();
		
		if (nb>=values.size() || nb<0)
			return kifNULL;

		list<KifElement*>::iterator it=values.begin();
		while (nb>0) {
			it++;
			nb--;
		}
		KifElement* kres=*it;
		values.erase(it);
		if (kres!=NULL) {
			kres->popped=true;
			nb=reference;
			while (nb>=0) {
				kres->Resetreference();
				nb--;
			}
			return kres;
		}
		return kifNULL;
	}

	KifElement* PopFirst() {
		ThreadLock _lock(type);
		if (values.size()==0)
			return kifNULL;
		KifElement* kres=values.front();
		int nb=reference;
		kres->popped=true;
		while (nb>=0) {
			kres->Resetreference();
			nb--;
		}
		values.pop_front();
		return kres;
	}


	KifElement* Last() {
		if (values.size()==0)
			return kifNULL;
		return values.back();	
	}

	KifElement* First() {
		if (values.size()==0)
			return kifNULL;
		return values.front();	
	}

	bool Basic() {
		return true;
	}

	void Toassign(bool v) {
		evaluate=v;
	}

	bool Assigning(KifType t) {
		if (t!=type)
			return false;
		return evaluate;
	}

	Exported KifElement* Declaration(short n);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);
	KifElement* ValueOnIndex(size_t ikey) {
		if (ikey<0 || ikey>=values.size())
			return kifNULL;
		list<KifElement*>::iterator it=values.begin();
		int i;
		for (i=0;i<ikey;i++) it++;
		return *it;
	}


	//Clear cleans the vector and free some of the inner instances
	//There is slight difference with the next function. In this case,
	//we do not want to interfere with an instance that would be a map or
	//a vector and free its content, while it should still be alive...
	//Clean is called recursively to clean all instances, then itself
	Exported void Setreference() {
		reference++;
		list<KifElement*>::iterator itx;
		for (itx=values.begin();itx!=values.end();itx++)			
			(*itx)->Setreference();
	}

	Exported void Setpopped() {
		popped=true;
		list<KifElement*>::iterator itx;
		for (itx=values.begin();itx!=values.end();itx++)			
			(*itx)->Setpopped();
	}

	Exported void Clean() {
		reference--;
		list<KifElement*>::iterator itx;
		for (itx=values.begin();itx!=values.end();itx++)			
			(*itx)->Clean();
		values.clear();

	}

	Exported void Resetreference();

	Exported void Clear();


	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx);
	Exported long Integer() {
		return values.size();
	}
	Exported double Float() {
		return values.size();
	}

	Exported string String();

	Exported long Size() {
		return values.size();
	}

	Exported bool Boolean() {
		if (values.size()==0)
			return false;
		return true;
	}

	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* multiply(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* divide(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* mod(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* shiftright(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* shiftleft(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* power(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* orset(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* andset(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* same(KifElement* a);
};

class KifVector : public KifElement {
public:
	vector<KifElement*> values;
	bool evaluate;

	KifVector(KifCode* klc,KifElement* kp) : KifElement(klc,kp,kifVector) {evaluate=false;}

	Exported KifElement* Newinstance() {
		return kifcode->Providevector();
	}

	Exported KifElement* Newiterator(bool);
	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL);
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* idx,bool rcouple=false);
	Exported KifElement* Evalue(KifElement* contextualpattern,KifDomain* dom,KifElement* idx);
	Exported bool Setvalue(KifElement* ke,KifElement* idx,KifElement* dom=NULL);
	Exported KifElement* Vector(KifElement*) {
		return this;
	}
	Exported KifElement* Map(KifElement*);
	
	bool Basic() {
		return true;
	}

	void Toassign(bool v) {
		evaluate=v;
	}

	bool Assigning(KifType t) {
		if (t!=type)
			return false;
		return evaluate;
	}

	void Resetreference() {
		for (int itx=0;itx<values.size();itx++)	{
			if (popped==true)
				values[itx]->popped=popped;
			values[itx]->Resetreference();
		}

		reference--;
		if (reference<=0) {
			if (popped)
				popped=false;
			else {
				values.clear();
				ThreadLock _lock(type);
				if (idgarbage!=-1 && idgarbage<kifcode->cursorvector)
					kifcode->cursorvector=idgarbage;
			}
		}
	}

	void Clear() {
		for (int itx=0;itx<values.size();itx++)	{
			int nb=reference;
			while (nb>=0) {
				values[itx]->Resetreference();
				nb--;
			}
		}
		values.clear();
	}
	 
	Exported void Push(KifElement* ke) {
		ThreadLock _lock(type);
		int nb=reference;
		ke=ke->Atom();
		while (nb>=0) {
			ke->Setreference();
			nb--;
		}
		values.push_back(ke);
	}

	Exported void Insert(int idx,KifElement* ke) {
		int nb=reference;
		ke=ke->Atom();
		while (nb>=0) {
			ke->Setreference();
			nb--;
		}
		values.insert(values.begin()+idx,ke);
	}

	KifElement* Pop(KifElement* ke) {
		ThreadLock _lock(type);
		if (values.size()==0)
			return kifNULL;
		int nb=ke->Integer();
		if (nb==-1)
			nb=values.size()-1;
		else
			if (nb>=values.size() || nb<0)
				return kifNULL;

		KifElement* kres=values[nb];
		values.erase(values.begin()+nb);
		if (kres!=NULL) {
			kres->popped=true;
			nb=reference;
			while (nb>=0) {
				kres->Resetreference();
				nb--;
			}
			return kres;
		}

		return kifNULL;
	}

	KifElement* Last() {
		if (values.size()==0)
			return kifNULL;

		int i=values.size()-1;

		return values[i];
	}

	KifElement* ValueOnIndex(size_t i) {
		if (i<0 || i>=values.size())
			return kifNULL;
		return values[i];
	}

	Exported void Add(KifElement* e) {
		ThreadLock _lock(type);
		values.push_back(e);
	}


	Exported KifElement* Declaration(short n);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);


	//Clear cleans the vector and free some of the inner instances
	//There is slight difference with the next function. In this case,
	//we do not want to interfere with an instance that would be a map or
	//a vector and free its content, while it should still be alive...
	//Clean is called recursively to clean all instances, then itself
	Exported void Setreference() {
		reference++;
		vector<KifElement*>::iterator itx;
		for (itx=values.begin();itx!=values.end();itx++)			
			(*itx)->Setreference();
	}

	Exported void Setpopped() {
		popped=true;
		vector<KifElement*>::iterator itx;
		for (itx=values.begin();itx!=values.end();itx++)			
			(*itx)->Setpopped();
	}

	Exported void Clean() {
		reference--;
		for (int i=0;i<=values.size();i++)			
			values[i]->Clean();
		values.clear();
		if (reference<=0) {
			ThreadLock _lock(type);
			if (idgarbage!=-1 && idgarbage<kifcode->cursorvector)
				kifcode->cursorvector=idgarbage;
		}
	}



	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx);
	Exported long Integer() {
		return values.size();
	}
	Exported double Float() {
		return values.size();
	}

	Exported string String();

	Exported long Size() {
		return values.size();
	}

	Exported bool Boolean() {
		if (values.size()==0)
			return false;
		return true;
	}

	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* multiply(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* divide(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* mod(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* shiftright(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* shiftleft(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* power(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* orset(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* andset(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* same(KifElement* a);

};


class KifMap : public KifElement {
public:
	hmap<string,KifElement*> values;
	bool evaluate;

	Exported KifMap(KifCode* klc,KifElement* kp) : KifElement(klc,kp,kifMap) {evaluate=false;}

	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL);

	Exported KifElement* Declaration(short n);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);

	Exported KifElement* Vector(KifElement*);
	Exported KifElement* Map(KifElement*) {
		return this;
	}

	bool Basic() {
		return true;
	}

	void Toassign(bool v) {
		evaluate=v;
	}

	bool Assigning(KifType t) {
		if (t!=type)
			return false;
		return evaluate;
	}

	Exported KifElement* Newinstance() {
		return kifcode->Providemap();
	}
	Exported string String();

	Exported KifElement* Newiterator(bool);

	KifElement* Values(string n) {
		hmap<string,KifElement*>::iterator iter=values.find(n);
		if (iter==values.end())
			return NULL;
		return iter->second;
	}


	KifElement* Pop(KifElement* ke) {
		ThreadLock _lock(type);
		if (values.size()==0)
			return kifNULL;

		string s=ke->String();
		hmap<string,KifElement*>::iterator itx=values.find(s);

		if (itx==values.end())
			return kifNULL;

		KifElement* kres=itx->second;
		values.erase(itx);

		if (kres!=NULL) {
			kres->popped=true;
			int nb=reference;
			while (nb>=0) {
				kres->Resetreference();
				nb--;
			}
			return kres;
		}
		return kifNULL;
	}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* idx,bool rcouple=false);
	Exported KifElement* Evalue(KifElement* contextualpattern,KifDomain* dom,KifElement* idx);
	Exported bool Setvalue(KifElement* ke,KifElement* idx,KifElement* dom=NULL);

	Exported void Setreference() {
		reference++;
		hmap<string,KifElement*>::iterator itx;
		for (itx=values.begin();itx!=values.end();itx++) {
			if (itx->second!=NULL)
				itx->second->Setreference();
		}
	}

	Exported void Setpopped() {
		popped=true;
		hmap<string,KifElement*>::iterator itx;
		for (itx=values.begin();itx!=values.end();itx++) {
			if (itx->second!=NULL)
				itx->second->Setpopped();
		}
	}

	Exported void Clean() {
		reference--;
		hmap<string,KifElement*>::iterator itx;
		for (itx=values.begin();itx!=values.end();itx++) {
			if (itx->second!=NULL)
				itx->second->Clean();
		}
		values.clear();
		if (reference<=0) {
			ThreadLock _lock(type);
			if (idgarbage!=-1 && idgarbage<kifcode->cursormap)
				kifcode->cursormap=idgarbage;
		}
	}

	Exported void Resetreference();
	Exported void Clear();


	Exported long Size() {
		return values.size();
	}

	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx);
	Exported long Integer() {
		return values.size();
	}
	Exported double Float() {
		return values.size();
	}

	Exported bool Boolean() {
		if (values.size()==0)
			return false;
		return true;
	}

	//To insert a value into a map through the API 
	Exported void Push(string& key,KifElement* val) {
		ThreadLock _lock(type);
		int nb=reference;
		val=val->Atom();
		if (values.find(key)!=values.end()) {
			while (nb>=0) {
				values[key]->Resetreference();
				val->Setreference();
				nb--;
			}
			values[key]=val;
		}
		else {
			values[key]=val;
			while (nb>=0) {
				val->Setreference();
				nb--;
			}
		}
	}

	Exported void Push(char* key,KifElement* val) {
		ThreadLock _lock(type);
		int nb=reference;
		val=val->Atom();
		if (values.find(key)!=values.end()) {
			while (nb>=0) {
				values[key]->Resetreference();
				val->Setreference();
				nb--;
			}
			values[key]=val;
		}
		else {
			values[key]=val;
			while (nb>=0) {
				val->Setreference();
				nb--;
			}
		}
	}

	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* multiply(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* divide(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* mod(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* shiftright(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* shiftleft(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* power(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* orset(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* andset(KifElement* a,KifElement* b,bool autoself);
	Exported KifElement* same(KifElement* a);

};



class KifMatrix : public KifElement {
public:

	short name;
	vector<map<string,map<string,KifElement*> > > values;
	map<string,bool> attributes;
	map<string,bool> classes;
	long nbelements;

	KifMatrix(KifCode* klc,KifElement* kp,short n) : KifElement(klc,kp,kifMatrix) {
		nbelements=0;
		name=n;
	}

	Exported short Name() {
		return name;
	}

	Exported KifElement* Newinstance() {
		return new KifMatrix(kifcode,NULL,name);
	}

	Exported KifElement* Copy(KifDomain* dom,KifElement* decl=kifNULL) {
		return this;
	}

	bool Variable() {
		return true;
	}

	bool Basic() {
		return true;
	}

	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx);
	Exported void Clear();
	Exported KifElement* Declaration(short n);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);

	Exported void Clean();
	Exported void Save(string& filename,string& ty);
	Exported bool Setvalue(KifElement* k,KifElement* index,KifElement* dom);
	Exported void Resetreference();	
	Exported void Setreference();
	Exported void Setpopped();

	Exported long Size() {
		return nbelements;
	}
	Exported long Integer() {
		return nbelements;
	}
	Exported double Float() {
		return nbelements;
	}
	Exported bool Boolean() {
		if (nbelements==0)
			return false;
		return true;
	}
	void Addvalue(string& c,string& a,KifElement* v,long line);
};

class KifFile : public KifElement {
public:

	string filename;
	fstream* thefile;
	FILE* fileread;
	KifElement* local;
	KifType localtype;
	unsigned char c;
	KifBaseString* localstring;
	char mode;

	KifFile(KifCode* klc,KifElement* kp) : KifElement(klc,kp,kifFile) {
		mode=0;
		thefile=NULL;
		fileread=NULL;
		localstring=new KifBaseString(NULL,NULL);
		localstring->kifcode=kifcode;
	}

	KifElement* EndOfFile() {
		if (mode!=1)
			return kifTRUE;
		if (fileread!=NULL) {
			if (feof(fileread))
				return kifTRUE;
			return kifFALSE;
		}
		if (thefile==NULL)
			return kifTRUE;
		if (thefile->eof())
			return kifTRUE;
		return kifFALSE;
	}
	
	bool Basic() {
		return true;
	}

	void initwhile(KifElement* var) {
		local=var->Returnvalue();
		localtype=local->type;
		
		delete thefile;
		thefile=NULL;
		fileread=fopen((char*)filename.c_str(),"rb");

		if (var->inType()==kifVector)
			local=localstring;
	}

	bool Openread(string n) {
		ThreadLock _lock(kifFile);
		if (thefile!=NULL)
			return false;
		thefile=new fstream((char*)n.c_str(),ios::in|ios::binary);
		if (thefile->fail()) {
			thefile=NULL;
			fileread=NULL;
			return false;
		}
		filename=n;
		mode=1;
		return true;
	}

	Exported KifElement* Declaration(short n);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);


	bool Openwrite(string n) {
		ThreadLock _lock(kifFile);
		if (thefile!=NULL)
			return false;
		thefile=new fstream((char*)n.c_str(),ios_base::out|ios_base::binary);
		if (thefile->fail()) {
			thefile=NULL;
			return false;
		}
		filename=n;
		mode=2;
		return true;
	}

	bool Openappend(string n) {
		ThreadLock _lock(kifFile);
		if (thefile!=NULL)
			return false;
		thefile=new fstream((char*)n.c_str(),ios_base::out|ios_base::app|ios_base::binary);
		if (thefile->fail()) {
			thefile=NULL;
			return false;
		}
		filename=n;
		mode=2;
		return true;
	}

	void Close() {
		ThreadLock _lock(kifFile);
		if (thefile!=NULL)
			delete thefile;
		if (fileread!=NULL)
			fclose(fileread);
		thefile=NULL;
		fileread=NULL;
		mode=0;
	}

	bool Write(string n);
	KifElement* Read();
	KifElement* Readoneline();

	Exported string String() {
		return filename;
	}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple=false) {
		return this;
	}

	~KifFile() {
		Close();
		delete localstring;
	}

	Exported long Size();
	Exported long Integer();
	Exported double Float();

	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		return new KifFile(kifcode,NULL);
	}

	KifElement* Seek(long i) {
		if (fileread!=NULL) {
			fseek(fileread,i,SEEK_SET);
			return kifTRUE;
		}

		if (mode==1) {
			thefile->seekg(i);
			thefile->clear();
			return kifTRUE;
		}
		return kifFALSE;
	}

	KifElement* Tell() {
		long l=-1;
		if (fileread!=NULL)
			l=ftell(fileread);
		else
			if (mode==1)
				l=thefile->tellg();
		return kifcode->Provideinteger(l);
	}

	Exported void Clean() {
		if (reference<=1)
			Close();
		KifElement::Resetreference();
	}

	Exported void Resetreference() {
		if (reference<=1)
			Close();
		KifElement::Resetreference();
	}

	Exported void Clear() {
		Close();
	}
	
	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx);
	Exported KifElement* whilein(KifElement* var);
};


class KifIndex : public KifElement {
public:
	bool interval;
	KifElement* key;
	KifElement* function;
	KifElement* right;

	KifIndex(KifCode* klc,KifElement* kp,bool interv) : KifElement(klc,kp,kifIndex) {
		key=NULL;
		right=NULL;
		function=NULL;
		interval=interv;
	}

	Exported KifElement* Declaration(short s);

	Exported void Add(KifElement* ke) {
		if (key==NULL)
			key=ke;
		else
			if (interval==true)
				right=ke;
			else
				function=ke;
	}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke=NULL,bool rcouple=false);
};

class KifVariable : public KifElement {
public:
	short name;
	KifElement* value;
	bool privatevariable;
	bool localvariable;

	KifVariable(KifCode* klc,KifElement* kp,KifElement* v,short n) : KifElement(klc,kp,kifVariable) {
		localvariable=false;
		name=n;
		value=v;
		privatevariable=false;
	}

	void Setprivate(bool v) {
		privatevariable=v;
	}

	void Setlocalvariable() {
		localvariable=true;
	}
	
	bool Localvariable() {
		return localvariable;
	}
		
	Exported bool Private() {
		return privatevariable;
	}
	
	Exported short Name() {
		return name;
	}
	bool Variable() {
		return true;
	}

	Exported KifType inType() {
		return value->inType();
	}

	Exported KifElement* Atom() {
		return value->Atom();
	}
	
	virtual Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		KifVariable* var=new KifVariable(kifcode,(KifElement*)kp,value->Copy(kp),name);
		if (value!=var->value)
			var->value->Setreference();
		return var;
	}
	virtual Exported void callfunction(KifElement* a,KifElement* b,KifDomain* dom) {}
	Exported bool Setvalue(KifElement* k,KifElement* index,KifElement* dom);
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke=NULL,bool rcouple=false);
	KifElement* Returnvalue() {
		return value;
	}



	Exported void Clean() {
		KifElement::Resetreference();
		//value->Clean();
	}

	Exported void Clear() {
		//value->Clear();
	}

	Exported void Setreference() {
		reference++;
		value->Setreference();
	}

	Exported void Setpopped() {
		popped=true;
		value->Setpopped();
	}

	Exported void Resetreference() {		
		if (popped==true)
			value->popped=popped;
		value->Resetreference();
		KifElement::Resetreference();
	}

	Exported string String() {
		return value->String();
	}
	Exported long Integer() {
		return value->Integer();
	}
	Exported double Float() {
		return value->Float();
	}
	Exported bool Boolean() {
		return value->Boolean();
	}



	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself) {
		return value->plus(value,b,autoself);
	}
	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself) {
		return value->minus(value,b,autoself);
	}
	Exported KifElement* multiply(KifElement* a,KifElement* b,bool autoself) {
		return value->multiply(value,b,autoself);
	}
	Exported KifElement* divide(KifElement* a,KifElement* b,bool autoself) {
		return value->divide(value,b,autoself);
	}
	Exported KifElement* mod(KifElement* a,KifElement* b,bool autoself) {
		return value->mod(value,b,autoself);
	}
	Exported KifElement* shiftright(KifElement* a,KifElement* b,bool autoself) {
		return value->shiftright(value,b,autoself);
	}
	Exported KifElement* shiftleft(KifElement* a,KifElement* b,bool autoself) {
		return value->shiftleft(value,b,autoself);
	}
	Exported KifElement* power(KifElement* a,KifElement* b,bool autoself) {
		return value->power(value,b,autoself);
	}

	Exported KifElement* less(KifElement* a) {
		return value->less(a);
	}

	Exported KifElement* more(KifElement* a) {
		return value->more(a);
	}

	Exported KifElement* same(KifElement* a) {
		return value->same(a);
	}

	Exported KifElement* different(KifElement* a) {
		return value->different(a);	
	}

	Exported KifElement* lessequal(KifElement* a) {
		return value->lessequal(a);
	}

	Exported KifElement* moreequal(KifElement* a) {
		return value->moreequal(a);
	}

	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
		if (kfunc==NULL)
			return value->in(a,b,NULL,this,idx);
		return applyfunc(a,b,kfunc);
	}
};

class KifVariableFunction : public KifVariable {
public:
	KifElement* function;
	KifVariableFunction(KifCode* klc,KifElement* kp,KifElement* v,KifElement* func,short n) : KifVariable(klc,kp,v,n) {
		function=func;
	}

	bool Function() {
		if (function==NULL)
			return false;
		return true;
	}

	virtual Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		KifVariableFunction* var=new KifVariableFunction(kifcode,(KifElement*)kp,value->Copy(kp),function,name);
		if (value!=var->value)
			var->value->Setreference();
		return var;
	}
	KifElement* Returnfunction() {
		return function;
	}
	Exported void callfunction(KifElement* a,KifElement* b,KifDomain* dom) {		
		applyfuncvariable(this,a,b,(KifDomain*)function->Functioncall(dom));
	}
};

class KifVariableFrame : public KifVariable {
public:
	KifDomain* frame;

	KifVariableFrame(KifCode* klc,KifElement* kp,KifElement* v,short n) : KifVariable(klc,kp,v,n) {
		frame=NULL;
	}
	void  Setframe(KifElement* fr) {
		frame=(KifDomain*)fr;
	}

	KifElement* Frame() {
		return (KifElement*)frame;
	}
};

class KifVariableFrameFunction : public KifVariableFrame {
public:
	KifElement* function;
	
	KifVariableFrameFunction(KifCode* klc,KifElement* kp,KifElement* v,KifElement* func,short n) : KifVariableFrame(klc,kp,v,n) {
		function=func;
	}

	bool Function() {
		if (function==NULL)
			return false;
		return true;
	}

	virtual Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		KifVariableFrameFunction* var=new KifVariableFrameFunction(kifcode,(KifElement*)kp,value->Copy(kp),function,name);
		if (value!=var->value)
			var->value->Setreference();
		return var;
	}
	KifElement* Returnfunction() {
		return function;
	}

	Exported void callfunction(KifElement* a,KifElement* b,KifDomain* dom) {		
		applyfuncinframe(this,(KifElement*)frame,a,b,(KifDomain*)function->Functioncall(dom));
	}

};

class KifCouple : public KifElement {
public:	
	KifIndex* indexes;
	KifElement* recipient;
	KifDomain* domain;

	KifCouple(KifCode* klc,KifElement* rec,KifIndex* i,KifDomain* dom) : KifElement(klc,NULL,kifCouple) {
		indexes=i;
		recipient=rec;
		domain=dom;
	}

	Exported bool Setvalue(KifElement* k,KifElement* index=NULL,KifElement* dom=NULL);
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke=NULL,bool rcouple=false);

	Exported string Type();

	Exported string String() {
		KifElement* ke=Execute(this,domain,kifNULL,false);
		return ke->String();
	}
	Exported long Integer() {
		KifElement* ke=Execute(this,domain,kifNULL,false);
		return ke->Integer();
	}
	Exported double Float() {
		KifElement* ke=Execute(this,domain,kifNULL,false);
		return ke->Float();
	}
	Exported bool Boolean() {
		KifElement* ke=Execute(this,domain,kifNULL,false);
		return ke->Boolean();
	}	

	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself) {
		if (a->type==kifCouple)
			a=a->Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->plus(a,b,autoself);
	}
	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself) {
		if (a->type==kifCouple)
			a=a->Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->minus(a,b,autoself);
	}
	Exported KifElement* multiply(KifElement* a,KifElement* b,bool autoself) {
		if (a->type==kifCouple)
			a=a->Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->multiply(a,b,autoself);
	}
	Exported KifElement* divide(KifElement* a,KifElement* b,bool autoself) {
		if (a->type==kifCouple)
			a=a->Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->divide(a,b,autoself);
	}
	Exported KifElement* mod(KifElement* a,KifElement* b,bool autoself) {
		if (a->type==kifCouple)
			a=a->Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->mod(a,b,autoself);
	}
	Exported KifElement* shiftleft(KifElement* a,KifElement* b,bool autoself) {
		if (a->type==kifCouple)
			a=a->Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->mod(a,b,autoself);
	}
	Exported KifElement* shiftright(KifElement* a,KifElement* b,bool autoself) {
		if (a->type==kifCouple)
			a=a->Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->mod(a,b,autoself);
	}
	Exported KifElement* power(KifElement* a,KifElement* b,bool autoself) {
		if (a->type==kifCouple)
			a=a->Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->power(a,b,autoself);
	}
	Exported KifElement* less(KifElement* b) {
		KifElement* a=Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->less(b);
	}
	Exported KifElement* more(KifElement* b) {
		KifElement* a=Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->more(b);
	}
	Exported KifElement* same(KifElement* b) {
		KifElement* a=Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->same(b);
	}
	Exported KifElement* different(KifElement* b) {
		KifElement* a=Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->different(b);
	}

	Exported KifElement* lessequal(KifElement* b) {
		KifElement* a=Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->lessequal(b);
	}
	Exported KifElement* moreequal(KifElement* b) {
		KifElement* a=Execute(kifNULL,domain,kifNULL,false);
		if (b->type==kifCouple)
			b=b->Execute(kifNULL,domain,kifNULL,false);
		return a->moreequal(b);
	}	
};

class KifConst : public KifElement {
public:
	short name; //can be a frame as well
	KifElement* value;

	KifConst(KifCode* klc,KifElement* kp,short n);

	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		return this;
	}
	Exported void Setreference() {}
	Exported void Setpopped() {}
	Exported void Clean() {}
	Exported void Resetreference() {}
	Exported bool Setvalue(KifElement* k,KifElement* index,KifElement* dom) {return false;}
	Exported KifElement* Newinstance() {
		return this;
	}
	
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false) {
		return this;
	}

	Exported string Type();

	Exported void Add(KifElement* ke) {
		value=ke;
		value->Setreference();
	}
	Exported short Name() {
		return name;
	}

	virtual KifElement* Returnvalue() {
		return value;
	}

	KifElement* Linkedvalue() {
		return value;
	}

	bool Variable() {
		return true;
	}

	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself) {
		if (a->type<=kifnull)
			return kifNULL;
		return a->plus(a,b,autoself);
	}
	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself) {
		if (a->type<=kifnull)
			return kifNULL;
		return a->minus(a,b,autoself);
	}
	Exported KifElement* multiply(KifElement* a,KifElement* b,bool autoself) {
		if (a->type<=kifnull)
			return kifNULL;
		return a->multiply(a,b,autoself);
	}
	Exported KifElement* divide(KifElement* a,KifElement* b,bool autoself) {
		if (a->type<=kifnull)
			return kifNULL;
		return a->divide(a,b,autoself);
	}
	Exported KifElement* mod(KifElement* a,KifElement* b,bool autoself) {
		if (a->type<=kifnull)
			return kifNULL;
		return a->mod(a,b,autoself);
	}
	Exported KifElement* shiftright(KifElement* a,KifElement* b,bool autoself) {
		if (a->type<=kifnull)
			return kifNULL;
		return a->shiftright(a,b,autoself);
	}
	Exported KifElement* shiftleft(KifElement* a,KifElement* b,bool autoself) {
		if (a->type<=kifnull)
			return kifNULL;
		return a->shiftleft(a,b,autoself);
	}
	Exported KifElement* power(KifElement* a,KifElement* b,bool autoself) {
		if (a->type<=kifnull)
			return kifNULL;
		return a->power(a,b,autoself);
	}
	Exported KifElement* orset(KifElement* a,KifElement* b,bool autoself) {
		if (a->type<=kifnull)
			return kifNULL;
		return a->orset(a,b,autoself);
	}

	Exported KifElement* xorset(KifElement* a,KifElement* b,bool autoself) {
		if (a->type<=kifnull)
			return kifNULL;
		return a->xorset(a,b,autoself);
	}

	Exported KifElement* andset(KifElement* a,KifElement* b,bool autoself) {
		if (a->type<=kifnull)
			return kifNULL;
		return a->andset(a,b,autoself);
	}
};

class KifThis : public KifElement {
public:

	KifThis(KifCode* klc,KifElement* kp) : KifElement(klc,kp,kifthis) {}


	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		KifElement* ke=new KifThis(kifcode,(KifElement*)kp);
		return ke;
	}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple);
};


//A basic variable declaration is of type: KifType
class KifVariableDeclaration : public KifElement {
public:
	short name; //can be a frame as well
	KifElement* value;
	KifElement* initialisation;
	bool xip;
	long line;
	KifElement* function;
	bool privatevariable;

	long Line() {return line;}
	void Setline(long l) {line=l;}

	KifVariableDeclaration(KifCode* klc,KifElement* kp,short n,KifType kt=kifVariableDeclaration) : KifElement(klc,kp,kt) {
		privatevariable=false;
		value=kifNULL;		
		name=n;
		line=-1;
		initialisation=kifNULL;
		xip=false;
		function=NULL;
	}

	KifVariableDeclaration(KifCode* klc,KifElement* kp,string n,KifType kt=kifVariableDeclaration);

	void Setprivate(bool v) {
		privatevariable=v;
	}
	Exported bool Private() {
		return privatevariable;
	}

	bool XIP() {
		return xip;
	}
	virtual Exported bool Setvalue(KifElement* k,KifElement* index,KifElement* dom);
	Exported string Type();
	void Setinitialisation(KifElement* ke) {
		if (ke!=NULL)
			initialisation=ke;
	}
	virtual KifElement* Returnfunction() {
		return function;
	}
	void Setfunction(KifElement* f) {
		function=f;
	}
	Exported void Add(KifElement* ke) {
		value=ke;
		value->Setreference();
	}
	Exported short Name() {
		return name;
	}

	virtual KifElement* Returnvalue() {
		return value;
	}

	KifElement* Linkedvalue() {
		return value;
	}

	bool Variable() {
		return true;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);	
	virtual Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL);
	KifElement* Initialisation() {
		return initialisation;
	}
};



class KifFrameDeclaration : public KifVariableDeclaration {
public:
	KifElement* frame;
	bool postpone;
	KifFrameDeclaration(KifCode* klc,KifElement* kp,short n,KifElement* d) : KifVariableDeclaration(klc,kp,n,kifFrameDeclaration) {
		frame=d;
		postpone=false;
	}

	void Setpostpone(bool v) {
		postpone=true;
	}

	bool Postpone() {
		return postpone;
	}

	KifElement* Domain() {
		return frame;
	}
	KifElement* Frame() {
		return frame;
	}
	Exported bool Setvalue(KifElement* k,KifElement* index,KifElement* dom) {return false;}
	KifElement* Returnvalue() {return kifNULL;}
	virtual Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL);
};

class KifFrameDeclarationCommon : public KifFrameDeclaration {
public:
	KifElement* variable;
	
	KifFrameDeclarationCommon(KifCode* klc,KifElement* kp,short n,KifElement* d) : KifFrameDeclaration(klc,kp,n,d) {
		variable=NULL;
	}
	
	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		if (variable==NULL) {
			variable=KifFrameDeclaration::Copy(kp,dom);
			variable->Setreference();
		}
		return variable;
	}
};


class KifFunctionDeclaration : public KifVariableDeclaration {
public:
	KifElement* domain;
	KifFunctionDeclaration(KifCode* klc,KifElement* kp,short n,KifElement* d) : KifVariableDeclaration(klc,kp,n,kifFunctionDeclaration) {
		domain=d;
	}
	KifElement* Domain() {
		return domain;
	}
	Exported bool Setvalue(KifElement* k,KifElement* index,KifElement* dom) {return false;}
	KifElement* Returnvalue() {return kifNULL;}
};

//====================================================================================
class KifCall : public KifElement {
public:
	KifFunction* body;
	KifDomain* domain;


	KifCall(KifCode* klc,KifElement* kp,KifFunction* b) : KifElement(klc,kp,kifCall) {
		body=b;
		domain=NULL;
	}

	KifFunction* Functioncall(KifDomain* dom) {
		return body;
	}

	Exported KifElement* Atom() {
		if (body==NULL)
			return kifNULL;
		return (KifElement*)body;
	}

	Exported string String();

	Exported bool Setvalue(KifElement* val,KifElement* idx,KifElement* dom);
	Exported KifElement* Copy(KifDomain* dom,KifElement* decl=kifNULL) {
		return this;
	}

	bool Variable() {
		return true;
	}

	bool Basic() {
		return true;
	}

	Exported KifElement* Newinstance() {
		return new KifCall(kifcode,NULL,NULL);
	}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
	Exported KifElement* same(KifElement* a) {
		
		if (a==kifNULL) {
			if (body==NULL)
				return kifTRUE;
			return kifNULL;
		}

		if (a->type==kifCall) {
			if (body==((KifCall*)a)->body)
				return kifTRUE;
			return kifFALSE;
		}
		if (a==(KifElement*)body)
			return kifTRUE;
		return kifFALSE;
	}
};
//=======================================================================================
class KifInstanceCommon : public KifElement {
public:
	short name;
	KifVariableDeclaration* declaration;
	long line;
	string keyvalue;
	KifOrigin newinstance;
	KifElement* current_value;

	long Line() {return line;}
	void Setline(long l) {line=l;}

	KifInstanceCommon(KifCode* klc,KifElement* kp,short n,KifVariableDeclaration* d) : KifElement(klc,kp,kifInstance) {
		declaration=d;
		name=n;
		line=-1;
		current_value=NULL;
		newinstance=kinUnknown;
	}
	
	virtual void Initvalue(KifElement* ke) {}
	virtual void Setself() {};
	Exported short Name() {return name;}

	Exported KifElement* Declaration(short name) {
		return declaration->value->Declaration(name);
	}

	Exported KifElement*  Linkedvalue() {
		return declaration->value;
	}

	string Keyvalue() {
		return keyvalue;
	}

	void Setstringvalue(string& k) {
		keyvalue=k;
	}
	Exported virtual string Type() {	
		return "";
	}
};

//This class is used when a variable is in an expression
class KifInstance : public KifInstanceCommon {
public:
	//The domain is its type either in a frame or in a function
	KifElement* value;
	KifIndex* index;
	KifCouple* couple;
	KifCouple* bcouple;
	bool self;

	KifInstance(KifCode* klc,KifElement* kp,short n,KifVariableDeclaration* d) : KifInstanceCommon(klc,kp,n,d) {
		couple=NULL;
		bcouple=NULL;
		if (d!=NULL)
			value=d->value;
		index=NULL;
		self=false;
	}

	KifInstance(KifCode* klc,KifElement* kp,string n,KifVariableDeclaration* d);

	Exported KifElement* Evalue(KifElement* contextualpattern,KifDomain* dom);
	KifElement* Thevariable(KifDomain* dom);
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple);
	KifFunction* Functioncall(KifDomain* dom) {
		KifElement* call=Evalue(kifNULL,dom);
		return ((KifCall*)call)->body;
	}


	Exported string Type() {	
		if (value!=NULL)
			return value->Type();
		return "";
	}

	Exported KifType inType();

	void Initvalue(KifElement* ke) {
		if (ke->type==kifIndex) {
			index=(KifIndex*)ke;
			couple=new KifCouple(kifcode,kifNULL,index,NULL);
			bcouple=couple;
		}
		else
			value=ke;
	}
	
	Exported KifElement* Linkedvalue() {
		if (value->type==kifInstance)
			return value->Linkedvalue();
		return value;
	}

	void Setself() {
		self=true;
	}
};

class KifInstanceFunction : public KifInstanceCommon {
public:
	KifCallFunction* function;

	KifInstanceFunction(KifCode* klc,KifElement* kp,short n,KifVariableDeclaration* d) : KifInstanceCommon(klc,kp,n,d) {
		function=NULL;
		type=kifInstanceFunction;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple);
	
	void Initvalue(KifElement* ke) {
		function=(KifCallFunction*)ke;
	}

	Exported string Type() {	
		return "kifCallFunction";
	}
	Exported KifType inType();
};

class KifObject : public KifElement {
public:

	long line;
	bool adding;

	long Line() {return line;}
	void Setline(long l) {line=l;}

	KifObject(KifCode* klc,KifElement* kp,KifType k=kifAny) : KifElement(klc,kp,k) {
		line=-1;
		type=k;
		adding=true;
	}

	void Disableadding() {
		adding=false;
	}	
};


class KifValue {
public:
	char type;
	KifValue() {
		type=0;
	}
};

class KifIntegerValue : public KifValue {
public:
	long value;
	KifIntegerValue(long v) {
		value=v;
		type=ckifInteger;
	}
};

class KifFloatValue : public KifValue {
public:
	double value;
	KifFloatValue(double v) {
		value=v;
		type=ckifFloat;
	}
};

class KifStringValue : public KifValue {
public:
	string value;
	KifStringValue(string v) {
		value=v;
		type=ckifString;
	}
};

class KifComputeValue : public KifValue {
public:
	KifInstanceCommon* base;
	KifValue* value;
	KifInstructionType instructiontype;
	KifComputeValue(KifElement* v,KifInstructionType i) {		
		if (v->type==kifInstance)
			base=(KifInstance*)v;
		else
			base=(KifInstanceFunction*)v;
		type=ckifInstance;
		instructiontype=i;
		switch(instructiontype) {
		case kifFULLSTRING:
			value=new KifStringValue("");
			break;
		case kifFULLINTEGER:
			value=new KifIntegerValue(0);
			break;
		default:
			value=new KifFloatValue(0);
		}
	}

	void Execute(KifDomain* dom);

	~KifComputeValue() {
		delete value;
	}
};


class KifNumber {
public:
	KifValue* value;
	char type;
	KifChild* child;
	KifNumber() {
		value=NULL;
		type=0;
		child=NULL;
	}
	void Append(KifChild* k) {
		child=k;
	}
	~KifNumber();
};


class KifChild {
public:
	KifOperator op;
	VECTA<KifNumber*> values;
	KifInstructionType instructiontype;
	KifChild(KifInstructionType i) {
		instructiontype=i;
	}
	double ExecuteFloat();
	long ExecuteInteger();
	void ExecuteString(string&);
	void Append(KifNumber* k) {
		values.push_back(k);
	}

	~KifChild() {
		for (int i=0;i<values.size();i++) {
			if (values[i]->type!=3)
				delete values[i];
		}
	}
};

class KifRoot {
public:	
	hmap<short,KifComputeValue*> declarations;

	KifChild* child;
	KifInstructionType instructiontype;
	KifElement* returnvalue;
	KifElement* ExecuteFloat(KifDomain*);
	KifElement* ExecuteInteger(KifDomain*);
	KifElement* ExecuteString(KifDomain*,string&);
	KifRoot(KifCode* kifcode,KifInstructionType i) {
		child=NULL;
		instructiontype=i;
		if (instructiontype==kifFULLINTEGER)
			returnvalue=new KifInteger(NULL,NULL,0);
		else
			if (instructiontype==kifFULLFLOAT)
				returnvalue=new KifFloat(NULL,NULL,0);
			else
				returnvalue=new KifBaseString(NULL,NULL,"");
		returnvalue->kifcode=kifcode;
	}
	~KifRoot() {
		if (child !=NULL)
			delete child;
		hmap<short,KifComputeValue*>::iterator it;
		for (it=declarations.begin();it!=declarations.end();it++)
			delete it->second;
		delete returnvalue;
	}
};


class KifObjectInstruction : public KifObject {
public:
	vector<KifElement*> instructions;	
	KifInstructionType instructiontype;

	KifObjectInstruction(KifCode* klc,KifElement* kp,KifType ktype=kifAny) : KifObject(klc,kp,ktype) {
		instructiontype=kifNOTYPE;
	}

	int InstructionSize() {
		return instructions.size();
	}
	

	KifElement* Lastinstruction() {
		if (instructions.size()==0)
			return kifNULL;
		return instructions[instructions.size()-1];
	}

	KifElement* Instruction(int i) {
		return instructions[i];
	}
	void Addinstruction(int i,KifElement* ke);
	void InstructionClear() {
		instructions.clear();
	}
	
	KifElement* InstructionRemoveLast() {
		if (instructions.size()==0)
			return kifNULL;
		KifElement* ret=instructions[instructions.size()-1];
		instructions.pop_back();
		return ret;
	}

	Exported void Add(KifElement* k);
};


class KifInstructionFOR : public KifObjectInstruction {
public:
	KifInstructionFOR(KifCode* klc,KifElement* kp) : KifObjectInstruction(klc,NULL,kifInstruction) {
		if (kp!=NULL)
			kp->Add(this);
		type=kifInstructionFOR;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
};


class KifInstructionTRY : public KifObjectInstruction {
public:
	KifInstructionTRY(KifCode* klc,KifElement* kp) : KifObjectInstruction(klc,NULL,kifInstruction) {
		if (kp!=NULL)
			kp->Add(this);
		type=kifInstructionTRY;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
};

class KifInstructionSWITCH : public KifObjectInstruction {
public:
	KifInstructionSWITCH(KifCode* klc,KifElement* kp) : KifObjectInstruction(klc,NULL,kifInstruction) {
		if (kp!=NULL)
			kp->Add(this);
		type=kifInstructionSWITCH;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
};

class KifInstructionIF : public KifObjectInstruction {
public:
	KifInstructionIF(KifCode* klc,KifElement* kp) : KifObjectInstruction(klc,NULL,kifInstruction) {
		if (kp!=NULL)
			kp->Add(this);
		type=kifInstructionIF;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
};

class KifInstruction : public KifObjectInstruction {
public:
	KifOperator action;
	KifElement* parent;	
	bool negation;
	KifRoot* root;

	KifInstruction(KifCode* klc,KifElement* kp,KifOperator kop=kifNONE);

	KifChild* BuildNumericalExpression(char);

	Exported void Set(short s,KifElement* k,hmap<short,KifElement*>* stacks);
	virtual Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
	Exported KifElement* Evalue(KifElement* contextualpattern,KifDomain* dom);

	bool Negation() {
		return negation;
	}

	inline KifElement* INITIALISATION(KifDomain* dom,KifElement* ke);
	inline KifElement* AFFECTATION(KifDomain* dom);

	inline KifElement* BLOCBOOLEAN(KifElement* contextualpattern,KifDomain* dom);

	inline KifElement* PLUSPLUS(KifDomain* dom);
	inline KifElement* MINUSMINUS(KifDomain* dom);
		
	KifElement* APPLYOPERATION(KifElement* contextualpattern,KifDomain* dom);
	KifElement* APPLYOPERATIONEQU(KifDomain* dom);
	KifElement* KIFEQU(KifDomain* dom);


	inline KifElement* KIFIN(KifElement* contextualpattern,KifDomain* dom);
	
	inline KifElement* COMPARE(KifDomain* dom);

	inline KifElement* OR(KifDomain* dom);
	inline KifElement* AND(KifDomain* dom);


	inline KifElement* XInteger(KifDomain* dom);
	inline KifElement* XFloat(KifDomain* dom);
	inline KifElement* XString(KifDomain* dom);

	inline void Setaction(KifOperator a) {
		action=a;
	}

	inline KifOperator Action() {
		return action;
	}

	inline KifElement* Parent() {
		return parent;
	}

	void Setnegation(bool v) {
		negation=v;
	}

	void Addparent(KifElement* p);
	~KifInstruction() {
		if (root!=NULL)
			delete root;
	}
};

class KifInstructionPARAMETER : public KifInstruction {
public:
	KifInstructionPARAMETER(KifCode* klc,KifElement* kp) : KifInstruction(klc,NULL) {
		if (kp!=NULL)
			kp->Add(this);
		type=kifInstructionPARAMETER;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
};


class KifDomain : public KifObject {
public:

	hmap<short,KifElement*> declarations;
	short name;
	KifElement* frame;
	short delayed;
	bool postpone;

	KifDomain(KifCode* klc,KifElement* kp,short n,KifType t) : KifObject(klc,kp,t) {
		name=n;
		frame=kifNULL;
		delayed=0;
		postpone=false;
	}

	virtual bool Basic() {
		return true;
	}

	void Setpostpone(bool v) {
		postpone=v;
	}

	bool Postpone() {
		return postpone;
	}

	short Delayed() {
		return delayed;
	}
	
	virtual bool PredefinedVariableFunction() {
		return false;
	}
	void Setdelayed() {
		delayed++;
	}

	void Resetdelayed() {
		delayed--;
	}

	void ApplyDelayedInitial();

	void  Setframe(KifElement* fr) {
		frame=fr;
	}

	virtual KifFrame* ParentFrame() {
		return NULL;
	}
	
	KifElement* ExecuteMethod(short name,KifElement* contextualpattern,KifDomain* domain,KifCallFunction* func) {
		if (frame!=NULL)
			return frame->ExecuteMethod(name,contextualpattern,this,func);
		return kifNULL;
	}

	Exported KifElement* Newinstance() {
		KifDomain* ke=new KifDomain(kifcode,NULL,name,type);
		ke->frame=frame;
		return ke;
	}

	virtual Exported KifElement* Declaration(short s);
	Exported KifElement* Declared(short s);

	Exported void Methods(KifVector* fcts);

	Exported void Setdeclaration(short n,KifElement* ke,hmap<short,KifElement*>* stacks) {
		ThreadLock _lock(type);
		KifElement* kdec=Declared(n);
		if (kdec==ke)
			return;

		if (stacks!=NULL) {
			(*stacks)[n]=kdec;
			ke->Setreference();
		}
		else
			ke->reference++;

		declarations[n]=ke;
	}

	Exported void Setdeclaration(string n,KifElement* ke,hmap<short,KifElement*>* stacks);
	KifElement* applycomparatorfunction(KifElement* a,KifElement* b,KifFunction* func);

	Exported void Resetdeclaration(hmap<short,KifElement*>& stacks) {
		ThreadLock _lock(type);
		if (stacks.size()==0)
			return;
		hmap<short,KifElement*>::iterator it;
		short n;
		for (it=stacks.begin();it!=stacks.end();it++) {
			n=it->first;
			if (Declaration(n)!=NULL)
				declarations[n]->Resetreference();
			if (it->second==NULL)
				declarations.erase(n);
			else
				declarations[n]=it->second;
		}
	}

	Exported short Name() {return name;}

	virtual Exported string Type() {
		return frame->Type();
	}

	bool isDomain() {return true;}

	virtual Exported KifElement* Copy(KifDomain* dom,KifElement* decl=kifNULL);
	
	Exported void SetInstances(KifElement* dom,hmap<short,KifElement*>* stacks) {
		hmap<short,KifElement*>::iterator it;
		dom->Disableadding();
		for (it=declarations.begin();it!=declarations.end();it++) {
			KifElement* xe=it->second->Copy(this,it->second);
			dom->Setdeclaration(it->first,xe,stacks);
		}
	}	

	void SetInstanceslocal(KifElement* dom,hmap<short,KifElement*>* stacks);
	virtual Exported void Clean();
	virtual Exported void Clear();
	virtual Exported void Setreference();
	virtual Exported void Setpopped();
	virtual Exported void Resetreference();
	Exported KifElement* Vector(KifElement*);
	Exported KifElement* Map(KifElement*);

	virtual Exported bool Setvalue(KifElement* ke,KifElement* idx=NULL,KifElement* dom=NULL);

	Exported void Sharedeclaration(KifDomain* k);

	KifElement*  Frame() {
		return frame;
	}
	Exported KifElement* Framedefined(short met,KifElement* contextualpattern,KifDomain* dom);
	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx);
	Exported KifElement* applycomparison(short ,KifElement* a);
	KifElement* applyincrement(short na);
	Exported KifElement* applyoperation(short ,KifElement* a,KifElement* b);
	Exported KifElement* applyinitial(KifDomain*,KifElement*);
	Exported bool initialapplyied() {return true;}

	virtual Exported long Size() {
		KifElement* ke=Framedefined(idsize,kifcode->kifTypeINTEGER,this);
		return ke->Integer();
	}

	Exported string String() {
		KifElement* ke=Framedefined(idstring,kifcode->kifTypeSTRING,this);
		return ke->String();
	}

	Exported long Integer() {
		KifElement* ke=Framedefined(idint,kifcode->kifTypeINTEGER,this);
		return ke->Integer();
	}
	Exported double Float() {
		KifElement* ke=Framedefined(idfloat,kifcode->kifTypeFLOAT,this);
		return ke->Float();
	}
	Exported bool Boolean() {
		KifElement* ke=Framedefined(idboolean,kifcode->kifTypeBOOLEAN,this);
		return ke->Boolean();
	}

	Exported KifFraction* Fraction() {
		KifElement* ke=Framedefined(idfraction,kifcode->kifTypeBOOLEAN,this);
		return ke->Fraction();
	}

	Exported KifElement* less(KifElement* a) {
		return applycomparison(idinferior,a);
	}
	Exported KifElement* more(KifElement* a) {
		return applycomparison(idsuperior,a);
	}

	Exported KifElement* same(KifElement* a) {
		if (a==kifNULL) {
			if (declarations.size()==0)
				return kifTRUE;
			return kifFALSE;
		}

		if (a->Frame()!=frame)
			return kifFALSE;
		KifElement* func=Declaration(idequal);

		if (func==NULL) {
			if (a==this)
				return kifTRUE;
			return kifFALSE;
		}			
		return applycomparison(idequal,a);
	}

	Exported KifElement* different(KifElement* a) {
		if (a->Frame()!=frame)
			return kifTRUE;

		KifElement* func=Declaration(iddifferent);
		if (func==NULL) {
			if (a!=this)
				return kifTRUE;
			return kifFALSE;
		}			
		return applycomparison(iddifferent,a);
	}

	Exported KifElement* lessequal(KifElement* a) {
		return applycomparison(idinferiorequal,a);
	}
	Exported KifElement* moreequal(KifElement* a) {
		return applycomparison(idsuperiorequal,a);
	}

	void plusplus() {
		applyincrement(idplusplus);
	}
	
	void minusminus() {
		applyincrement(idminusminus);
	}

	Exported KifElement* orset(KifElement* a,KifElement* b,bool autoself) {
		return applyoperation(idorset,a,b);
	}

	Exported KifElement* xorset(KifElement* a,KifElement* b,bool autoself) {
		return applyoperation(idxorset,a,b);
	}
	
	Exported KifElement* andset(KifElement* a,KifElement* b,bool autoself) {
		return applyoperation(idandset,a,b);
	}

	Exported KifElement* plus(KifElement* a,KifElement* b,bool autoself) {
		return applyoperation(idplus,a,b);
	}

	Exported KifElement* minus(KifElement* a,KifElement* b,bool autoself) {
		return applyoperation(idminus,a,b);
	}

	Exported KifElement* multiply(KifElement* a,KifElement* b,bool autoself) {
		return applyoperation(idmultiply,a,b);
	}

	Exported KifElement* divide(KifElement* a,KifElement* b,bool autoself) {
		return applyoperation(iddivide,a,b);
	}

	Exported KifElement* mod(KifElement* a,KifElement* b,bool autoself) {
		return applyoperation(idmod,a,b);
	}
	Exported KifElement* shiftright(KifElement* a,KifElement* b,bool autoself) {
		return applyoperation(idshiftright,a,b);
	}
	Exported KifElement* shiftleft(KifElement* a,KifElement* b,bool autoself) {
		return applyoperation(idshiftleft,a,b);
	}
	Exported KifElement* power(KifElement* a,KifElement* b,bool autoself) {
		return applyoperation(idpower,a,b);
	}

	virtual Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);

	virtual Exported void Set(short s,KifElement* k,hmap<short,KifElement*>* stacks) {
		ThreadLock _lock(type);
		Setdeclaration(s,k,stacks);
	}
};

class KifDomainInstruction : public KifDomain {
public:
	vector<KifElement*> instructions;

	KifDomainInstruction(KifCode* klc,KifElement* kp,short n,KifType t) : KifDomain(klc,kp,n,t) {}

	Exported virtual void Add(KifElement* ke) {
		if (adding)
			instructions.push_back(ke);
	}

	int InstructionSize() {
		return instructions.size();
	}

	KifElement* Lastinstruction() {
		if (instructions.size()==0)
			return kifNULL;
		return instructions[instructions.size()-1];
	}

	KifElement* InstructionRemoveLast() {
		if (instructions.size()==0)
			return kifNULL;
		KifElement* ret=instructions[instructions.size()-1];
		instructions.pop_back();
		return ret;
	}

	void InstructionClear() {
		instructions.clear();
	}

	KifElement* Instruction(int i) {
		return instructions[i];
	}
	void Addinstruction(int i,KifElement* ke) {
		if (i<instructions.size())
			instructions[i]=ke;		
		else
			instructions.push_back(ke);		
	}
};

class KifInstructionSEQUENCE : public KifDomainInstruction {
public:
	KifInstructionSEQUENCE(KifCode* klc,KifElement* kp,short n) : KifDomainInstruction(klc,kp,n,kifInstructionSEQUENCE) {
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
};

class KifInstructionCATCH : public KifInstructionSEQUENCE {
public:
	KifInstructionCATCH(KifCode* klc,KifElement* kp) : KifInstructionSEQUENCE(klc,kp,idcatch) {}
	KifOperator Action() {
		return kifCATCHBLOC;
	}

};


//Next is the basic Kif instruction: KifFunction
class KifFunction : public KifDomainInstruction {
public:
	vector<KifElement*> arguments;
	KifFunction* next;
	char choice;
	bool autorun;
	bool privatefunction;
	bool strict;
	bool used;
	bool nonlimited;

	KifFunction(KifCode* klc,KifElement* kp,short n,KifType ktype=kifFunction) : KifDomainInstruction(klc,kp,n,ktype) {
		privatefunction=false;
		nonlimited=false;
		used=false;
		strict=false;
		next=NULL;
		choice=0;
		autorun=false;
		line=0;
		declarations[name]=this;
		if (kp!=NULL && kp->type==kifFrame)
			frame=kp;
	}

	Exported bool Unlimited() {
		return nonlimited;
	}

	Exported void Setlimited(bool l);

	Exported string String();
	Exported string Type();
	bool Autorun() {
		return autorun;
	}

	KifFunction* Functioncall(KifDomain*) {
		return this;
	}

	Exported bool Private() {
		return privatefunction;
	}
	bool Basic() {
		return false;
	}
	
	bool Predeclared() {
		if (choice==2)
			return true;
		return false;
	}

	bool isFunction() {
		return true;
	}
	
	void Setused() {
		used=true;
	}

	bool isUsed() {
		return used;
	}

	void Addfunction(KifFunction* kfunc) {
		KifFunction* n=this;
		while (n->next!=NULL)
			n=n->next;
		n->next=kfunc;
	}

	
	Exported long Size() {
		return arguments.size();
	}

	Exported KifElement* Declaration(short s) {
		hmap<short,KifElement*>::iterator iter=declarations.find(s);
		if (iter==declarations.end())
			return NULL;
		return iter->second;
	}

	Exported void Add(KifElement* ke);

	Exported bool Setvalue(KifElement* ke,KifElement* idx=NULL,KifElement* dom=NULL) {
		return true;
	}
	virtual Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
	Exported KifElement* Copy(KifDomain* dom,KifElement* decl=kifNULL) {
		return this;
	}
	Exported void Clean() {}
	Exported void Setreference() {}
	Exported void Setpopped() {}
	Exported void Resetreference() {}
	virtual void StoreResult(string& s,KifElement* res) {}
	virtual KifElement* ReturnResult(string& s) {return NULL;}
	KifElement* Argument(int i) {
		if (i>=0 && i<arguments.size())
			return arguments[i];
		return NULL;
	}
};


class KifFunctionSynchronous : public KifFunction {
public:
	KifFunctionSynchronous(KifCode* klc,KifElement* kp,short n) : KifFunction(klc,kp,n,kifFunction) {}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
	bool PredefinedVariableFunction() {
		return true;
	}
};

class KifPolynomial : public KifFunction {
public:
	hmap<string,KifElement*> results;
	KifPolynomial(KifCode* klc,KifElement* kp,short n) : KifFunction(klc,kp,n,kifPolynomial) {}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
	void StoreResult(string& s,KifElement* res) {
		results[s]=res;
		res->Setreference();
	}

	KifElement* ReturnResult(string& s) {
		hmap<string,KifElement*>::iterator it=results.find(s);
		if (it!=results.end())
			return it->second;
		return NULL;
	}
};


class KifCallFunction : public KifDomain {
public:
	KifCallFunction* function;
	vector<KifElement*> parameters;
	KifElement* returnvalue;
	bool selfinsert;
	bool isreturned;
	char add;
	KifElement* environment;
	KifSelf* kbloc;
	int threadid;

	KifCallFunction(KifCode* klc,KifElement* kp,short n) : KifDomain(klc,kp,n,kifCallFunction) {
		threadid=-1;
		line=-1;
		kbloc=NULL;
		function=NULL;
		environment=kifNULL;
		returnvalue=kifNULL;
		add=1;
		selfinsert=false;
		isreturned=false;
	}

	int Threadid() {
		return threadid;
	}


	virtual bool Inthread() {
		return false;
	}

	void Setselfinsert(bool v) {
		if (v==true && kbloc==NULL)
			kbloc=new KifSelf(NULL,NULL,NULL);
		selfinsert=v;
	}
	void Initialise(KifCallFunction* kthread);


	Exported long Size() {
		return parameters.size();
	}

	bool Basic() {
		return false;
	}


	virtual Exported KifElement* Declaration(short s);	

	void Initialisation(KifElement* ke=NULL) {
		ThreadLock _lock(kifSignal);
		if (kifcode!=NULL && kifcode->current_wait!=NULL) {
			kifcode->current_wait->Resetreference();
			kifcode->current_wait=NULL;
		}
		returnvalue=kifNULL;
		isreturned=false;
	}



	void Setreturnvalue(KifElement* k) {
		returnvalue=k;
		isreturned=true;
	}

	Exported KifElement* Evaluate(int param,KifDomain* domain) {
		return parameters[param]->Execute(kifNULL,domain,kifNULL,false);
	}

	bool Isreturned() {
		return isreturned;
	}

	Exported void Add(KifElement* ke);

	void SetParameters(vector<KifElement*>& vect,hmap<short,KifElement*>* stacks);

	KifElement* Returnvalue() {
		return this;
	}
	Exported short Name() {return name;}
	Exported void Setreference() {}
	Exported void Setpopped() {}
	Exported void Resetreference() {};
	Exported void Clean() {}
	Exported KifElement* applyfunction(KifElement* a);
	virtual KifFunction* Body() {
		return NULL;
	}
	virtual void Setbody(KifFunction* ke) {}
	~KifCallFunction() {
		if (kbloc!=NULL)
			delete kbloc;
	}
};

class KifCallReturn : public KifCallFunction {
public:
	
	KifCallReturn(KifCode* klc,KifElement* kp,short n) : KifCallFunction(klc,kp,n) {}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
};


class KifReturn : public KifElement {
public:

	KifReturn(KifCode* klc,KifElement* kp) : KifElement(klc,kp,kifCallFunctionBCR) {}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false) {
		KifCallFunction* callfunc=(KifCallFunction*)kifcode->Top();
		if (callfunc==NULL)
			return kifNULL;
		callfunc->Setreturnvalue(kifNULL);
		return kifTRUE;
	}
};

class KifCallFunctionBreakOuContinue : public KifElement {
public:
	KifElement* returnvalue;

	KifCallFunctionBreakOuContinue(KifCode* klc,KifElement* kp,KifElement* r) : KifElement(klc,kp,kifCallFunctionBCR) {
		returnvalue=r;
	}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false) {
		return returnvalue;
	}
};

class KifCallFunctionBreakpoint : public KifElement {
public:

	KifCallFunctionBreakpoint(KifCode* klc,KifElement* kp) : KifElement(klc,kp,kifCallFunctionBCR) {}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false) {
		kifcode->debug=true;
		kifcode->debugging=true;
		kifcode->infunction=true;
		return kifTRUE;
	}
};


class KifCallFunctionGeneral : public KifCallFunction {
public:
	KifFunction* body;
	bool dynamicselection;
	KifCallFunctionGeneral(KifCode* klc,KifElement* kp,short n,KifFunction* b) : KifCallFunction(klc,kp,n) {
		body=b;
		type=kifCallFunctionGeneral;
		dynamicselection=false;
		if (kifcode==NULL && b!=NULL && b->next!=NULL)
			dynamicselection=true;
	}
	virtual Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);

	KifFunction* Body() {
		return body;
	}
	void Setbody(KifFunction* ke) {
		body=ke;
	}

	int InstructionSize() {
		if (body==NULL)
			return 0;
		return body->InstructionSize();
	}

	KifElement* Lastinstruction() {
		if (body==NULL)
			return kifNULL;
		return body->Lastinstruction();
	}

	KifElement* InstructionRemoveLast() {
		if (body==NULL)
			return kifNULL;
		return body->InstructionRemoveLast();
	}

	KifElement* Instruction(int i) {
		if (body==NULL)
			return kifNULL;
		return body->Instruction(i);
	}

	void InstructionClear() {
		if (body!=NULL)
			body->InstructionClear();
	}

	void Addinstruction(int i,KifElement* ke) {
		if (body!=NULL)
			body->Addinstruction(i,ke);
	}

};

class KifCallFunctionCall : public KifCallFunctionGeneral {
public:
	KifInstance* kcall;
	
	KifCallFunctionCall(KifCode* klc,KifElement* kp,short n,KifElement* declaration) : KifCallFunctionGeneral(klc,kp,n,NULL) {
		type=kifCallFunctionCall;
		kcall=new KifInstance(klc,NULL,n,(KifVariableDeclaration*)declaration);
	}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
};




class KifCallFunctionThread : public KifCallFunctionGeneral {
public:

	KifCallFunctionThread(KifCode* klc,KifElement* kp,short n,KifFunction* b) : KifCallFunctionGeneral(klc,kp,n,b) {
		type=kifCallFunctionThread;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);

};

class KifCallExecuteThread : public KifCallFunctionGeneral {
public:
#ifdef WIN32
	HANDLE thid;
	DWORD tid;
	static DWORD WINAPI Call(LPVOID);
#else
	pthread_t tid;
	static void* Call(void*);
#endif
	KifElement* context;
	KifDomain* domain;
	KifElement* value;
	bool couple;
	int parentthreadid;
	hmap<short,KifElement*> stacksparam;
	KifFunction* currentbody;
	
	Exported void Launch();
	KifCallExecuteThread(KifCode* klc,KifCallFunctionGeneral* kthread,KifFunction* b,int idthread) : KifCallFunctionGeneral(klc,NULL,kthread->name,b) {
		Initialise(kthread);
		parentthreadid=-1;
		type=kifCallExecuteThread;
		threadid=idthread;
	}
	
	Exported KifElement* Arguments();
	Exported KifElement* Execution();

	bool Inthread() {
		return true;
	}

	Exported int Parentthreadid() {
		return parentthreadid;
	}
};

class KifCallFunctionPredefined : public KifCallFunction {
public:
	KifPredefined* body;
	KifCallFunctionPredefined(KifCode* klc,KifElement* kp,short n,KifFunction* b) : KifCallFunction(klc,kp,n) {
		body=(KifPredefined*)b;
		type=kifCallFunctionPredefined;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
	Exported KifElement* Declaration(short s);
	KifType inType();
};

class KifCallExecuteThreadPredefined : public KifCallFunctionPredefined {
public:

	KifCallExecuteThreadPredefined(KifCallFunction* kthread,KifFunction* b,int idthread) : KifCallFunctionPredefined(NULL,NULL,kthread->name,b) {
		Initialise(kthread);
		type=kifCallExecuteThreadPredefined;
		threadid=idthread;
	}
	bool Inthread() {
		return true;
	}
};

class KifCallFunctionExternal : public KifCallFunction {
public:
	KifCallMethod* body;
	KifCallFunctionExternal(KifCode* klc,KifElement* kp,short n,KifFunction* b);
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
};

class KifCallExecuteThreadExternal : public KifCallFunctionExternal {
public:

	KifCallExecuteThreadExternal(KifCallFunction* kthread,KifFunction* b,int idthread) : KifCallFunctionExternal(NULL,NULL,kthread->name,b) {
		Initialise(kthread);
		type=kifCallExecuteThreadExternal;
		threadid=idthread;
	}
	bool Inthread() {
		return true;
	}
};


//A User Based Variable: frame
class KifFrame : public KifDomainInstruction {
public:
	bool declared;
	KifFrame* parent;
	KifElement* function;	
	vector<short> ordered;

	Exported KifElement* Copy(KifDomain*,KifElement*);
	KifFrame(KifCode* klc,KifElement* kp,short n,KifType ktype=kifFrame);

	Exported void Setfunction(KifElement* f) {
		function=f;
	}
	KifElement* Returnfunction() {
		return function;
	}

	KifFrame* ParentFrame() {
		if (parent->parent==NULL)
			return NULL;
		return parent;
	}
	
	bool Subframe(KifFrame* sub) {
		//First case, we have a translation method from sub to this
		if (sub->Declared(name))
			return true;
		//Else we test whether it is a derivation of this
		while (sub->parent!=NULL) {
			if (sub==this)
				return true;
			sub=sub->parent;
		}
		return false;
	}

	Exported KifElement* Pop(KifElement* key);

	Exported void Set(short,KifElement* k,hmap<short,KifElement*>* stacks);
	Exported void Setstring(string,KifElement* k,hmap<short,KifElement*>* stacks);
	Exported void Run(int from);
	Exported short Newfield(string n,KifElement* val);
	bool Basic() {
		return false;
	}

	Exported KifElement* Getfield(short n,KifDomain* dom) {
		return kifcode->Get(n,dom);
	}
	Exported string String();
	Exported KifElement* Map(KifElement*);
	Exported string Type();
	Exported bool Setvalue(KifElement* ke,KifElement* idx,KifElement* dom);
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
};

//-------------------------------------------------------------------------------

class KifPredefined : public KifElement {
public:
	short name;
	Predefined function;
	KifPredefined(KifCode* klc,Predefined f,short n) : KifElement(klc,NULL,kifPredefined) {
		function=f;
		name=n;
	}
	Exported KifElement* Execute(KifElement* a,KifDomain* b,KifElement* c,KifCallFunction* d);
};

//====================================================================================
class KifIteration : public KifElement {
public:
	bool reverse;
	KifIteration(KifCode* klc,KifElement* kp) : KifElement(klc,kp,kifIteration) {}
};

class KifIteratorVectorString : public KifIteration {
public:
	VECTA<string*>* values;
	int it;

	KifIteratorVectorString(KifCode* klc,KifElement* kp) : KifIteration(klc,kp) {it=0;}

	Exported KifElement* IteratorKey() {
		KifElement* ke=kifcode->Provideinteger(it);		
		return ke;
	}

	Exported KifElement* IteratorValue() {
		if ((*values)[it]==NULL)
			return kifNULL;
		string s=*(*values)[it];
		KifString* ke=kifcode->Providestring(s);

		return ke;
	}

	Exported KifElement* Next() {
		if (reverse==false)
			it++;
		else
			it--;
		if ((*values)[it]==NULL)
			return kifNULL;
		string s=*(*values)[it];
		KifString* ke=kifcode->Providestring(s);

		return ke;
	}

	Exported KifElement* End() {
		if (reverse==false) {
			if (it>=values->size())
				return kifTRUE;		
		}
		else {
			if (it<0)
				return kifTRUE;
		}
		return kifFALSE;
	}

	Exported KifElement* Begin() {
		if (reverse==false)
			it=0;
		else
			it=values->size()-1;

		if ((*values)[it]==NULL)
			return kifNULL;
		string s=*(*values)[it];
		KifString* ke=kifcode->Providestring(s);		
		return ke;
	}
};


class KifIteratorVectorNumber : public KifIteration {
public:
	VECTA<double>* values;
	int it;

	KifIteratorVectorNumber(KifCode* klc,KifElement* kp) : KifIteration(klc,kp) {it=0;}
	Exported KifElement* IteratorKey() {
		KifElement* ke=kifcode->Provideinteger(it);		
		return ke;
	}

	Exported KifElement* IteratorValue() {
		double v=(*values)[it];
		KifFloat* ke=kifcode->Providefloat(v);
		return ke;
	}


	Exported KifElement* Next() {
		if (reverse==false)
			it++;
		else
			it--;
		double v=(*values)[it];
		KifFloat* ke=kifcode->Providefloat(v);
		return ke;
	}

	Exported KifElement* End() {
		if (reverse==false) {
			if (it>=values->size())
				return kifTRUE;		
		}
		else {
			if (it<0)
				return kifTRUE;
		}
		return kifFALSE;
	}

	Exported KifElement* Begin() {
		if (reverse==false)
			it=0;
		else
			it=values->size()-1;
		if (it>=values->size())
			return kifNULL;
		double v=(*values)[it];
		KifFloat* ke=kifcode->Providefloat(v);		
		return ke;
	}
};

class KifIteratorString : public KifIteration {
public:

	string value;
	int itx;

	KifIteratorString(KifCode* klc,KifElement* kp) : KifIteration(klc,kp) {
		itx=0;
	}

	Exported KifElement* IteratorKey();
	Exported KifElement* IteratorValue();
	Exported KifElement* Next();
	Exported KifElement* End();
	Exported KifElement* Begin();
};

class KifIteratorTree : public KifIteration {
public:

	KifTree* tree;
	vector<KifTree*> flat;
	int idx;

	KifIteratorTree(KifCode* klc,KifElement* kp,KifTree* t=NULL) : KifIteration(klc,kp) {
		idx=0;
		tree=t;
	}

	Exported KifElement* IteratorKey();
	Exported KifElement* IteratorValue();
	Exported KifElement* Next();
	Exported KifElement* End();
	Exported KifElement* Begin();
	Exported void Flatten(KifTree*);
};


class KifIteratorVector : public KifIteration {
public:
	int itx;
	vector<KifElement*>* values;
	vector<KifElement*>::iterator it;
	vector<KifElement*>::reverse_iterator itr;
	KifIteratorVector(KifCode* klc,KifElement* kp) : KifIteration(klc,kp) {itx=0;}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);

	Exported KifElement* IteratorKey() {
		KifElement* ke=kifcode->Provideinteger(itx);		
		return ke;
	}

	Exported KifElement* IteratorValue() {
		if (reverse==false) {
			if (it==values->end())
				return kifNULL;
			return *it;
		}
		if (itr==values->rend())
			return kifNULL;
		return *itr;
	}

	Exported KifElement* Next() {
		if (reverse==false) {
			it++;
			itx++;
			if (it==values->end())
				return kifNULL;
			return *it;
		}

		itr++;
		itx--;
		if (itr==values->rend())
			return kifNULL;
		return *itr;
	}

	Exported KifElement* End() {
		if (reverse==false) {
			if (it==values->end())
				return kifTRUE;		
		}
		else {
			if (itr==values->rend())
				return kifTRUE;
		}
		return kifFALSE;
	}

	Exported KifElement* Begin() {
		if (reverse==false) {
			it=values->begin();
			if (it==values->end())
				return kifNULL;
			itx=0;
			return *it;
		}
		itr=values->rbegin();
		if (itr==values->rend())
			return kifNULL;
		itx=values->size()-1;
		return *itr;
	}
};


class KifIteratorList : public KifIteration {
public:
	int itx;
	list<KifElement*>* values;
	list<KifElement*>::iterator it;
	list<KifElement*>::reverse_iterator itr;
	KifIteratorList(KifCode* klc,KifElement* kp) : KifIteration(klc,kp) {itx=0;}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);

	Exported KifElement* IteratorKey() {
		KifElement* ke=kifcode->Provideinteger(itx);		
		return ke;
	}

	Exported KifElement* IteratorValue() {
		if (reverse==false) {
			if (it==values->end())
				return kifNULL;
			return *it;
		}
		if (itr==values->rend())
			return kifNULL;
		return *itr;
	}

	Exported KifElement* Next() {
		if (reverse==false) {
			it++;
			itx++;
			if (it==values->end())
				return kifNULL;
			return *it;
		}

		itr++;
		itx--;
		if (itr==values->rend())
			return kifNULL;
		return *itr;
	}

	Exported KifElement* End() {
		if (reverse==false) {
			if (it==values->end())
				return kifTRUE;		
		}
		else {
			if (itr==values->rend())
				return kifTRUE;
		}
		return kifFALSE;
	}

	Exported KifElement* Begin() {
		if (reverse==false) {
			it=values->begin();
			if (it==values->end())
				return kifNULL;
			itx=0;
			return *it;
		}
		itr=values->rbegin();
		if (itr==values->rend())
			return kifNULL;
		itx=values->size()-1;
		return *itr;
	}
};

class KifIteratorMap : public KifIteration {
public:
	hmap<string,KifElement*>* values;
	hmap<string,KifElement*>::iterator it;
#if defined(KIF_HASH_MAP) && !defined(WIN32)
	hmap<string,KifElement*>::iterator itr;
#else
	hmap<string,KifElement*>::reverse_iterator itr;
#endif

	KifIteratorMap(KifCode* klc,KifElement* kp) : KifIteration(klc,kp) {}

	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
	Exported KifElement* IteratorKey() {
		KifElement* ke;
		if (reverse==false) {
			if (it==values->end())
				return kifNULL;
			string s=it->first;
			ke=kifcode->Providestring(s);		
			return ke;
		}
		if (itr==values->Rend())
			return kifNULL;
		string s=itr->first;
		ke=kifcode->Providestring(s);		
		return ke;
	}


	Exported KifElement* IteratorValue() {
		if (reverse==false) {
			if (it==values->end())
				return kifNULL;
			return it->second;
		}
		if (itr==values->Rend())
			return kifNULL;
		return itr->second;
	}

	Exported KifElement* Next() {
		if (reverse==false) {
			it++;
			if (it==values->end())
				return kifNULL;
			return it->second;
		}
		itr++;
		if (itr==values->Rend())
			return kifNULL;
		return itr->second;
	}

	Exported KifElement* End() {
		if (reverse==false) {
			if (it==values->end())
				return kifTRUE;		
			return kifFALSE;
		}
		if (itr==values->Rend())
			return kifTRUE;
		return kifFALSE;
	}

	Exported KifElement* Begin() {		
		if (reverse==false) {
			it=values->begin();
			if (it==values->end())
				return kifNULL;
			return it->second;
		}
		itr=values->Rbegin();
		if (itr==values->Rend())
			return kifNULL;
		return itr->second;
	}
};



class KifIterator : public KifElement {
public:

	KifElement* value;
	bool reverse;

	KifIterator(KifCode* klc,KifElement* kp,bool rev=false) : KifElement(klc,kp,kifIterator) {
		value=kifNULL;
		reverse=rev;
	}

	Exported bool Setvalue(KifElement* k,KifElement* idx=NULL,KifElement* dom=NULL);
	Exported bool Putvalue(KifElement* k);
	
	Exported KifElement* Newinstance() {
		return this;
	}

	Exported KifElement* Next() {
		return value->Next();
	}

	Exported KifElement* End() {
		return value->End();	
	}

	Exported KifElement* Begin() {
		return value->Begin();
	}

	Exported KifElement* IteratorKey() {
		return value->IteratorKey();
	}
	Exported KifElement* IteratorValue() {
		return value->IteratorValue();
	}

	Exported string String() {
		return value->IteratorValue()->String();
	}

	Exported long Integer() {
		return value->IteratorValue()->Integer();
	}

	Exported double Float() {
		return value->IteratorValue()->Float();
	}

	Exported bool Boolean() {
		return value->IteratorValue()->Boolean();
	}


	Exported KifElement* Declaration(short s);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);


	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		KifElement* ke=new KifIterator(kifcode,kp,reverse);		
		return ke;
	}

	Exported void Resetreference();

	Exported void Clear() {
		if (value!=NULL && value->type==kifIteration)
			value->Resetreference();
	}

	Exported void Clean() {
		if (value!=NULL && value->type==kifIteration)
			value->Resetreference();
		KifElement::Resetreference();
	}
};


class KifBooleanLoop {
public:
	KifIterator it;
	KifElement* var;
	bool first;
	
	KifBooleanLoop(KifElement* varout,KifElement* varin) : it(NULL,NULL,false) {
		var=varout;
		it.Putvalue(varin);
		first=true;
	}

	Exported KifElement* Nextin() {
		if (first) {
			first=false;
			if (it.Begin()==kifNULL)
				return kifFALSE;		
		}
		else {
			it.Next();
			if (it.End()==kifTRUE)
				return kifFALSE;		
		}
		var->Setvalue(it.IteratorValue());
		return kifTRUE;
	}

	~KifBooleanLoop() {
		it.Clean();
	}
};

class KifInstructionWHILE : public KifObjectInstruction {
public:	
	KifInstructionWHILE(KifCode* klc,KifElement* kp) : KifObjectInstruction(klc,NULL,kifInstruction) {
		if (kp!=NULL)
			kp->Add(this);
		type=kifInstructionWHILE;
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
	KifElement* InFile(KifDomain* dom,KifElement* var,KifFile* kfile);
	
};

class KifKiF : public KifElement {
public:
	int id;
	string name;

	KifKiF(KifCode* klc,KifElement* kp,KifType kt=kifKiF) : KifElement(klc,kp,kt) {
		id=-1;
	}
	Exported KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		return this;
	}
	virtual Exported KifElement* Declaration(short n);
	virtual Exported KifElement* Information(KifElement*);
	virtual Exported void Methods(KifVector*);

	bool Simple() {
		return true;
	}

	Exported bool Setvalue(KifElement* k,KifElement* index=NULL,KifElement* dom=NULL) {
		if (k->type==kifKiF) {
			KifKiF* p=(KifKiF*)k;
			id=p->id;
		}
		else
			id=k->kifcode->idkifmain;

		return false;
	}
	
	Exported string String() {
		return name;
	}
	Exported long Integer() {
		return id;
	}

	Exported bool Boolean() {
		if (id==-1)
			return false;
		return true;
	}

	Exported void Clean() {}
	Exported void Clear() {}

	Exported KifElement* same(KifElement* a) {
		if (a==kifNULL) {
			if (id==-1)
				return kifTRUE;
			else
				return kifFALSE;
		}
		else
			if (name==a->String())
				return kifTRUE;
		return kifFALSE;
	}	

	~KifKiF();
};


class KifTree : public KifElement {
public:

	KifTree* parent;
	KifTree* child;
	KifTree* next;
	KifTree* previous;
	KifTree* last;
	KifElement* value;
	int hight;

	KifTree(KifCode* klc,KifElement* kp,KifElement* v,KifType kt=kifTree) : KifElement(klc,kp,kt) {
		parent=NULL;
		child=NULL;
		next=NULL;
		previous=NULL;
		last=NULL;
		value=v;
		hight=0;
	}

	Exported void Flatten(KifVector* kvect,KifTree* t);
	Exported void Mapping(KifMap* kmap,KifTree* t);
	Exported KifElement* Vector(KifElement*);
	Exported KifElement* Map(KifElement*);
	Exported KifElement* Declaration(short n);
	Exported void Methods(KifVector* fcts);
	Exported KifElement* Information(KifElement*);

	Exported void Setpopped() {
		popped=true;
		value->Setpopped();
	}

	Exported int Depth() {
		return hight;
	}

	Exported KifElement* Copy(KifDomain*,KifElement* ke=kifNULL) {
		return new KifTree(kifcode,NULL,kifNULL);
	}
	
	KifElement* Returnvalue() {
		return this;
	}

	Exported bool Setvalue(KifElement* k,KifElement* index=NULL,KifElement* dom=NULL);

	Exported KifElement* TreeChild() {
		if (child==NULL)
			return kifNULL;
		return child;
	}

	Exported KifElement* TreeNext()  {
		if (next==NULL)
			return kifNULL;
		return next;
	}
	Exported KifElement* TreePrevious() {
		if (previous==NULL)
			return kifNULL;
		return previous;
	}

	Exported KifElement* TreeParent() {
		if (parent==NULL)
			return kifNULL;
		return parent;
	}

	Exported KifElement* TreeLast() {
		if (last==NULL)
			return kifNULL;
		return last;
	}

	void Initreference();
	Exported KifElement* TreeAddchild(KifTree* t);
	Exported KifElement* TreeAddnext(KifTree* t);
	Exported KifElement* TreeAddprevious(KifTree* t);
	Exported KifElement* TreeRemove();
	Exported KifElement* TreeExtract(KifTree* with);
	Exported void SetHight(int seed);
	Exported KifElement* TreeValue() {
		return value;
	}	

	Exported void Resetreference() {		
		if (reference<=1) {
			if (next!=NULL || parent!=NULL || previous!=NULL)
				popped=true;
			if (popped==true)
				value->popped=popped;
			value->Resetreference();
		}
		KifElement::Resetreference();
	}
	Exported string String() {
		return value->String();
	}
	Exported long Integer() {
		return value->Integer();
	}
	Exported double Float() {
		return value->Float();
	}
	Exported bool Boolean() {
		return value->Boolean();
	}
	
	Exported KifElement* same(KifElement* a) {
		if (a==kifNULL)
			return kifFALSE;
		if (a==this)
			return kifTRUE;
		if (a->type!=kifTree)
			return value->same(a);
		return kifFALSE;
	}

	Exported KifElement* different(KifElement* a) {
		if (a==kifNULL)
			return kifTRUE;
		if (a==this)
			return kifFALSE;
		if (a->type!=kifTree)
			return value->different(a);
		return kifTRUE;
	}

	Exported KifElement* in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx);
	Exported KifElement* Newiterator(bool rev) {
		KifIteratorTree* iter=new KifIteratorTree(kifcode,NULL);
		iter->reverse=rev;
		iter->tree=this;
		return iter;
	}
};

class KifThread : public KifFunction {
public:
	KifThreadLock* klock;
	KifThread(KifCode* klc,KifElement* kp,short n,bool s=false,KifType kt=kifThread) : KifFunction(klc,kp,n,kt) {
		klock=NULL;
		if (s==true)
			klock=new KifThreadLock(NULL,false);
	}
	Exported KifElement* Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val=kifNULL,bool rcouple=false);
	~KifThread() {
		if (klock!=NULL)
			delete klock;
	}
};



#endif

