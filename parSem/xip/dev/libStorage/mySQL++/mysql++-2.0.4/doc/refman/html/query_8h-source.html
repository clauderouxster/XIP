<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>MySQL++ Reference Manual</title>
	<meta http-equiv="Content-type" content="text/html;charset=iso-8859-1">
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="refman.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>query.h</h1><a href="query_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 
00003 
00004 <span class="comment">/***********************************************************************</span>
00005 <span class="comment"> Copyright (c) 1998 by Kevin Atkinson, (c) 1999, 2000 and 2001 by</span>
00006 <span class="comment"> MySQL AB, and (c) 2004, 2005 by Educational Technology Resources, Inc.</span>
00007 <span class="comment"> Others may also hold copyrights on code in this file.  See the CREDITS</span>
00008 <span class="comment"> file in the top directory of the distribution for details.</span>
00009 <span class="comment"></span>
00010 <span class="comment"> This file is part of MySQL++.</span>
00011 <span class="comment"></span>
00012 <span class="comment"> MySQL++ is free software; you can redistribute it and/or modify it</span>
00013 <span class="comment"> under the terms of the GNU Lesser General Public License as published</span>
00014 <span class="comment"> by the Free Software Foundation; either version 2.1 of the License, or</span>
00015 <span class="comment"> (at your option) any later version.</span>
00016 <span class="comment"></span>
00017 <span class="comment"> MySQL++ is distributed in the hope that it will be useful, but WITHOUT</span>
00018 <span class="comment"> ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
00019 <span class="comment"> FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public</span>
00020 <span class="comment"> License for more details.</span>
00021 <span class="comment"></span>
00022 <span class="comment"> You should have received a copy of the GNU Lesser General Public</span>
00023 <span class="comment"> License along with MySQL++; if not, write to the Free Software</span>
00024 <span class="comment"> Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301</span>
00025 <span class="comment"> USA</span>
00026 <span class="comment">***********************************************************************/</span>
00027 
00028 <span class="preprocessor">#ifndef MYSQLPP_QUERY_H</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#define MYSQLPP_QUERY_H</span>
00030 <span class="preprocessor"></span>
00031 <span class="preprocessor">#include "<a class="code" href="defs_8h.html">defs.h</a>"</span>
00032 
00033 <span class="preprocessor">#include "<a class="code" href="lockable_8h.html">lockable.h</a>"</span>
00034 <span class="preprocessor">#include "<a class="code" href="noexceptions_8h.html">noexceptions.h</a>"</span>
00035 <span class="preprocessor">#include "<a class="code" href="qparms_8h.html">qparms.h</a>"</span>
00036 <span class="preprocessor">#include "<a class="code" href="result_8h.html">result.h</a>"</span>
00037 <span class="preprocessor">#include "<a class="code" href="row_8h.html">row.h</a>"</span>
00038 <span class="preprocessor">#include "<a class="code" href="sql__string_8h.html">sql_string.h</a>"</span>
00039 
00040 <span class="preprocessor">#include &lt;mysql.h&gt;</span>
00041 
00042 <span class="preprocessor">#include &lt;deque&gt;</span>
00043 <span class="preprocessor">#include &lt;list&gt;</span>
00044 <span class="preprocessor">#include &lt;map&gt;</span>
00045 <span class="preprocessor">#include &lt;set&gt;</span>
00046 <span class="preprocessor">#include &lt;sstream&gt;</span>
00047 <span class="preprocessor">#include &lt;vector&gt;</span>
00048 
00049 <span class="preprocessor">#ifdef HAVE_EXT_SLIST</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#  include &lt;ext/slist&gt;</span>
00051 <span class="preprocessor">#else</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#  if defined(HAVE_STD_SLIST) || defined(HAVE_GLOBAL_SLIST)</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#      include &lt;slist&gt;</span>
00054 <span class="preprocessor">#  endif</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00056 <span class="preprocessor"></span>
00057 
<a name="l00059"></a><a class="code" href="query_8h.html#a0">00059</a> <span class="preprocessor">#define mysql_query_define0(RETURN, FUNC)\</span>
00060 <span class="preprocessor">  RETURN FUNC (ss a)\</span>
00061 <span class="preprocessor">    {return FUNC (parms() &lt;&lt; a);}\</span>
00062 <span class="preprocessor">  RETURN FUNC (ss a, ss b)\</span>
00063 <span class="preprocessor">    {return FUNC (parms() &lt;&lt; a &lt;&lt; b);}\</span>
00064 <span class="preprocessor">  RETURN FUNC (ss a, ss b, ss c)\</span>
00065 <span class="preprocessor">    {return FUNC (parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c);}\</span>
00066 <span class="preprocessor">  RETURN FUNC (ss a, ss b, ss c, ss d)\</span>
00067 <span class="preprocessor">    {return FUNC (parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d);}\</span>
00068 <span class="preprocessor">  RETURN FUNC (ss a, ss b, ss c, ss d, ss e)\</span>
00069 <span class="preprocessor">    {return FUNC (parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; e);} \</span>
00070 <span class="preprocessor">  RETURN FUNC (ss a, ss b, ss c, ss d, ss e, ss f)\</span>
00071 <span class="preprocessor">    {return FUNC (parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; e &lt;&lt; f);}\</span>
00072 <span class="preprocessor">  RETURN FUNC (ss a, ss b, ss c, ss d, ss e, ss f, ss g)\</span>
00073 <span class="preprocessor">    {return FUNC (parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; e &lt;&lt; f &lt;&lt; g);}\</span>
00074 <span class="preprocessor">  RETURN FUNC (ss a, ss b, ss c, ss d, ss e, ss f, ss g, ss h)\</span>
00075 <span class="preprocessor">    {return FUNC (parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; e &lt;&lt; f &lt;&lt; g &lt;&lt; h);}\</span>
00076 <span class="preprocessor">  RETURN FUNC (ss a, ss b, ss c, ss d, ss e, ss f, ss g, ss h, ss i)\</span>
00077 <span class="preprocessor">    {return FUNC (parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; e &lt;&lt; f &lt;&lt; g &lt;&lt; h &lt;&lt; i);}\</span>
00078 <span class="preprocessor">  RETURN FUNC (ss a,ss b,ss c,ss d,ss e,ss f,ss g,ss h,ss i,ss j)\</span>
00079 <span class="preprocessor">    {return FUNC (parms() &lt;&lt;a &lt;&lt;b &lt;&lt;c &lt;&lt;d &lt;&lt;e &lt;&lt;f &lt;&lt;g &lt;&lt;h &lt;&lt;i &lt;&lt;j);}\</span>
00080 <span class="preprocessor">  RETURN FUNC (ss a,ss b,ss c,ss d,ss e,ss f,ss g,ss h,ss i,ss j,ss k)\</span>
00081 <span class="preprocessor">    {return FUNC (parms() &lt;&lt;a &lt;&lt;b &lt;&lt;c &lt;&lt;d &lt;&lt;e &lt;&lt;f &lt;&lt;g &lt;&lt;h &lt;&lt;i &lt;&lt;j &lt;&lt;k);}\</span>
00082 <span class="preprocessor">  RETURN FUNC (ss a,ss b,ss c,ss d,ss e,ss f,ss g,ss h,ss i,ss j,ss k,ss l)\</span>
00083 <span class="preprocessor">    {return FUNC (parms() &lt;&lt;a &lt;&lt;b &lt;&lt;c &lt;&lt;d &lt;&lt;e &lt;&lt;f &lt;&lt;g &lt;&lt;h &lt;&lt;i &lt;&lt;j &lt;&lt;k &lt;&lt;l);}\</span>
00084 <span class="preprocessor"></span>
00085 <span class="preprocessor"></span>
<a name="l00086"></a><a class="code" href="query_8h.html#a1">00086</a> <span class="preprocessor">#define mysql_query_define1(RETURN, FUNC) \</span>
00087 <span class="preprocessor">  MYSQLPP_EXPORT RETURN FUNC (parms &amp;p);\</span>
00088 <span class="preprocessor">  mysql_query_define0(RETURN,FUNC) \</span>
00089 <span class="preprocessor"></span>
00090 <span class="preprocessor"></span>
<a name="l00091"></a><a class="code" href="query_8h.html#a2">00091</a> <span class="preprocessor">#define mysql_query_define2(FUNC) \</span>
00092 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con, const char* str); \</span>
00093 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con, parms &amp;p, query_reset r = RESET_QUERY);\</span>
00094 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con, ss a)\</span>
00095 <span class="preprocessor">        {FUNC (con, parms() &lt;&lt; a);}\</span>
00096 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con, ss a, ss b)\</span>
00097 <span class="preprocessor">        {FUNC (con, parms() &lt;&lt; a &lt;&lt; b);}\</span>
00098 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con, ss a, ss b, ss c)\</span>
00099 <span class="preprocessor">        {FUNC (con, parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c);}\</span>
00100 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con, ss a, ss b, ss c, ss d)\</span>
00101 <span class="preprocessor">        {FUNC (con, parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d);}\</span>
00102 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con, ss a, ss b, ss c, ss d, ss e)\</span>
00103 <span class="preprocessor">        {FUNC (con, parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; e);} \</span>
00104 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con, ss a, ss b, ss c, ss d, ss e, ss f)\</span>
00105 <span class="preprocessor">        {FUNC (con, parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; e &lt;&lt; f);}\</span>
00106 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con,ss a,ss b,ss c,ss d,ss e,ss f,ss g)\</span>
00107 <span class="preprocessor">        {FUNC (con, parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; e &lt;&lt; f &lt;&lt; g);}\</span>
00108 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con,ss a,ss b,ss c,ss d,ss e,ss f,ss g,ss h)\</span>
00109 <span class="preprocessor">        {FUNC (con, parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; e &lt;&lt; f &lt;&lt; g &lt;&lt; h);}\</span>
00110 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con, ss a, ss b, ss c, ss d, ss e, ss f, ss g, ss h, ss i)\</span>
00111 <span class="preprocessor">        {FUNC (con, parms() &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; e &lt;&lt; f &lt;&lt; g &lt;&lt; h &lt;&lt; i);}\</span>
00112 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con, ss a,ss b,ss c,ss d,ss e,ss f,ss g,ss h,ss i,ss j)\</span>
00113 <span class="preprocessor">        {FUNC (con, parms() &lt;&lt;a &lt;&lt;b &lt;&lt;c &lt;&lt;d &lt;&lt;e &lt;&lt;f &lt;&lt;g &lt;&lt;h &lt;&lt;i &lt;&lt;j);}\</span>
00114 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con, ss a,ss b,ss c,ss d,ss e,ss f,ss g,ss h,ss i,ss j,ss k)\</span>
00115 <span class="preprocessor">        {FUNC (con, parms() &lt;&lt;a &lt;&lt;b &lt;&lt;c &lt;&lt;d &lt;&lt;e &lt;&lt;f &lt;&lt;g &lt;&lt;h &lt;&lt;i &lt;&lt;j &lt;&lt;k);}\</span>
00116 <span class="preprocessor">  template &lt;class T1&gt; void FUNC (T1 &amp;con, ss a,ss b,ss c,ss d,ss e,ss f,ss g,ss h,ss i,ss j,ss k,ss l)\</span>
00117 <span class="preprocessor">        {FUNC (con, parms() &lt;&lt;a &lt;&lt;b &lt;&lt;c &lt;&lt;d &lt;&lt;e &lt;&lt;f &lt;&lt;g &lt;&lt;h &lt;&lt;i &lt;&lt;j &lt;&lt;k &lt;&lt;l);}\</span>
00118 <span class="preprocessor"></span>
00119 <span class="preprocessor"></span><span class="keyword">namespace </span>mysqlpp {
00120 
00121 <span class="keyword">class </span>Connection;
00122 
<a name="l00124"></a><a class="code" href="namespacemysqlpp.html#a101">00124</a> <span class="keyword">enum</span> <a class="code" href="namespacemysqlpp.html#a101">query_reset</a> { DONT_RESET, RESET_QUERY };
00125 
00174 
<a name="l00175"></a><a class="code" href="classmysqlpp_1_1Query.html">00175</a> <span class="keyword">class </span><a class="code" href="classmysqlpp_1_1Query.html">Query</a> : <span class="keyword">public</span> std::ostream,
00176                 <span class="keyword">public</span> <a class="code" href="classmysqlpp_1_1OptionalExceptions.html">OptionalExceptions</a>, <span class="keyword">public</span> <a class="code" href="classmysqlpp_1_1Lockable.html">Lockable</a>
00177 {
00178 <span class="keyword">public</span>:
<a name="l00179"></a><a class="code" href="classmysqlpp_1_1Query.html#s0">00179</a>         <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="classmysqlpp_1_1SQLString.html">SQLString</a>&amp; <a class="code" href="classmysqlpp_1_1Query.html#s0">ss</a>;    
<a name="l00180"></a><a class="code" href="classmysqlpp_1_1Query.html#s1">00180</a>         <span class="keyword">typedef</span> <a class="code" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> <a class="code" href="classmysqlpp_1_1Query.html#s1">parms</a>;    
00181 
<a name="l00188"></a><a class="code" href="classmysqlpp_1_1Query.html#a0">00188</a>         <a class="code" href="classmysqlpp_1_1Query.html#a0">Query</a>(<a class="code" href="classmysqlpp_1_1Connection.html">Connection</a>* c, <span class="keywordtype">bool</span> te = <span class="keyword">true</span>) :
00189         std::ostream(&amp;sbuffer_),
00190         <a class="code" href="classmysqlpp_1_1OptionalExceptions.html">OptionalExceptions</a>(te),
00191         <a class="code" href="classmysqlpp_1_1Lockable.html">Lockable</a>(false),
00192         <a class="code" href="classmysqlpp_1_1Query.html#m0">def</a>(this),
00193         conn_(c),
00194         success_(false)
00195         {
00196                 success_ = <span class="keyword">true</span>;
00197         }
00198 
00206         MYSQLPP_EXPORT <a class="code" href="classmysqlpp_1_1Query.html#a0">Query</a>(<span class="keyword">const</span> <a class="code" href="classmysqlpp_1_1Query.html#a0">Query</a>&amp; q);
00207 
00212         MYSQLPP_EXPORT <a class="code" href="classmysqlpp_1_1Query.html#a0">Query</a>&amp; <a class="code" href="classmysqlpp_1_1Query.html#a2">operator=</a>(<span class="keyword">const</span> <a class="code" href="classmysqlpp_1_1Query.html#a0">Query</a>&amp; rhs);
00213 
00219         MYSQLPP_EXPORT std::string <a class="code" href="classmysqlpp_1_1Query.html#a3">error</a>();
00220 
00226         MYSQLPP_EXPORT <span class="keywordtype">bool</span> <a class="code" href="classmysqlpp_1_1Query.html#a4">success</a>();
00227 
00235         MYSQLPP_EXPORT <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a5">parse</a>();
00236 
00241         MYSQLPP_EXPORT <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a6">reset</a>();
00242 
<a name="l00244"></a><a class="code" href="classmysqlpp_1_1Query.html#a7">00244</a>         std::string <a class="code" href="classmysqlpp_1_1Query.html#a7">preview</a>() { <span class="keywordflow">return</span> <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>(<a class="code" href="classmysqlpp_1_1Query.html#m0">def</a>); }
00245 
<a name="l00247"></a><a class="code" href="classmysqlpp_1_1Query.html#a8">00247</a>         std::string <a class="code" href="classmysqlpp_1_1Query.html#a7">preview</a>(<a class="code" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a>&amp; p)
00248         {
00249                 <span class="keywordflow">return</span> <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>(p);
00250         }
00251 
<a name="l00253"></a><a class="code" href="classmysqlpp_1_1Query.html#a9">00253</a>         std::string <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>()
00254         {
00255                 <span class="keywordflow">return</span> <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>(<a class="code" href="classmysqlpp_1_1Query.html#m0">def</a>);
00256         }
00257 
<a name="l00262"></a><a class="code" href="classmysqlpp_1_1Query.html#a10">00262</a>         std::string <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>(<a class="code" href="namespacemysqlpp.html#a101">query_reset</a> r)
00263         {
00264                 <span class="keywordflow">return</span> <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>(<a class="code" href="classmysqlpp_1_1Query.html#m0">def</a>, r);
00265         }
00266 
00271         MYSQLPP_EXPORT std::string <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>(SQLQueryParms&amp; p);
00272 
00279         MYSQLPP_EXPORT std::string <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>(SQLQueryParms&amp; p, <a class="code" href="namespacemysqlpp.html#a101">query_reset</a> r);
00280 
00292         MYSQLPP_EXPORT <span class="keywordtype">bool</span> <a class="code" href="classmysqlpp_1_1Query.html#a13">exec</a>(<span class="keyword">const</span> std::string&amp; <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>);
00293 
<a name="l00310"></a><a class="code" href="classmysqlpp_1_1Query.html#a14">00310</a>         <a class="code" href="classmysqlpp_1_1ResNSel.html">ResNSel</a> <a class="code" href="classmysqlpp_1_1Query.html#a14">execute</a>() { <span class="keywordflow">return</span> <a class="code" href="classmysqlpp_1_1Query.html#a14">execute</a>(<a class="code" href="classmysqlpp_1_1Query.html#m0">def</a>); }
00311 
00315         MYSQLPP_EXPORT ResNSel <a class="code" href="classmysqlpp_1_1Query.html#a14">execute</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>);
00316 
<a name="l00341"></a><a class="code" href="classmysqlpp_1_1Query.html#a16">00341</a>         <a class="code" href="classmysqlpp_1_1ResUse.html">ResUse</a> <a class="code" href="classmysqlpp_1_1Query.html#a16">use</a>() { <span class="keywordflow">return</span> <a class="code" href="classmysqlpp_1_1Query.html#a16">use</a>(<a class="code" href="classmysqlpp_1_1Query.html#m0">def</a>); }
00342 
00348         MYSQLPP_EXPORT ResUse <a class="code" href="classmysqlpp_1_1Query.html#a16">use</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>);
00349 
<a name="l00371"></a><a class="code" href="classmysqlpp_1_1Query.html#a18">00371</a>         <a class="code" href="classmysqlpp_1_1Result.html">Result</a> <a class="code" href="classmysqlpp_1_1Query.html#a18">store</a>() { <span class="keywordflow">return</span> <a class="code" href="classmysqlpp_1_1Query.html#a18">store</a>(<a class="code" href="classmysqlpp_1_1Query.html#m0">def</a>); }
00372 
00378         MYSQLPP_EXPORT Result <a class="code" href="classmysqlpp_1_1Query.html#a18">store</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>);
00379 
00406         MYSQLPP_EXPORT Result <a class="code" href="classmysqlpp_1_1Query.html#a20">store_next</a>();
00407 
00419         MYSQLPP_EXPORT <span class="keywordtype">bool</span> <a class="code" href="classmysqlpp_1_1Query.html#a21">more_results</a>();
00420 
00438         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Sequence&gt;
<a name="l00439"></a><a class="code" href="classmysqlpp_1_1Query.html#a22">00439</a>         <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a22">storein_sequence</a>(Sequence&amp; con, <a class="code" href="namespacemysqlpp.html#a101">query_reset</a> r = RESET_QUERY)
00440         {
00441                 storein_sequence_(con, <a class="code" href="classmysqlpp_1_1Query.html#m0">def</a>, r);
00442         }
00443 
00451         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Set&gt;
<a name="l00452"></a><a class="code" href="classmysqlpp_1_1Query.html#a23">00452</a>         <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a23">storein_set</a>(<a class="code" href="classmysqlpp_1_1Set.html">Set</a>&amp; con, <a class="code" href="namespacemysqlpp.html#a101">query_reset</a> r = RESET_QUERY)
00453         {
00454                 <a class="code" href="classmysqlpp_1_1Query.html#a23">storein_set</a>(con, <a class="code" href="classmysqlpp_1_1Query.html#m0">def</a>, r);
00455         }
00456 
00475         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Container&gt;
<a name="l00476"></a><a class="code" href="classmysqlpp_1_1Query.html#a24">00476</a>         <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a24">storein</a>(Container&amp; con, <a class="code" href="namespacemysqlpp.html#a101">query_reset</a> r = RESET_QUERY)
00477         {
00478                 <a class="code" href="classmysqlpp_1_1Query.html#a24">storein</a>(con, <a class="code" href="classmysqlpp_1_1Query.html#m0">def</a>, r);
00479         }
00480 
00482         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00483"></a><a class="code" href="classmysqlpp_1_1Query.html#a25">00483</a>         <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a24">storein</a>(std::vector&lt;T&gt;&amp; con, <span class="keyword">const</span> <span class="keywordtype">char</span>* s)
00484         {
00485                 <a class="code" href="classmysqlpp_1_1Query.html#a22">storein_sequence</a>(con, s);
00486         }
00487 
00489         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00490"></a><a class="code" href="classmysqlpp_1_1Query.html#a26">00490</a>         <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a24">storein</a>(std::deque&lt;T&gt;&amp; con, <span class="keyword">const</span> <span class="keywordtype">char</span>* s)
00491         {
00492                 <a class="code" href="classmysqlpp_1_1Query.html#a22">storein_sequence</a>(con, s);
00493         }
00494 
00496         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00497"></a><a class="code" href="classmysqlpp_1_1Query.html#a27">00497</a>         <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a24">storein</a>(std::list&lt;T&gt;&amp; con, <span class="keyword">const</span> <span class="keywordtype">char</span>* s)
00498         {
00499                 <a class="code" href="classmysqlpp_1_1Query.html#a22">storein_sequence</a>(con, s);
00500         }
00501 
00502 <span class="preprocessor">#if defined(HAVE_EXT_SLIST)</span>
00505 <span class="preprocessor">        template &lt;class T&gt;</span>
00506 <span class="preprocessor"></span>        <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a24">storein</a>(__gnu_cxx::slist&lt;T&gt;&amp; con, <span class="keyword">const</span> <span class="keywordtype">char</span>* s)
00507         {
00508                 <a class="code" href="classmysqlpp_1_1Query.html#a22">storein_sequence</a>(con, s);
00509         }
00510 <span class="preprocessor">#elif defined(HAVE_GLOBAL_SLIST)</span>
00517 <span class="preprocessor">        template &lt;class T&gt;</span>
00518 <span class="preprocessor"></span>        <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a24">storein</a>(slist&lt;T&gt;&amp; con, <span class="keyword">const</span> <span class="keywordtype">char</span>* s)
00519         {
00520                 <a class="code" href="classmysqlpp_1_1Query.html#a22">storein_sequence</a>(con, s);
00521         }
00522 <span class="preprocessor">#elif defined(HAVE_STD_SLIST)</span>
00528 <span class="preprocessor">        template &lt;class T&gt;</span>
00529 <span class="preprocessor"></span>        <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a24">storein</a>(std::slist&lt;T&gt;&amp; con, <span class="keyword">const</span> <span class="keywordtype">char</span>* s)
00530         {
00531                 <a class="code" href="classmysqlpp_1_1Query.html#a22">storein_sequence</a>(con, s);
00532         }
00533 <span class="preprocessor">#endif</span>
00534 <span class="preprocessor"></span>
00536         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00537"></a><a class="code" href="classmysqlpp_1_1Query.html#a28">00537</a>         <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a24">storein</a>(std::set&lt;T&gt;&amp; con, <span class="keyword">const</span> <span class="keywordtype">char</span>* s)
00538         {
00539                 <a class="code" href="classmysqlpp_1_1Query.html#a23">storein_set</a>(con, s);
00540         }
00541 
00543         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00544"></a><a class="code" href="classmysqlpp_1_1Query.html#a29">00544</a>         <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Query.html#a24">storein</a>(std::multiset&lt;T&gt;&amp; con, <span class="keyword">const</span> <span class="keywordtype">char</span>* s)
00545         {
00546                 <a class="code" href="classmysqlpp_1_1Query.html#a23">storein_set</a>(con, s);
00547         }
00548 
00559         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00560"></a><a class="code" href="classmysqlpp_1_1Query.html#a30">00560</a>         <a class="code" href="classmysqlpp_1_1Query.html">Query</a>&amp; <a class="code" href="classmysqlpp_1_1Query.html#a30">update</a>(<span class="keyword">const</span> T&amp; o, <span class="keyword">const</span> T&amp; n)
00561         {
00562                 <a class="code" href="classmysqlpp_1_1Query.html#a6">reset</a>();
00563 
00564                 <span class="comment">// Cast required for VC++ 2003 due to error in overloaded operator</span>
00565                 <span class="comment">// lookup logic.  For an explanation of the problem, see:</span>
00566                 <span class="comment">// http://groups-beta.google.com/group/microsoft.public.vc.stl/browse_thread/thread/9a68d84644e64f15</span>
00567                 dynamic_cast&lt;std::ostream&amp;&gt;(*this) &lt;&lt; <span class="stringliteral">"UPDATE "</span> &lt;&lt; o.table() &lt;&lt;
00568                                 <span class="stringliteral">" SET "</span> &lt;&lt; n.equal_list() &lt;&lt; <span class="stringliteral">" WHERE "</span> &lt;&lt;
00569                                 o.equal_list(<span class="stringliteral">" AND "</span>, sql_use_compare);
00570                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00571         }
00572 
00581         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00582"></a><a class="code" href="classmysqlpp_1_1Query.html#a31">00582</a>         <a class="code" href="classmysqlpp_1_1Query.html">Query</a>&amp; <a class="code" href="classmysqlpp_1_1Query.html#a31">insert</a>(<span class="keyword">const</span> T&amp; v)
00583         {
00584                 <a class="code" href="classmysqlpp_1_1Query.html#a6">reset</a>();
00585 
00586                 <span class="comment">// See above comment for cast rationale</span>
00587                 dynamic_cast&lt;std::ostream&amp;&gt;(*this) &lt;&lt; <span class="stringliteral">"INSERT INTO "</span> &lt;&lt;
00588                                 v.table() &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; v.field_list() &lt;&lt; <span class="stringliteral">") VALUES ("</span> &lt;&lt;
00589                                 v.value_list() &lt;&lt; <span class="stringliteral">")"</span>;
00590                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00591         }
00592 
00606         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iter&gt;
<a name="l00607"></a><a class="code" href="classmysqlpp_1_1Query.html#a32">00607</a>         <a class="code" href="classmysqlpp_1_1Query.html">Query</a>&amp; <a class="code" href="classmysqlpp_1_1Query.html#a31">insert</a>(Iter first, Iter last)
00608         {
00609                 <a class="code" href="classmysqlpp_1_1Query.html#a6">reset</a>();
00610                 <span class="keywordflow">if</span> (first == last) {
00611                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;   <span class="comment">// empty set!</span>
00612                 }
00613                 
00614                 <span class="comment">// See above comment for cast rationale</span>
00615                 dynamic_cast&lt;std::ostream&amp;&gt;(*this) &lt;&lt; <span class="stringliteral">"INSERT INTO "</span> &lt;&lt;
00616                                 first-&gt;table() &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; first-&gt;field_list() &lt;&lt;
00617                                 <span class="stringliteral">") VALUES ("</span> &lt;&lt; first-&gt;value_list() &lt;&lt; <span class="charliteral">')'</span>;
00618 
00619                 Iter it = first + 1;
00620                 <span class="keywordflow">while</span> (it != last) {
00621                         *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">",("</span> &lt;&lt; it-&gt;value_list() &lt;&lt; <span class="charliteral">')'</span>;
00622                         ++it;
00623                 }
00624 
00625                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00626         }
00627 
00637         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00638"></a><a class="code" href="classmysqlpp_1_1Query.html#a33">00638</a>         <a class="code" href="classmysqlpp_1_1Query.html">Query</a>&amp; <a class="code" href="classmysqlpp_1_1Query.html#a33">replace</a>(<span class="keyword">const</span> T&amp; v)
00639         {
00640                 <a class="code" href="classmysqlpp_1_1Query.html#a6">reset</a>();
00641 
00642                 <span class="comment">// See above comment for cast rationale</span>
00643                 dynamic_cast&lt;std::ostream&amp;&gt;(*this) &lt;&lt; <span class="stringliteral">"REPLACE INTO "</span> &lt;&lt;
00644                                 v.table() &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; v.field_list() &lt;&lt; <span class="stringliteral">") VALUES ("</span> &lt;&lt;
00645                                 v.value_list() &lt;&lt; <span class="stringliteral">")"</span>;
00646                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00647         }
00648 
<a name="l00650"></a><a class="code" href="classmysqlpp_1_1Query.html#a34">00650</a>         <a class="code" href="classmysqlpp_1_1Query.html#a34">operator bool</a>() { <span class="keywordflow">return</span> <a class="code" href="classmysqlpp_1_1Query.html#a4">success</a>(); }
00651 
<a name="l00653"></a><a class="code" href="classmysqlpp_1_1Query.html#a35">00653</a>         <span class="keywordtype">bool</span> <a class="code" href="classmysqlpp_1_1Query.html#a35">operator !</a>() { <span class="keywordflow">return</span> !<a class="code" href="classmysqlpp_1_1Query.html#a4">success</a>(); }
00654 
00655 <span class="preprocessor">#if !defined(DOXYGEN_IGNORE)</span>
00656 <span class="preprocessor"></span>        <span class="comment">// Declare the remaining overloads.  These are hidden down here partly</span>
00657         <span class="comment">// to keep the above code clear, but also so that we may hide them</span>
00658         <span class="comment">// from Doxygen, which gets confused by macro instantiations that look</span>
00659         <span class="comment">// like method declarations.</span>
00660         <a class="code" href="query_8h.html#a0">mysql_query_define0</a>(std::string, <a class="code" href="classmysqlpp_1_1Query.html#a7">preview</a>)
00661         <a class="code" href="query_8h.html#a0">mysql_query_define0</a>(std::string, <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>);
00662         <a class="code" href="query_8h.html#a1">mysql_query_define1</a>(ResNSel, execute)
00663         <a class="code" href="query_8h.html#a1">mysql_query_define1</a>(Result, store)
00664         <a class="code" href="query_8h.html#a1">mysql_query_define1</a>(ResUse, use)
00665         <a class="code" href="query_8h.html#a2">mysql_query_define2</a>(<a class="code" href="classmysqlpp_1_1Query.html#a22">storein_sequence</a>)
00666         <a class="code" href="query_8h.html#a2">mysql_query_define2</a>(<a class="code" href="classmysqlpp_1_1Query.html#a23">storein_set</a>)
00667         <a class="code" href="query_8h.html#a2">mysql_query_define2</a>(<a class="code" href="classmysqlpp_1_1Query.html#a24">storein</a>)
00668 #endif <span class="comment">// !defined(DOXYGEN_IGNORE)</span>
00669 
<a name="l00673"></a><a class="code" href="classmysqlpp_1_1Query.html#m0">00673</a>         <a class="code" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> <a class="code" href="classmysqlpp_1_1Query.html#m0">def</a>;
00674 
00675 <span class="keyword">private</span>:
00676         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a>;
00677 
00679         <a class="code" href="classmysqlpp_1_1Connection.html">Connection</a>* conn_;
00680 
00682         <span class="keywordtype">bool</span> success_;
00683 
00685         std::vector&lt;SQLParseElement&gt; parse_elems_;
00686 
00689         std::vector&lt;std::string&gt; parsed_names_;
00690 
00692         std::map&lt;std::string, short int&gt; parsed_nums_;
00693 
00695         std::stringbuf sbuffer_;
00696 
00698         my_ulonglong affected_rows() <span class="keyword">const</span>;
00699         my_ulonglong insert_id();
00700         std::string info();
00701         <span class="keywordtype">char</span>* preview_char();
00702 
00704         <span class="keywordtype">void</span> proc(<a class="code" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a>&amp; p);
00705 
00706         <span class="comment">// Locking mechanism</span>
00707         <span class="keywordtype">bool</span> <a class="code" href="classmysqlpp_1_1Lockable.html#b2">lock</a>();
00708         <span class="keywordtype">void</span> <a class="code" href="classmysqlpp_1_1Lockable.html#b3">unlock</a>();
00709 
00710         <a class="code" href="classmysqlpp_1_1SQLString.html">SQLString</a>* pprepare(<span class="keywordtype">char</span> option, <a class="code" href="classmysqlpp_1_1SQLString.html">SQLString</a>&amp; S, <span class="keywordtype">bool</span> replace = <span class="keyword">true</span>);
00711 };
00712 
00713 
00714 <span class="preprocessor">#if !defined(DOXYGEN_IGNORE)</span>
00715 <span class="preprocessor"></span><span class="comment">// Doxygen will not generate documentation for this section.</span>
00716 
00717 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Seq&gt;
00718 <span class="keywordtype">void</span> Query::storein_sequence(Seq&amp; seq, SQLQueryParms&amp; p, <a class="code" href="namespacemysqlpp.html#a101">query_reset</a> r)
00719 {
00720         r = parse_elems_.size() ? DONT_RESET : RESET_QUERY;
00721         <a class="code" href="classmysqlpp_1_1Query.html#a22">storein_sequence</a>(seq, <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>(p, r).c_str());
00722 }
00723 
00724 
00725 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Sequence&gt;
00726 <span class="keywordtype">void</span> Query::storein_sequence(Sequence&amp; con, <span class="keyword">const</span> <span class="keywordtype">char</span>* s)
00727 {
00728         ResUse result = <a class="code" href="classmysqlpp_1_1Query.html#a16">use</a>(s);
00729         <span class="keywordflow">while</span> (1) {
00730                 MYSQL_ROW d = mysql_fetch_row(result.raw_result());
00731                 <span class="keywordflow">if</span> (!d)
00732                         <span class="keywordflow">break</span>;
00733                 Row row(d, &amp;result, mysql_fetch_lengths(result.raw_result()),
00734                                 <span class="keyword">true</span>);
00735                 <span class="keywordflow">if</span> (!row)
00736                         <span class="keywordflow">break</span>;
00737                 con.push_back(<span class="keyword">typename</span> Sequence::value_type(row));
00738         }
00739 }
00740 
00741 
00742 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Set&gt;
00743 <span class="keywordtype">void</span> Query::storein_set(Set&amp; sett, SQLQueryParms&amp; p, <a class="code" href="namespacemysqlpp.html#a101">query_reset</a> r)
00744 {
00745         r = parse_elems_.size() ? DONT_RESET : RESET_QUERY;
00746         <a class="code" href="classmysqlpp_1_1Query.html#a23">storein_set</a>(sett, <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>(p, r).c_str());
00747 }
00748 
00749 
00750 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Set&gt;
00751 <span class="keywordtype">void</span> Query::storein_set(Set&amp; con, <span class="keyword">const</span> <span class="keywordtype">char</span>* s)
00752 {
00753         ResUse result = <a class="code" href="classmysqlpp_1_1Query.html#a16">use</a>(s);
00754         <span class="keywordflow">while</span> (1) {
00755                 MYSQL_ROW d = mysql_fetch_row(result.raw_result());
00756                 <span class="keywordflow">if</span> (!d)
00757                         <span class="keywordflow">return</span>;
00758                 Row row(d, &amp;result, mysql_fetch_lengths(result.raw_result()),
00759                                 <span class="keyword">true</span>);
00760                 <span class="keywordflow">if</span> (!row)
00761                         <span class="keywordflow">break</span>;
00762                 con.insert(<span class="keyword">typename</span> Set::value_type(row));
00763         }
00764 }
00765 
00766 
00767 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00768 <span class="keywordtype">void</span> Query::storein(T&amp; con, SQLQueryParms&amp; p, <a class="code" href="namespacemysqlpp.html#a101">query_reset</a> r)
00769 {
00770         r = parse_elems_.size() ? DONT_RESET : RESET_QUERY;
00771         <a class="code" href="classmysqlpp_1_1Query.html#a24">storein</a>(con, <a class="code" href="classmysqlpp_1_1Query.html#a9">str</a>(p, r).c_str());
00772 }
00773 
00774 
00775 <span class="preprocessor">#endif // !defined(DOXYGEN_IGNORE)</span>
00776 <span class="preprocessor"></span>
00777 } <span class="comment">// end namespace mysqlpp</span>
00778 
00779 <span class="preprocessor">#endif</span>
00780 <span class="preprocessor"></span>
</pre></div><hr><address style="align: right;"><small>Generated on Mon Aug 29 15:45:45 2005 for MySQL++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
