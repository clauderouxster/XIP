//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//! Xerox Research Centre Europe - Grenoble Laboratory
//!
//! Copyright (c) 2003 Xerox Corporation.  All Rights Reserved.
//!
//! --- CONTENTS ---
//!   Project    : English XIP normalization grammar
//!   filename   : paraph.xip
//!   Date       : 09/2003
//!   Author     : Caroline Hagege
//!  
//!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

DependencyRules:



//////////////////////////////////
// Adding a feature c_person:+ to proper nouns of persons
//////////////////////////////////

// Rule 638
| noun[c_person=+]{ ?*, noun[proper,fam], ?*, noun[proper]} |
	~

// Rule 639
| noun[c_person=+]{?*, noun[proper,fam]} |
	~

// Rule 640
| noun[c_person=+,proper,fam] |
	~


//////////////////////////////////
// Recuperation of the preposition in the NMOD dependencies
// Creation of a syntactic relation NMODPREP that contains the prepostion in the last argument
//////////////////////////////////


// Rule 641
// e.g The friend of my sister NMODPREP(friend,sister,of)
| NP#1;PP#1, ?*, PP#2{prep#5} |
	if ( HEAD(#3,#1) & HEAD(#4,#2) & ^MOD(#3[noun],#4) )
	NMODPREP(#3,#4,#5)


//////////////////////////////////
// NMODGEN links a nominal premodifier with its head when the premodifier has a possessive particle
// Also links two nouns when the second is introduced by "whose". e.g. The process, whose inventor ....
//////////////////////////////////

// Rule 642
// e.g. The painting's creator
| ?{#1[last]};#1, part, #2 |
	if ( MOD[pre](#2[noun],#1) )
	NMODGEN(#2,#1)

// Rule 643
// When the premodifier is a noun, the particle is not always present
| ?{#1[last,noun,adj:~]};#1[noun,pl,adj:~], #2 |
	if ( MOD[pre](#2[noun],#1) )
	NMODGEN(#2,#1)

// Rule 644
// Relatives introduced by "whose"
// e.g. The process, whose inventor is John --> NMODGEN(inventor,process)
	if ( DETD(#2,#3[form:fwho,gen]) & MOD[relativ,post](#1[noun],?) )
	NMODGEN(#2,#1)

// Rule 645
| NP#10, (punct[comma]), SC{ BG{pron#1[first,rel,gen,pron]}, NP{?*, #2[noun,last]} } |
	if ( HEAD(#20,#10) & ~NMODGEN(#2,#20) )
	NMODGEN(#2,#20)



//////////////////////////////////
// Recuperation of the preposition in the VMOD dependencies
// Creation of a syntactic relation VMODPREP that contains the prepostion in the last argument
//////////////////////////////////

// Rule 646
// He died in 1976 --> VMODPREP(died,1976,in)

| SC{?*,FV{?*,#1[last]}};?[verb]{?*,#1[last]};verb#1[partpas], ?*, PP#2{prep#5} |
	if ( HEAD(#4,#2) & ^MOD[post](#1,#4) )
	VMODPREP(#1,#4,#5)



// Rule 647
// For coordinated nouns that depends on the same preposition
if ( VMODPREP(#1,#2,#3) & COORD(#10,#2) & COORD(#10,#4) )
	VMODPREP(#1,#4,#3)



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
// 
// 
// Trying to delimitate clauses in a sentence
// 
// 
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// He said that she loves Peter who is my friend
//  MAIN(said)
// EMBED relation wich hierarchize the propositions that are present in a sentence
// EMBED(loves,said)
// EMBED(is,loves)



// Rule 648
// For sentences that are governed by the main element
// link to sentential object and sentential modifiers
// Disjunction here in order to deal with coordinated verbs in the highest level
if ( ( MAIN(#1) | MAIN2(#1) | ( COORD(#5,#1) & MAIN(#5) ) ) & ( OBJ[sentence](#1,#3) | MOD[sentence](#1,#3) ) )
	EMBED(#3,#1)


// Rule 649
// Same as above but the dependent is an infinitive clause (infinitive object or modifier)
if ( ( MAIN(#1) | MAIN2(#1) ) & ( OBJ[infinit](#1,#2) | MOD[infinit](#1,#2) ) )
	EMBED[infinit=+](#2,#1)

// Rule 650
// The infinitive modifies one of the argument of the main verb
if ( ( MAIN(#1) | MAIN2(#1) ) & ( OBJ(#1,#3) | MOD(#1,#3) | NUCL[subjcompl](#1,#3) ) & MOD[infinit](#3,#4) )
	EMBED[infinit=+](#4,#1)

// Rule 651
// For relative clauses whose antecedant is in the main clause
// 2 possibilites: 
// 1) the antecedant is directly related to the main verb
if (   ( MAIN(#1) | MAIN2(#1) ) & VDOMAIN(#1,#2)  & ( ?[sentence:~](#1,#9) | ?[sentence:~](#2,#9) | ?[sentence:~](#1,#9,?) | ?[sentence:~](#2,#9,?) ) & MOD[sentence,relativ](#9,#10) )
	EMBED[relativ=+](#10,#1)




// Rule 652
// For relative clauses only. The antecedant is in the main clause and is linked to a dependant of the main verb
// Second possibility
// 2) the antecedant is a noun modifier of an element directly related to the main verb (see next rule)
if ( ( MAIN(#1) | MAIN2(#1) ) & VDOMAIN(#1,#2) & ( ?[sentence:~](#1,#8) | ?[sentence:~](#2,#8) ) & ( NMODPREP[post](#8,#9,?) | ( NMODPREP[post](#8,#11,?) & NMODPREP[post](#11,#9,?) ) ) & MOD[sentence,relativ](#9,#10) )
	EMBED[relativ=+](#10,#1)


// The main verb can be a [indspeech:+] verb. In this case we have to apply the previous rules in the "second-main" verb.

// Rule 653
// For verbs that are just under the TOP node (past particple forms)
// e.g. Acetone is a chemical USED to make fibers
// In this case we want an EMBED(USED,is)
| NP, verb#10[partpas] |
	if ( ~EMBED(#10,?) 
		& ( MAIN(#1) | MAIN2(#1) ) & VDOMAIN(#1,#2) 
		& VDOMAIN[passive](#10,#10)
		& ~MOD(?,#10) 
		)
	EMBED(#10,#1) 


// Embedded sentences of another embedded sentence (independent of the level of embedding)


// Rule 654
// Sentential objects or modifiers
if ( EMBED(#1,?) & ( OBJ[sentence](#1,#3) | MOD[sentence](#1,#3) ) )
	EMBED(#3,#1)

// Rule 655
// Same as above but the dependent is an infinitive clause (infinitive object)
if ( EMBED(#1,?) & ( OBJ[infinit](#1,#2) | MOD[infinit](#1,#2) ) )
	EMBED[infinit=+](#2,#1)

// Rule 656
// Infinitive clause depending from one of the arguments of the main verb
if ( EMBED(#1,?) & ( OBJ(#1,#3) | MOD(#1,#3) | NUCL[subjcompl](#1,#3) ) & MOD[infinit](#3,#4) )
	EMBED[infinit=+](#4,#1)


// Rule 657
// Relatives first case
if (   EMBED(#1,?) & VDOMAIN(#1,#2) & ( ?[sentence:~](#1,#9) | ?[sentence:~](#2,#9) | ?[sentence:~](#1,#9,?) | ?[sentence:~](#2,#9,?) ) & MOD[sentence,relativ](#9,#10) )
	EMBED[relativ=+](#10,#1)

// Rule 658
// Same as above it the embedded st is an infinitive (no VDOMAIN in this case)
if ( EMBED[infinit](#1,?) & ( ?[sentence:~](#1,#9) | ?[sentence:~](#1,#9,?)  ) & MOD[sentence,relativ](#9,#10) )
	EMBED[relativ=+](#10,#1)

// Rule 659
// Relatives second case
if ( EMBED(#1,?) & VDOMAIN(#1,#2) & ( ?[sentence:~](#1,#8) | ?[sentence:~](#1,#8,?) | ?[sentence:~](#2,#8,?) | ?[sentence:~](#2,#8) ) & ( NMODPREP[post](#8,#9,?) | ( NMODPREP[post](#8,#11,?) & NMODPREP[post](#11,#9,?) ) ) & MOD[sentence,relativ](#9,#10) )
	EMBED[relativ=+](#10,#1)

// Rule 660
// Same as above it the embedded st is an infinitive (no VDOMAIN in this case)
if ( EMBED[infinit](#1,?) & ( ?[sentence:~](#1,#8) | ?[sentence:~](#1,#8,?) ) & ( NMODPREP[post](#8,#9,?) | ( NMODPREP[post](#8,#11,?) & NMODPREP[post](#11,#9,?) ) ) & MOD[sentence,relativ](#9,#10) )
	EMBED[relativ=+](#10,#1)

// Repetitions of the previous rules in order to take into account all levels of embedment
// constraint in order to avoid to calculate the same EMBED relation more than once

// Rule 661
if ( EMBED(#1,?) & ~EMBED(#2,#1) & (  OBJ[sentence](#1,#2) | MOD[sentence](#1,#2) )  )
	EMBED(#2,#1)

// Rule 662
if ( EMBED(#1,?) & ~EMBED(#2,#1) & OBJ[infinit](#1,#2) )
	EMBED[infinit=+](#2,#1)

// Rule 663
if (   EMBED(#1,?) & VDOMAIN(#1,#2) & ~EMBED(#10,#1) & ( ?[sentence:~](#1,#9) | ?[sentence:~](#1,#9,?) | ?[sentence:~](#2,#9,?) | ?[sentence:~](#2,#9) ) & MOD[sentence,relativ](#9,#10) )
	EMBED[relativ=+](#10,#1)



// Rule 664
// Relatives second case
if ( EMBED(#1,?) & VDOMAIN(#1,#2) & ~EMBED(#10,#1) & ( ?[sentence:~](#1,#8) | ?[sentence:~](#2,#8) ) & ( NMODPREP[post](#8,#9,?) | ( NMODPREP[post](#8,#11,?) & NMODPREP[post](#11,#9,?) ) ) & MOD[sentence,relativ](#9,#10) )
	EMBED[relativ=+](#10,#1)


// Last loop of repetition of the previous rules in order to take into account all levels of embedment (4th level)
// constraint in order to avoid to calculate the same EMBED relation more than once

// Rule 665
if ( EMBED(#1,?) & ~EMBED(#2,#1) & (  OBJ[sentence](#1,#2) | MOD[sentence](#1,#2) )  )
	EMBED(#2,#1)

// Rule 666
if ( EMBED(#1,?) & ~EMBED(#2,#1) & OBJ[infinit](#1,#2) )
	EMBED[infinit=+](#2,#1)

// Rule 667
if (   EMBED(#1,?) & VDOMAIN(#1,#2) & ~EMBED(#10,#1) & ( ?[sentence:~](#1,#9) | ?[sentence:~](#2,#9) ) & MOD[sentence,relativ](#9,#10) )
	EMBED[relativ=+](#10,#1)



// Rule 668
// Relatives second case
if ( EMBED(#1,?) & VDOMAIN(#1,#2) & ~EMBED(#10,#1) & ( ?[sentence:~](#1,#8) | ?[sentence:~](#2,#8) ) & ( NMODPREP[post](#8,#9,?) | ( NMODPREP[post](#8,#11,?) & NMODPREP[post](#11,#9,?) ) ) & MOD[sentence,relativ](#9,#10) )
	EMBED[relativ=+](#10,#1)



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
// SUBJ-N (semantic subject)
//  eg. John is playing SUBJ-N(playing,John)
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// Rule 669
/Semantic subject between the subject and the nucleus of the verb \
// Restriction on COMPOUNDS i.e. we don't want to have *SUBJSEM(got,you) in "you have got"
if ( SUBJ[!features:!,relativ:~](#1,#2[wh:~,rel:~])  & VDOMAIN[passive:~](#3,#1) & ~COMPOUND(#1,#3) )
	SUBJ-N(#3,#2)



// Rule 670
// Semantic subject between the subject and the verb in case of a compound verb
// e.g. you have got
if ( SUBJ[wh:~](#1,#2) & COMPOUND(#1,#3) & VDOMAIN[passive:~](#3,#1) )
	SUBJ-N(#1,#2)


// Rule 671
// For passive forms, the SUBJ-N is the AGENT calculated before....
if ( ^AGENT(#1,#2) )
	SUBJ-N(#1,#2)



// Rule 672
// When the SUBJ of a verb is a numeral alone followed by a PP we have SUBJ(<verb>,<numeral>)
// But we want a SUBJ-N(<verb>,<PP-head>)
// EG. Three of the boys were missing. SUBJ(were, three) SUBJSEM(missing,boys)
| NP{num#1[last]}, PP#2{?[form:fof]} |
	if ( HEAD(#3,#2) & QUANTD(#3,#1) & SUBJ(#4,#1) & VDOMAIN(#5,#4) & ^SUBJ-N(#5,#1) )
	SUBJ-N(#5,#3)


// Rule 673
// ING-forms  modifying a NP-head 
// e.g. Recessive host mutation affecting virus multiplication....
if ( MOD[post,gerund](#1[noun],#2) )
	SUBJ-N(#2,#1)


// Rule 674
// When the subject of the verb is a relative pronoun the subj-sem of the verb of the relative clause is the antecedant of this pronoun
if ( SUBJ[pre,relativ](#3,#1) & VDOMAIN[passive:~](#2,#3) & MOD[post,sentence,relativ](#4,#2) )
	SUBJ-N(#2,#4)




// Rule 675
// Case of subject of infinitive forms. They have not been calculated yet because VDOMAIN relation does not exist for them
// These kind of subjects bear the feature nfinit:+
if ( SUBJ[nfinit:+](#1,#2) & ~VDOMAIN[passive](?,#1) )
	SUBJ-N(#1,#2)



// Rule
// Complex verbal forms with deduced subjects
//if ( SUBJ[deduced](#1[cop:~,cop2:~,aux:~],#2) & ~AGENT(#1,#2) )
//	AGENT(#1,#2)


// Rule 676
// for pastparticiple that are modifying a noun within a NP
// e.g. Mutation affected by virus modification ...
// e.g  Measures taken so far ....
| #1[partpas], PP#3{prep[form:fby]} |
if ( HEAD(#4,#3) &  ( MOD[post,pastpart](#2[noun],#1) | VDOMAIN[passive](#1,#1) )  )
	SUBJ-N(#1,#4)



// Rule 677
// For ing-forms that are tagged as adjectives and modify a noun
// e.g. The sleeping lady SUBJ-N(sleeping,lady)
// PROBLEMS : Developing countries where "countries" is not the semantic subject of "developing"
if ( MOD[pre](#1[noun],#2[adj,vprog]) )
	SUBJ-N(#2,#1)


// Rule 678
// Passing feature NEG
if ( ( ?[neg](#1,#2) | ?[neg](#2,#1) ) & ^SUBJ-N[neg:~](#1,#2) )
	SUBJ-N[neg=+](#1,#2)



////////////////////////////////
// Obj-sem subsumes Patients and (partly) Result
////////////////////////////////


// Rule 679
// e.g. The house is getting rebuilt, The story got translated into English
// A previous subj-sem has been (wrongly) calculated between the NP on the left and the verb
| SC{FV{?*,#1[form:fget]}}; ?[verb]{?*,#1[form:fget]}, NFV{?*,#2[partpas]} |
	if ( VDOMAIN(#2,?) & ^SUBJ-N(#2,#3) & #3 < #2 ) 
	OBJ-N(#2,#3)




// Rule 680
// Adding restriction in order to avoid to take as OBJ-N sentences, infinitives or relative pronouns which are in an OBJ dependency with the main verb
if ( OBJ[infinit:~,sentence:~,relativ:~](#1[cop:~,cop2:~],#2) )
	OBJ-N(#1,#2)


// Rule 681
// OBJ-N in case of relative clauses.
// If a relative prounoun is the object of a clause AND if we have the antecedent of this relative pronoun
// Then there is an OBJ-N dep. betwee the verb of the relative clause and the antecedent.
if ( OBJ[relativ](#1[cop:~],#2) & MOD[relativ,sentence](#3,#1) )
	OBJ-N(#1,#3)

// Rule 682
// for passive forms
// constraint added on ~OBJ[infinit,post] in order to avoid to have OBJ-N(expect,John) in "John is expected to do..."
if ( SUBJ[relativ:~](#1,#2) & ( (VDOMAIN[passive](#3,#1) &  #1 < #3) | VDOMAIN[passive](#3,#1) ) & ~OBJ[infinit,post](#3,?) )
	OBJ-N(#3,#2)



// Rule 683
// Passive forms in embedded relatives
if ( SUBJ[relativ](#1,#2) & VDOMAIN[passive](#3,#1) & #1 < #3 & ~OBJ[infinit,post](#3,?) & MOD[relativ,sentence](#4,#3) )
	OBJ-N(#3,#4)


// Rule 684
// for pastparticiple that are modifying a noun within a NP
// e.g. Mutation affected by virus modification ...
// e.g  Measures taken so far ....
if ( MOD[post,pastpart](#1[noun],#2) )
	OBJ-N(#2,#1)


// Rule 685
// Correction of badly calculated SUBJ-N - OBJ-N result of tagging error of past-particple forms (taken as FV)
// Arsenic is an element that is widely distributed in France
if ( ^SUBJ-N(#3[partpas],#2) & OBJ-N(#3,#2) )
	~



// Rule 686
// Negation
if (  ( ?[neg](#1,#2) | ?[neg](#2,#1) ) & ^OBJ-N[neg:~](#1,#2) )
	OBJ-N[neg=+](#1,#2) 



/////////////////////////////////////////////////////////////////////////////
// 
// EXTRAPOSITION OF CLAUSAL SUBJECTS
// 
// 
// 
/////////////////////////////////////////////////////////////////////////////


///////////////////////////////
// 
// Result : subcategorized complements introduced by "into" and "to" when the verb is not a motion verb and ch_of_state verb
// and the complement is not a proper name
///////////////////////////////

// Rule 687
if ( ^VMODPREP[post](#1[vmotion:~],#2,#3[sc_pinto]) & PREPD(#2[proper:~,c_person:~],?[sc_pinto]) )
	RESULT(#1,#2)

// Rule 688
// Restriction in order to avoid RESULT in expressions like FROM X TO Y
if ( ^VMODPREP[post](#1[vmotion:~],#2,#3[sc_pto]) & ~VMODPREP(#1,#20,#30[sc_pfrom]) & PREPD(#2[proper:~,c_person:~],?[sc_pto]) )
	RESULT(#1,#2)






//////////////////////////////////
// Generalization of SUBJATTR dependency
// in case of controled subjects
// e.g. John is expected to be a painter
// Note that SUBJATTR dependency for the simpler cases have been calculated in the general grammar (even though they do not
// appear in the output
//////////////////////////////////

// Rule 
// SUBJATTR that are adjectives are linked as attrib
//if ( SUBJATTR(#1[form:~fit,form:~fthere],#2[adj]) )
//	ATTRIB(#1,#2)


// Rule 690
if ( SUBJ[nfinit](#1[cop],#2[form:~fit, form:~fthere]) & NUCL[subjcompl](#1,#3) )
	ATTRIB(#2,#3)

// Rule 691
if ( SUBJ(#1[cop],#2[form:fit]) & NUCL[subjcompl](#1,#3[adj,first,last]) & ~DETD(#3,?) )
	ATTRIB(#2,#3)


///////////////////////////////
// Attrib - links a nominal head to an attribute (subjattr, or nominal apposition)
/////////////////////////////

// Rule 692
// EN COURS - distinguer les definis des indefinis
if ( SUBJATTR[neg:~](#1,#2) & DETD(#2,?[indef:~,pron:~]) )
	ATTRIB[def=+](#1,#2)

// Rule 693
if ( SUBJATTR[neg:~](#1,#2) & DETD(#2,?[indef]) )
	ATTRIB[indef=+](#1,#2)

// Rule 694
if ( SUBJATTR[neg:~](#1,#2[noun, adj:~, proper:~,first,last]) & ~DETD(#2,?) & ~ATTRIB(#1,#2) )
	ATTRIB[indef=+](#1,#2)

// Rule 695
if ( SUBJATTR[neg:~](#1,#2[proper,first,last]) )
	ATTRIB(#1,#2)

// Rule 696
// Calculating attrib that comes from SUBJ-N
if ( SUBJ-N[neg:~](#1[form:fbe],#2) & NUCL[subjcompl](#1,#3[noun]) & DETD(#3,?[pron:~]) )
	ATTRIB(#2,#3)


// Rule 697
// Post noun modifier (apposition)
// John the butcher is nice....
//| NP, NP#1 |
	if ( HEAD(#2,#1) & DETD(#2,?[indef:~]) & MOD[post,appos](#3[noun],#2) )
	ATTRIB[def=+,appos=+](#3,#2)



// Rule 698
	if ( HEAD(#2,#1) & DETD(#2,?[indef]) & MOD[post,appos](#3[noun],#2) )
	ATTRIB[indef=+,appos=+](#3,#2)


// Rule 699
// e.g. John, the inventor of this process.... 
// e.g. John as the inventor...
//| NP#1, punct[comma], NP#2 |
	if ( ~ATTRIB[appos](#3,?) & ( MOD[post,appos](#3[noun],#4) | NMODPREP(#3,#4,?[form:fas])) & ~MOD[pre](?,#3) )
	ATTRIB[appos=+](#3,#4)




// Rule 700
// When there is a negation on the copula
// In this case another relation is created (NOT dependency)
if ( SUBJATTR[neg](#1,#2) )
//	NOT(#1,#2)
	ATTRIB[neg=+](#1,#2)



// Rule 701
// For the OBJCOMPL relation (e.g They considered him a fool) we have also an ATTRIB relation between the OBJ-N complement and the OBJCOMPL
// e.g. They considered him a fool -> ATTRIB(him,fool)
if ( OBJ-N(#1,#2) & OBJCOMPL(#1,#3) )
	ATTRIB(#2,#3)



// Rule 702
// Coordination
// Coordination of dependents
if ( ATTRIB[!features:!](#1,#2) & COORD(#3,#2) & COORD(#3,#4) & ~ATTRIB(#1,#4) )
	ATTRIB(#1,#4) 

// Rule 703
// Coordination of verbs and distribution of OBJ-N dependency
if ( OBJ-N[!features:!](#1,#2) & COORD(#3,#1) & COORD(#3,#4[trans:+]) & ~OBJ-N(#4,?) )
	OBJ-N(#4,#2)

// Rule 704
// Coordination of verbs and distribution of SUBJ-N dependency
if ( SUBJ-N[!features:!](#1,#2) & COORD(#3,#1) & COORD(#3,#4) & ~SUBJ-N(#4,?) )
	OBJ-N(#4,#2)


// Rule 705
if ( ATTRIB(#1,#2) & ^ATTRIB(#1,#2) )
	~


// Rule 706
// QUALIF relation.
// A qualificative adjective with the noun it qualifies
if ( NUCL[subjcompl](#1,#2[adj]) & SUBJ-N(#1,#3) & ~ATTRIB(#2,#3) )
	QUALIF(#3,#2)

// Rule 707
if ( MOD[pre](#1,#2[adj]) )
	QUALIF(#1,#2)




