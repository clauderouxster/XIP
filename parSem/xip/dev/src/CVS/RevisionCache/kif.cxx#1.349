/*
 * Xerox Research Centre Europe - Grenoble Laboratory
 *
 * Copyright (C) 2010 - 2011 Xerox Corporation, XRCE-Grenoble, All Rights Reserved.
 * This file can only be used with the XIP library or the KiF library, 
 * it should not and cannot be used otherwise.
 */
/* --- CONTENTS ---
   Project    : KiF
   Version    : 1.00
   filename   : kif.cxx
   Date       : 09/09/2010
   Purpose    : Implementation of the KiF language
   Programmer : Claude ROUX
   Reviewer   : 
*/

//#define PROFILING
#ifdef WIN32
#include "Windows.h"
#else
#include <pthread.h>
#endif

#include "kifn.h"
#include "kif.h"

#include "kifinit.h"
#include "automate.h"

#ifdef WIN32
#include <conio.h>
int GETCH(bool echoing) {
	ThreadLock _lock(kifInputchr);
	if (echoing==false)
		return _getch();
	int i=_getch();
	cout<<i;
	return i;
}
#else
#include <dlfcn.h>
#include <signal.h>
#include <termios.h>
int GETCH(bool echoing) {
	ThreadLock _lock(kifInputchr);
	struct termios t;
	tcgetattr(STDIN_FILENO, &t);
	t.c_lflag &= ~ICANON;
	if (echoing==false)
		t.c_lflag &= ~ECHO;
	tcsetattr(STDIN_FILENO, TCSANOW, &t);
	int c=getchar_unlocked();
	t.c_lflag |= ICANON;
	if (echoing==false)
		t.c_lflag |= ECHO;
	tcsetattr(STDIN_FILENO, TCSANOW, &t);
	return c;
}
#endif 


const char KIF_VERSION[]=KIFVERSION;
#define EXECUTABLE(xt) (xt>=kifInstruction && xt<=kifInstance)
#define CALLFUNCTION(xt) (xt->type>=kifCallFunction && xt->type<=kifCallFunctionGeneral)



Exported string Whoami_kif() {
	string s;
	s="KiF.";
	s+=KIF_VERSION;
	s+=Endl;
	s+="Copyright © Xerox Corporation 2010-2011";
	s+=Endl;
	s+="Xerox Research Center Europe";
	s+=Endl;
	s+="Implementation: Claude Roux";
	s+=Endl;
	return s;
}

static map<string,bool> kifConversionNames;
map<KifType,string> kifStringType;
map<KifType,unsigned long> kifTypeEncoding;
map<KifType,short> kifIdType;

class KifGlobalThread {
public:
	int kifnbthreads;
	LockedThread* threadloquet;

	KifGlobalThread() {
		kifnbthreads=0;
		threadloquet=NULL;
	}

	bool Test() {
		if (kifnbthreads==0)
			return false;
		return true;
	}

	void Increment() {
		ThreadLock _lock(kifThreading);
		kifnbthreads++;
		if (threadloquet==NULL)
			threadloquet=new LockedThread;
	}

	void Decrement() {
		ThreadLock _lock(kifThreading);
		kifnbthreads--;
		if (kifnbthreads==0) {
			threadloquet->Released();
			delete threadloquet;
			threadloquet=NULL;
		}
	}

	void WaitForTheEnd() {
		{
			ThreadLock _lock(kifThreading);
			if (threadloquet==NULL)
				return;
		}
		threadloquet->Blocked();
	}
} kifThreadControl;


static bool updatethread=true;
#ifdef WIN32
Exported ThreadLock::ThreadLock(KifType i) {
	if (updatethread==true) {
		updatethread=false;
		Initialise();
	}
	relax=-1;
	if (kifThreadControl.Test()==true) {
		relax=(int)i;
		if (table[relax]==0)
			table[relax]=CreateMutex(NULL,FALSE,NULL);
		WaitForSingleObject(table[relax],INFINITE);
	}
}

Exported void ThreadLock::Initialise() {
	for (int i=0;i<100;i++)
		table[i]=0;
}

Exported void ThreadLock::Clean() {
	for (int i=0;i<100;i++)
		if (table[i]!=0)
			CloseHandle(table[i]);
}
Exported ThreadLock::~ThreadLock() {
	if (relax!=-1)
		ReleaseMutex(table[relax]);
}

Exported KifThreadLock::KifThreadLock(HANDLE l,bool run) {
	lock=l;
	locked=run;
	if (run)
		WaitForSingleObject(lock,INFINITE);
}

Exported void KifThreadLock::Locking() {
	if (lock==NULL)
		lock=CreateMutex(NULL,FALSE,NULL);
	WaitForSingleObject(lock,INFINITE);
}

Exported void KifThreadLock::Unlocking() {
	ReleaseMutex(lock);
}

Exported KifThreadLock::~KifThreadLock() {
	if (locked)
		ReleaseMutex(lock);
	else
		if (lock!=NULL)
			CloseHandle(lock);
}

Exported LockedThread::LockedThread() {
	blocked=false;
	lock=CreateEvent(NULL,FALSE,FALSE,NULL);
}

Exported LockedThread::~LockedThread() {
	CloseHandle(lock);
}

Exported void LockedThread::Blocked() {
	blocked=true;
	WaitForSingleObject(lock,INFINITE);
}

Exported void LockedThread::Released() {
	SetEvent(lock);
}

Exported HANDLE ThreadLock::table[100];
#else //For other OS

//This method is used to create a mutex that counts up and does not block
void KifInitialisationMutex(pthread_mutex_t* mut) {
	static bool initial=true;
	static pthread_mutexattr_t mattr; 
	//We create it once for all
	if (initial==true) {
		pthread_mutexattr_init(&mattr);
		pthread_mutexattr_settype(&mattr,PTHREAD_MUTEX_RECURSIVE);
		initial=false;
	}
	pthread_mutex_init(mut,&mattr);
}

//this function is called when the main function has been interrupted
void cleanThreads(int i) {
	map<threadhandle,int>::iterator it;
	for (int i=0;i<kifCodeVector.size();i++) {		
		for (it=kifCodeVector[i]->threads.begin();it!=kifCodeVector[i]->threads.end();it++)
			pthread_cancel(it->first);
	}
	exit(-1);
}

ThreadLock::ThreadLock(KifType i) {
	relax=-1;
	if (kifThreadControl.Test()==true) {
		if (updatethread==true) {
			updatethread=false;
			signal(SIGPIPE,cleanThreads);
			signal(SIGINT,cleanThreads);
			Initialise();
		}		
		relax=(int)i;
		pthread_mutex_lock (&table[relax]);
	}
}

void ThreadLock::Initialise() {
	for (int i=0;i<100;i++)
		KifInitialisationMutex(&table[i]);
}


ThreadLock::~ThreadLock() {
	if (relax!=-1)
		pthread_mutex_unlock(&table[relax]);
}

Exported KifThreadLock::KifThreadLock(pthread_mutex_t* l,bool run) {
	lock=l;
	locked=run;
	if (run)
		pthread_mutex_lock(lock);
}

Exported void KifThreadLock::Locking() {
	if (lock==NULL) {
		lock=(pthread_mutex_t*)malloc(sizeof(pthread_mutex_t));
		KifInitialisationMutex(lock);
	}
	pthread_mutex_lock(lock);
}

Exported void KifThreadLock::Unlocking() {
	pthread_mutex_unlock(lock);
}


Exported KifThreadLock::~KifThreadLock() {
	if (locked)
		pthread_mutex_unlock(lock);
	else
		if (lock!=NULL)
			free(lock);
}

#ifdef APPLE
//Mac OS only provides "named" semaphores...
int LockedThread::naming=0;
Exported LockedThread::LockedThread() {
	blocked=false;
	sprintf(name,"/s_%d",naming);
	naming++;
	lock=sem_open(name,O_CREAT, 0777, 0);
}

Exported LockedThread::~LockedThread() {
	sem_unlink(name);
	sem_destroy(lock);
}
Exported void LockedThread::Blocked() {
	blocked=true;
	sem_wait(lock);
}


Exported void LockedThread::Released() {	
	sem_post(lock);
}
#else //Other UNIX systems
//In the other UNIX systems, we can use anonymous semaphores...
Exported LockedThread::LockedThread() {
	blocked=false;
	sem_init(&lock,0,0);
}

Exported LockedThread::~LockedThread() {
	sem_destroy(&lock);
}

Exported void LockedThread::Blocked() {
	blocked=true;
	sem_wait(&lock);
}


Exported void LockedThread::Released() {
	sem_post(&lock);
}
#endif

pthread_mutex_t ThreadLock::table[100];
#endif

int kif_declencheur=10000;

static int kifLastType=kifLASTYPE;


Exported int KifLoad(KifCode*,vector<string>& paths,vector<string>& arguments,bool debugkif);
int KifLoadPath(KifCode* kifcode,string& path,vector<string>& arguments,bool debugkif);
Exported string KifExecute(int ipar,string name,vector<string>& parameters,ostringstream* os,bool debugkif);
Exported void KifDelete(int ipar);
int KifLoadin(KifCode* kifcode,string path);
extern "C" {
void NormalisationNomFichier(char* nomFichier,char* tampon);
}
//----------------------------------------------------------------------------------------
#ifdef WIN32
#if defined(_MSC_VER) || defined(_MSC_EXTENSIONS)
  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000Ui64
#else
  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000ULL
#endif
int gettimeofday(struct timeval *tv, struct timezone *tz)
{
  FILETIME ft;
  unsigned __int64 tmpres = 0;
  static int tzflag;
 
  if (NULL != tv)
  {
    GetSystemTimeAsFileTime(&ft);
 
    tmpres |= ft.dwHighDateTime;
    tmpres <<= 32;
    tmpres |= ft.dwLowDateTime;
 
    /*converting file time to unix epoch*/
    tmpres -= DELTA_EPOCH_IN_MICROSECS; 
    tmpres /= 10;  /*convert into microseconds*/
    tv->tv_sec = (long)(tmpres / 1000000UL);
    tv->tv_usec = (long)(tmpres % 1000000UL);
  }
 
  return 0;
}
#endif

#ifdef PROFILING
map<string,int> kifstatistics;
void profilingcall(string s) {
	kifstatistics[s]+=1;
}

Exported void displaystatistics() {
	if (kifstatistics.size()==0)
		return;
	map<string,int>::iterator it;
	string maxs;
	string mins;
	int max=-1;
	int min=-1;
	int cpt=0;
	float avg;
	for (it=kifstatistics.begin();it!=kifstatistics.end();it++) {
		if (it->second>max) {
			max=it->second;
			maxs=it->first;
		}
		if (min==-1 || min>it->second) {
			min=it->second;
			mins=it->first;
		}
		cpt+=it->second;
	}
	avg=cpt/kifstatistics.size();
	for (it=kifstatistics.begin();it!=kifstatistics.end();it++)
		cout<<STR(it->first)<<":"<<it->second<<Endl;
	cout<<Endl<<"----------"<<Endl;
	cout<<"Max: "<<STR(maxs)<<"="<<max<<Endl;
	cout<<"Min: "<<STR(mins)<<"="<<min<<Endl;
	cout<<"Count: "<<cpt<<Endl;
	cout<<"Avg: "<<avg<<Endl;
}
#else
Exported void displaystatistics() {}
#endif

Exported void CreationRepertoire(char* noms,int pos) {
	char* pt=strchr(noms+pos,SEP);
	while (pt!=NULL) {
		*pt=0;
#ifdef WIN32
		CreateDirectory(noms,NULL);
#else
		mkdir(noms,S_IRWXU | S_IRWXG | S_IRWXO);
#endif
		*pt=SEP;
		pt=strchr(pt+1,SEP);
	}
#ifdef WIN32
		CreateDirectory(noms,NULL);
#else
		mkdir(noms,S_IRWXU | S_IRWXG | S_IRWXO);
#endif
}

#ifdef APPLE
extern "C" {
	int    gethostuuid(uuid_t id, const struct timespec *wait) {
		return -1;
	}
}
#endif

char* kifErrorStrings[]={
	"KIF(0): Wrong number of parameters in SPLIT",
	"KIF(1): Wrong 3rd parameter in SPLIT",
	"KIF(2): Wrong number of parameters in LIST",
	"KIF(3): Wrong number of parameters in UTF8",
	"KIF(4): Wrong number of parameters in LATIN",
	"KIF(5): Wrong number of parameters in LEFT",
	"KIF(6): Wrong number of parameters in RIGHT",
	"KIF(7): Wrong number of parameters in MID",
	"KIF(8): Wrong number of parameters in ISLOWER",
	"KIF(9): Wrong number of parameters in ISUPPER",
	"KIF(10): Wrong number of parameters in LOWER",
	"KIF(11): Wrong number of parameters in UPPER",
	"KIF(12): Wrong number of parameters in TRIM",
	"KIF(13): Wrong number of parameters in SETDATE",
	"KIF(14): Wrong time parameter in SETDATE",
	"KIF(15): Wrong number of parameters in DATE",
	"KIF(16): Wrong time parameter in DATE",
	"KIF(17): Wrong number of parameters in YEAR",
	"KIF(18): Wrong time parameter in YEAR",
	"KIF(19): Wrong number of parameters in DAY",
	"KIF(20): Wrong time parameter in DAY",
	"KIF(21): Wrong number of parameters in HOUR",
	"KIF(22): Wrong time parameter in HOUR",
	"KIF(23): Wrong number of parameters in MONTH",
	"KIF(24): Wrong time parameter in MONTH",
	"KIF(25): Missing parameter in RAISE",
	"KIF(26): Wrong number of parameters in WRITE",
	"KIF(27): First parameter in WRITE should be a file",
	"KIF(28): First parameter in READ should be a file",
	"KIF(29): First parameter in READLN should be a file",
	"KIF(30): First parameter in CLOSE should be a file",
	"KIF(31): First parameter in OPENREAD should be a file",
	"KIF(32): Error in OPENREAD while opening the file:",
	"KIF(33): First parameter in EOF should be a file",
	"KIF(34): First parameter in OPENWRITE should be a file",
	"KIF(35): Error in OPENWRITE while opening the file:",
	"KIF(36): Wrong number of parameters in INSERT",
	"KIF(37): Wrong call to INSERT",
	"KIF(38): Wrong number of parameters in PUSH",
	"KIF(39): Wrong call to a PUSH",
	"KIF(40): Wrong number of parameters in POP",
	"KIF(41): Wrong call to a POP",
	"KIF(42): Wrong number of parameters in LAST",
	"KIF(43): Unknown NODE in LAST",
	"XIP(44): Unknown GENERATION NODE in LAST",
	"KIF(45): Wrong call to LAST",
	"KIF(46): Wrong number of parameters in SORT",
	"KIF(47): Wrong call to a SORT",
	"KIF(48): Missing parameters in APPLY",
	"KIF(49): Wrong call to APPLY",
	"XIP(50): Wrong number of parameters in CREATEDEPENDENCY",
	"XIP(51): Unknown dependency:",
	"XIP(52): 2nd parameter should be a MAP in CREATEDEPENDENCY",
	"XIP(53): 3rd parameter should be a VECTOR in CREATEDEPENDENCY",
	"XIP(54): 3rd parameter should only contain NODE in CREATEDEPENDENCY",
	"XIP(55): 3rd parameter should only contain NODE in CREATEDEPENDENCY",
	"XIP(56): Unknown feature: ",
	"XIP(57): Dependency not created",
	"XIP(58): Wrong number of parameters in SETFEATURE",
	"XIP(59): Wrong type of variable in SETFEATURE",
	"XIP(60): Unknown feature: ",
	"XIP(61): Wrong number of parameters in REMOVEFEATURE",
	"XIP(62): Wrong type of variable in REMOVEFEATURE",
	"XIP(63): Unknown attribute: ",
	"XIP(64): Wrong number of parameters in FEATURE",
	"XIP(65): Wrong type of variable in FEATURE",
	"XIP(66): Unknown attribute: ",
	"XIP(67): Unknown feature value: ",
	"XIP(68): Parameter should be either a VECTOR or a MAP in CLEAR",
	"XIP(69): Second parameter should be a MAP in DATA",
	"XIP(70): Unknown NODE in DATA",
	"XIP(71): Unknown DEPENDENCY in DATA",
	"XIP(72): No DATA for this variable",
	"XIP(73): Unknown NODE in NAME",
	"XIP(74): Unknown DEPENDENCY in NAME",
	"XIP(75): No NAME for this variable",
	"XIP(76): Wrong number of parameters in STACK",
	"XIP(77): 2nd parameter should be a VECTOR in STACK",
	"XIP(78): Unknown dependency in STACK",
	"XIP(79): No STACK for this variable",
	"KIF(80): Wrong number of parameters in PARAMETERS",
	"KIF(81): 2nd parameter should be a VECTOR in PARAMETERS",
	"KIF(82): Unknown dependency in PARAMETERS",
	"KIF(83): No PARAMETERS for this variable",
	"KIF(84): Wrong number of parameters in REMOVEFIRST",
	"KIF(85): No REMOVEFIRST for this variable",
	"KIF(86): Wrong number of parameters in INSTANCES",
	"KIF(87): No INSTANCES for this variable",
	"KIF(88): Wrong number of parameters in SET",
	"KIF(89): Wrong number of parameters in REGEX",
	"KIF(90): Missing class in MATRIX SET",
	"KIF(91): Missing attribute in MATRIX SET",
	"KIF(92): No SET for this variable",
	"KIF(93): Wrong number of parameters in GET",
	"KIF(94): Missing class in MATRIX GET",
	"KIF(95): Missing attribute in MATRIX GET",
	"XIP(96): No GET for this variable",
	"XIP(97): Wrong number of parameters in OFFSET",
	"XIP(98): Unknown node in OFFSET",
	"XIP(99): No OFFSET for this variable",
	"XIP(100): Wrong number of parameters in OFFSETCHAR",
	"XIP(101): Unknown node in OFFSETCHAR",
	"XIP(102): No OFFSETCHAR for this variable",
	"XIP(103): Wrong number of parameters in TOKENOFFSET",
	"XIP(104): Unknown node in TOKENOFFSET",
	"XIP(105): No TOKENOFFSET for this variable",
	"XIP(106): Wrong number of parameters in LEFTOFFSET",
	"XIP(107): Unknown node in LEFTOFFSET",
	"XIP(108): No LEFTOFFSET for this variable",
	"XIP(109): Wrong number of parameters in RIGHTOFFSET",
	"XIP(110): Unknown node in RIGHTOFFSET",
	"XIP(111): No RIGHTOFFSET for this variable",
	"XIP(112): Wrong number of parameters in LEFTOFFSETCHAR",
	"XIP(113): Unknown node in LEFTOFFSETCHAR",
	"XIP(114): No LEFTOFFSETCHAR for this variable",
	"XIP(115): Wrong number of parameters in RIGHTOFFSETCHAR",
	"XIP(116): Unknown node in RIGHTOFFSETCHAR",
	"XIP(117): No RIGHTOFFSETCHAR for this variable",
	"XIP(118): Wrong number of parameters in LEFTTOKENOFFSET",
	"XIP(119): Unknown node in LEFTTOKENOFFSET",
	"XIP(120): No LEFTTOKENOFFSET for this variable",
	"XIP(121): Wrong number of parameters in RIGHTTOKENOFFSET",
	"XIP(122): Unknown node in RIGHTTOKENOFFSET",
	"XIP(123): No RIGHTTOKENOFFSET for this variable",
	"XIP(124): No LEMMA for this variable",
	"XIP(125): Wrong number of parameters in REMOVELAST",
	"XIP(126): No REMOVELAST for this variable",
	"XIP(127): No SURFACE for this variable",
	"XIP(128): Wrong number of parameters in REPLACE",
	"XIP(129): Wrong number of parameters in LOAD",
	"XIP(130): No XMLNODE for this NODE",
	"KIF(131): Unknown parameter in LOAD",
	"KIF(132): BEGIN failed for this ITERATOR",
	"KIF(133): END failed for this ITERATOR",
	"KIF(134): NEND failed for this ITERATOR",
	"KIF(135): No KEY for this ITERATOR",
	"KIF(136): No VALUE for this ITERATOR",
	"KIF(137): No VALUETYPE for this ITERATOR",
	"XIP(138): Unknown NODE in NEXT",
	"XIP(139): Unknown GENERATION NODE in NEXT",
	"KIF(140): Unknown XML in NEXT",
	"XIP(141): No NEXT for this variable",
	"XIP(142): Unknown NODE in PREVIOUS",
	"XIP(143): Unknown GENERATION NODE in PREVIOUS",
	"XIP(144): Unknown XML in PREVIOUS",
	"XIP(145): No PREVIOUS for this variable",
	"XIP(146): Unknown NODE in PARENT",
	"XIP(147): Unknown GENERATION NODE in PARENT",
	"XIP(148): Unknown XML in PARENT",
	"XIP(149): No PARENT for this variable",
	"XIP(150): Unknown NODE in CHILD",
	"XIP(151): Unknown GENERATION NODE in CHILD",
	"XIP(152): Unknown XML in CHILD",
	"XIP(153): No CHILD for this variable",
	"KIF(154): Wrong TYPE for a WRITE",
	"KIF(155): Wrong frame affectation",
	"KIF(156): Wrong CALL affectation",
	"KIF(157): ", //used, do not modify
	"KIF(158): Please check the number of parameters in: ",
	"KIF(159): Please check the parameters in: ",
	"KIF(160): Wrong frame initialisation",
	"KIF(161): Wrong number of parameters in SEEK",
	"KIF(162): First parameter shoud be a file in SEEK",
	"KIF(163): Wrong number of parameters in TELL",
	"KIF(164): First parameter shoud be a file in TELL",
	"KIF(165): Wrong number of parameters in JOIN",
	"KIF(166): Wrong parameter in JOIN",
	"KIF(167): Wrong number of parameters in COMPILE",
	"KIF(168): Wrong parameter in COMPILE",
	"KIF(169): Wrong number of parameters in SUM",
	"KIF(170): Wrong parameter in SUM",
	"KIF(171): Wrong number of parameters in PRODUCT",
	"KIF(172): Wrong parameter in PRODUCT",
	"KIF(173): Wrong number of parameters in UNGET",
	"KIF(174): No UNGET for this variable",
	"KIF(175): Wrong number of parameters in REVERSE",
	"KIF(176): Wrong number of parameters in EXTRACT",
	"KIF(177): Wrong parameter in EXTRACT",
	"KIF(178): Unknown function: ",
	"XIP(179): This parser has already been loaded",
	"XIP(180): Wrong number of parameters in PARSE",
	"XIP(181): Empty grammar in PARSE",
	"XIP(182): Wrong parameters in PARSE",
	"XIP(183): Unknown instance: ",
	"KIF(184): Loading error: ",
	"KIF(185): Missing parameter in HASH",
	"KIF(186): Wrong number of parameters in VALUES",
	"KIF(187): Wrong type of parameter in VALUES",
	"KIF(188): Wrong number of parameter or wrong type in SPLITRGX",
	"KIF(189): library failed to load: ",
	"KIF(190): Missing Entry Point KifInitialisationModule in: ",
	"KIF(191): Wrong number of parameters in FILEINFO",
	"KIF(192): Wrong number of parameters in KEYS",
	"KIF(193): Wrong type of parameter in KEYS",
	"KIF(194): Wrong number of parameters in FIND",
	"KIF(195): Wrong number of parameters in COMP",
	"KIF(196): Wrong type of parameters in: ",
	"KIF(197): Wrong number of parameters in KILL",
	"KIF(198): Wrong number of parameters in CAST",
	"KIF(199): Wrong number of parameters in WAIT",
	"KIF(200): Wrong number of parameters in WAITING",
	"KIF(201): Wrong parameter: expecting a TREE element",
	"KIF(202): Missing TREE parameter",
	"KIF(203): Wrong number of parameters",
	"KIF(204): Error: The parameter TREE is a parent of the target TREE",
	"KIF(205): You cannot move a node to itself",
	"KIF(206): Cannot initialize a vector with this value",
	"KIF(207): Cannot initialize a map with this value",
	"KIF(208): Wrong number of parameters in FILL",
	"KIF(209): Too long a size in FILL",
	"KIF(210): Wrong initial parameter in FILL",
	"KIF(211): Cannot create THREAD",
	"KIF(212): Only one WAIT string is accepted in a thread",
	"KIF(213): WAITALL is not accepted in a thread",
	"KIF(214): No parameters expected in GETC",
	"KIF(215): Wrong parameters in ADDOPTION",
	"KIF(216): Wrong parameters in REMOVEOPTION",
	"KIF(217): WAIT are forbiden in a CATCH section",
	"KIF(218): Wrong number of parameters in RESET",
	"KIF(219): Wrong parameter in RESET",
	"KIF(220): Cannot initialize a list with this value",
	"KIF(221): Wrong number of parameters in _CLOSE",
	"KIF(222): Unknown session",
	"KIF(223): Wrong number of parameters in _COMPILE",
	"KIF(224): Wrong number of parameters in _RUN",
	"KIF(225): Divided by zero",
	"KIF(226): Wrong number of parameters in RANGE",
	"KIF(227): RANGE over actual capacity",
	"KIF(228): Wrong number of parameter or wrong type in FORMAT",
	"XIP(229): Unknown function: ",
	"KIF(230): String should be one character long in RANGE",
	"KIF(231): No compatible function found or unknown function: ",
	"KIF(232): Empty CALL variable",
	"KIF(233): Unknown object: ",
	"KIF(234): Object already exists: ",
	"KIF(235): Wrong use of 'this': ",
	"KIF(236): Wrong call to a function in a APPLY",
	"KIF(237): Missing parameter in SYNCHRONIZED",
	"KIF(238): Missing parameter in LOCK",
	"KIF(239): Missing parameter in UNLOCK",
	"KIF(240): Unknown lock: ",
	"KIF(241): Bad use of RETURN",
	"KIF(242): Wrong comparison definition",
	""
};


//===================================================================
//List of all KifCode in memory
VECTA<KifCode*> kifCodeVector;
hmap<string,int> kifCodePaths;
hmap<string,KifExternalModule> kifLibraries;
hmap<string,KifExternalModule> kifTerminateLibraries;

Exported bool KifRecordLibraries(string name,KifExternalModule module) {
	if (kifLibraries.find(name)!=kifLibraries.end())
		return false;
	
	if (module==NULL)
		return true;

	kifLibraries[name]=module;
	return true;
}

Exported bool KifRecordTerminateModule(string name,KifExternalModule module) {
	if (kifTerminateLibraries.find(name)!=kifTerminateLibraries.end())
		return false;
	
	if (module==NULL)
		return true;

	kifTerminateLibraries[name]=module;
	return true;
}

//===================================================================

#ifndef WIN32
#define sprintf_s(a,b,c,d) sprintf(a,c,d)
#define strcpy_s(a,b,c) strcpy(a,c)
#endif

//===================================================================
Exported hmap<string,short>* kifStringId=NULL;
Exported hmap<short,string>* kifIdString=NULL;
Exported short idthis;
Exported short idnull;
Exported short idsequence;
Exported short idcatch;
Exported short id_call;
Exported short idself;
Exported short idin;
Exported short id_initial;
Exported short idstring;
Exported short idfloat;
Exported short idint;
Exported short idboolean;
Exported short idfraction;

Exported short idsize;
Exported short idget;
Exported short idinferior;
Exported short idsuperior;
Exported short idequal;
Exported short iddifferent;
Exported short idinferiorequal;
Exported short idsuperiorequal;
Exported short idmethods;
Exported short idvector;
Exported short idmap;
Exported short idapply;


Exported short idorset;
Exported short idandset;
Exported short idxorset;
Exported short idplusplus;
Exported short idminusminus;
Exported short idplus;
Exported short idminus;
Exported short idmultiply;
Exported short iddivide;
Exported short idpower;
Exported short idshiftleft;
Exported short idshiftright;
Exported short idmod;
Exported short idinterval;
Exported short idindex;

short idsynchronous;

Exported string KifIdString(short n) {
	hmap<short,string>::iterator it=kifIdString->find(n);
	if (it!=kifIdString->end())
		return it->second;
	return "";
}

Exported short KifNewId(string n) {
	hmap<string,short>::iterator it=kifStringId->find(n);
	if (it==kifStringId->end()) {
		int id=kifStringId->size();
		(*kifStringId)[n]=id;
		(*kifIdString)[id]=n;
		return id;
	}
	return it->second;
}

Exported short KifStringId(string n) {
	hmap<string,short>::iterator it=kifStringId->find(n);
	if (it==kifStringId->end())
		return -1;
	return it->second;
}

//===================================================================
//Conversion from string to double...
double convertfloat(char* s) {
	long v=0;
	long point=0;
	int i=0;
	long mantissa=0;
	while (s[i]!=0) {
		if (s[i]=='.') {
			mantissa=1;
			i++;
			continue;
		}
		if (s[i]<48 || s[i]>58) {
			i++;
			continue;
		}
		if (!mantissa) {
			v*=10;
			v+=s[i]-48;
		}
		else {
			point*=10;
			point+=s[i]-48;
			mantissa*=10;
		}
		i++;
	}
	double d=v;
	d+= ((double)point)/mantissa;
	return d;
}
		
		
//===================================================================
int KifCode::GetThreadid() {
	ThreadLock _lock(kifThreadId);
	if (kifThreadControl.Test()==false)
		return -1;
#ifdef WIN32
	threadhandle tid=GetCurrentThreadId();
#else
	threadhandle tid= pthread_self();
#endif
	map<threadhandle,int>::iterator it=threads.find(tid);
	if (it==threads.end())
		return -1;
	return it->second;
}

void KifCode::SetThreadid(threadhandle tid,int thid) {
	ThreadLock _lock(kifThreadId);
	threads[tid]=thid;	
	used[thid]=0;
}

void KifCode::EraseThreadid(threadhandle tid) {
	ThreadLock _lock(kifThreadId);
	threads.erase(tid);
}

void KifCode::Gets() {
	string s;
	getline(cin,s);
	if (s.size()<1023) {
		strcpy_s(buffer,1023,STR(s));
		buffer[s.size()]=0;
	}
	else {
		memcpy(buffer,STR(s),1022);
		buffer[1023]=0;
	}
}

string& Trim(string& chaine) {
	int d,f;
	for (d=0;d<chaine.size();d++) {
		if ((uchar)chaine[d]>32)
			break;
	}

	for (f=chaine.size()-1;f>=0;f--) {
		if ((uchar)chaine[f]>32)
			break;
	}
	int lg=f-d+1;
	if (lg>=1)
		chaine=chaine.substr(d,lg);
	else
		chaine="";
	return chaine;
}

string& Trimleft(string& chaine) {
	int d,f;
	f=chaine.size()-1;
	for (d=0;d<chaine.size();d++) {
		if ((uchar)chaine[d]>32)
			break;
	}

	int lg=f-d+1;
	if (lg>=1)
		chaine=chaine.substr(d,lg);
	else
		chaine="";
	return chaine;
}

string& Trimright(string& chaine) {
	int d=0,f;

	for (f=chaine.size()-1;f>=0;f--) {
		if ((uchar)chaine[f]>32)
			break;
	}

	int lg=f-d+1;
	if (lg>=1)
		chaine=chaine.substr(d,lg);
	else
		chaine="";
	return chaine;
}

inline string IntegerString(long value) {
	ostringstream is;
	is<<value;
	return is.str();
}

inline string FloatString(double value) {
	ostringstream is;
	is<<value;
	return is.str();
}


int Stringsplit(string thestr,string thesplitter,vector<string>& vect) {
	size_t pos=0;
	size_t found=0;

	while (pos!=-1) {
		found=thestr.find(thesplitter,pos);
		if (found!=-1) {
			string n=thestr.substr(pos,found-pos);
			if (n!="")
				vect.push_back(n);
			pos=found+thesplitter.size();
		}
		else
			break;
	}
	string s=thestr.substr(pos,thestr.size()-pos);
	if (s!="")
		vect.push_back(s);
	return vect.size();
}

//We only create a new vector or a new map if we are not in a context where the current map or vector cannot be used
KifVector* Selectvector(KifElement* kref,KifElement* context) {
	KifVector* kvect;
	if (context!=NULL && context!=kref && context->Assigning(kifVector)) {
		kvect=(KifVector*)context;
		kvect->Clear();
		return kvect;
	}

	return kref->kifcode->Providevector();
}

KifMap* Selectmap(KifElement* kref,KifElement* context) {
	KifMap* kmap;
	if (context!=NULL && context!=kref && context->Assigning(kifMap)) {
		kmap=(KifMap*)context;
		kmap->Clear();
		return kmap;
	}

	return kref->kifcode->Providemap();
}



#ifdef _DEBUG
KifCode* currentkifcode;
#endif

typedef KifElement* (KifCode::*KifParseElement)(x_node*,KifElement*);
typedef KifElement* (KifInstruction::*ExecuteInstruction)(KifElement* contextualpattern,KifDomain* dom,KifElement* ke);


hmap<short,mathFunc> kifMathFunctions;
static hmap<short,bool> kifReturnString;
static hmap<short,bool> kifReturnInt;
static hmap<short,bool> kifReturnFloat;

static hmap<short,bool> kifPredefinedFunctions;
static hmap<short,bool> kifMethods;

static hmap<short,bool> kifTreeFunctions;
static hmap<short,bool> kifStringFunctions;
static hmap<short,bool> kifMatrixFunctions;
static hmap<short,bool> kifDateFunctions;
static hmap<short,bool> kifTimeFunctions;
static hmap<short,bool> kifKiFFunctions;
static hmap<short,bool> kifFileFunctions;
static hmap<short,bool> kifIteratorFunctions;
static hmap<short,bool> kifNumericalFunctions;

hmap<short,bool> kifVectorFunctions;
hmap<short,bool> kifListFunctions;
hmap<short,bool> kifMapFunctions;


bool TestkifFunctions(short n,hmap<short,bool>& kiffunc) {
	hmap<short,bool>::iterator it=kiffunc.find(n);
	if (it==kiffunc.end())
		return false;
	return true;
}


hmap<string,KifParseElement> kifFunctions;
hmap<string,KifParseElement> kifTypes;
static hmap<string,KifOperator> kifOperators;
static hmap<string,string> kifMetaCharacters;
static map<KifType,bool> kifClean;
static bool kifOperatorMath[kifLASTDECLARATION+1];


KifElement* kifNOELEMENT=NULL;
KifElement* kifNULL=NULL;
KifElement* kifTRUE=NULL;
KifElement* kifFALSE=NULL;
KifElement* kifMINUSONE=NULL;
KifElement* kifDEFAULT=NULL;
KifElement* kifBREAK=NULL;
KifElement* kifBREAKPOINT=NULL;
KifElement* kifCONTINUE=NULL;
KifElement* kifNEG=NULL;

static map<string,string> kifInformationsString;
static map<string,string> kifInformationsInt;
static map<string,string> kifInformationsFloat;
static map<string,string> kifInformationsVector;
static map<string,string> kifInformationsList;
static map<string,string> kifInformationsMap;
static map<string,string> kifInformationsTree;
static map<string,string> kifInformationsMatrix;
static map<string,string> kifInformationsIterator;
static map<string,string> kifInformationsDate;
static map<string,string> kifInformationsTime;
static map<string,string> kifInformationsFile;
static map<string,string> kifInformationsKif;


void KifInitInformations() {
	kifInformationsString["split"]="split(string splitter,vector vect): split a string along splitter and store the results  in a vector. If splitter==, then the string is split into a vector of characters";
	kifInformationsString["removefirst"]="removefirst(int nb): remove the first nb characters of a string";
	kifInformationsString["removelast"]="removelast(int nb): remove the last nb characters of a string";
	kifInformationsString["left"]="left(int nb): return the first nb characters of a string";
	kifInformationsString["right"]="right(int nb): return the last nb characters of a string";
	kifInformationsString["mid"]="mid(int pos,int nb): return the nb characters starting at position pos of a string";
	kifInformationsString["reverse"]="reverse(): reverse the string";
	kifInformationsString["pop"]="pop(i): remove character at position i";
	kifInformationsString["pop"]="pop(): remove last character";
	kifInformationsString["last"]="last(): return last character";
	kifInformationsString["insert"]="insert(i,s): insert the string s at I";
	kifInformationsString["trim"]="trim(): remove the trailing characters";
	kifInformationsString["trimright"]="trimright(): remove the trailing characters on the right";
	kifInformationsString["trimleft"]="trimleft(): remove the trailing characters on the left";
	kifInformationsString["upper"]="upper(): Return the string in upper characters";
	kifInformationsString["lower"]="lower(): Return the string in lower characters";
	kifInformationsString["islower"]="islower(): Test if a string only contains lowercase characters";
	kifInformationsString["isupper"]="isupper(): Test if a string only contains uppercase characters";
	kifInformationsString["isalpha"]="isalpha(): Test if a string only contains only alphabetical characters";
	kifInformationsString["isdigit"]="isdigit(): Test if a string only contains digits";
	kifInformationsString["latin"]="latin(): convert an UTF8 string in LATIN";
	kifInformationsString["utf8"]="utf8(): convert a LATIN string into UTF8";
	kifInformationsString["find"]="find(string sub,int pos): Return the position of substring sub starting at position pos";
	kifInformationsString["rfind"]="rfind(string sub,int pos): Return the position of substring sub backward starting at position pos";
	kifInformationsString["replace"]="replace(sub,str): Replace the substrings matching sub with str";
	kifInformationsString["replacergx"]="replacergx(rgx,str): Replace the substrings matching rgx with str";
	kifInformationsString["splitrgx"]="splitrgx(rgx): Split string with regular expression rgx. Return a vector of substrings.";
	kifInformationsString["boolean=regex"]="boolean=regex(rgx): Test if the regular expression rgx applies to string";
	kifInformationsString["vector=regex"]="vector=regex(rgx): Return all substrings matching rgx";
	kifInformationsString["string=regex"]="string=regex(rgx): Return the substring matching rgx in the string";
	kifInformationsString["int=regex"]="int=regex(rgx): Return the position of the substring matching rgx in the string";
	kifInformationsInt["log"]="log(): return the log base 10 of the value";
	kifInformationsFloat["log"]="log(): return the log base 10 of the value";
	kifInformationsInt["ln"]="ln(): return the neperian log";
	kifInformationsFloat["ln"]="ln(): return the neperian log";
	kifInformationsInt["exp"]="exp(): return the exponential";
	kifInformationsFloat["exp"]="exp(): return the exponential";
	kifInformationsInt["sqrt"]="sqrt(): return the square root";
	kifInformationsFloat["sqrt"]="sqrt(): return the square root";
	kifInformationsInt["d"]="d(): Denominator of a fraction (with a parameter: set the value, without parameter return the value)";
	kifInformationsInt["n"]="n(): Numerator of a fraction (with a parameter: set the value, without parameter return the value)";
	kifInformationsInt["nd"]="nd(int n,int d): Set the Numerator and the Denominator of a fraction";
	kifInformationsInt["tan"]="tan(): tangent";
	kifInformationsFloat["tan"]="tan(): tangent";
	kifInformationsInt["sin"]="sin(): sinus";
	kifInformationsFloat["sin"]="sin(): sinus";
	kifInformationsInt["cos"]="cos(): cosinus";
	kifInformationsFloat["cos"]="cos(): cosinus";
	kifInformationsInt["atan"]="atan(): arc tangent";
	kifInformationsFloat["atan"]="atan(): arc tangent";
	kifInformationsInt["#"]="#(): return the bit complement";
	kifInformationsFloat["#"]="#(): return the bit complement";
	kifInformationsInt["format"]="format(string form): return a string formatted according to the pattern in form. (this format is the same as the sprintf format in C++)";
	kifInformationsFloat["format"]="format(string form): return a string formatted according to the pattern in form. (this format is the same as the sprintf format in C++)";
	kifInformationsString["get"]="get(): Read a string from keyboard";
	kifInformationsInt["get"]="get(): Read a number from keyboard";
	kifInformationsFloat["get"]="get(): Read a number from keyboard";
	
	kifInformationsVector["push"]="push(a): add a to the vector";
	kifInformationsVector["pop"]="pop(int i): remove the ith element from the vector and return it.";
	kifInformationsVector["pop"]="pop(): remove the last element from the vector and return it.";
	kifInformationsVector["last"]="last(): return the last element of the vector";
	kifInformationsVector["reverse"]="reverse(): reverse the order of the elements in the vector";
	kifInformationsVector["join"]="join(string sep): concatenate each element in the vector in a string where each element is separated from the others with sep";
	kifInformationsVector["insert"]="insert(i,x): insert the element x at position i";
	kifInformationsVector["sum"]="sum(): Sum each element with the others";
	kifInformationsVector["product"]="product(): Multiply each element with the others";
	kifInformationsVector["clear"]="clear(): clean the vector";
	kifInformationsVector["sort"]="sort(compare): sort the content of the vector according to compare function.";
	kifInformationsVector["apply"]="apply(a,b,c): apply all XIP rules stored in the vector, passing a,b,c etc. as parameters.";
	kifInformationsList["pushfirst"]="pushfirst(a): add a to the beginning of the list";
	kifInformationsList["pushlast"]="pushlast(a): add a at the end of the list";
	kifInformationsList["popfirst"]="popfirst(): remove the first element from the list and return it.";
	kifInformationsList["poplast"]="poplast(): remove the last element from the list and return it.";
	kifInformationsList["last"]="last(): return the last element of the list";
	kifInformationsList["first"]="last(): return the first element of the list";
	kifInformationsList["reverse"]="reverse(): reverse the order of the elements in the list";
	kifInformationsList["join"]="join(string sep): concatenate each element in the list in a string where each element is separated from the others with sep";
	kifInformationsList["insert"]="insert(i,x): insert the element x at position i";
	kifInformationsList["sum"]="sum(): Sum each element with the others";
	kifInformationsList["product"]="product(): Multiply each element with the others";
	kifInformationsList["apply"]="apply(a,b,c): apply all XIP rules stored in the list, passing a,b,c etc. as parameters.";
	kifInformationsList["clear"]="clear(): clean the list";	
	
	kifInformationsMap["sum"]="sum(): Sum each element with the others";
	kifInformationsMap["product"]="product(): Multiply each element with the others";
	kifInformationsMap["pop"]="pop(string key): remove the elements matching key";
	kifInformationsMap["keys"]="keys(): returns the map keys as a vector";
	kifInformationsMap["values"]="values(): return the values as a vector";
	kifInformationsMap["clear"]="clear(): clean the vector";
	kifInformationsTree["tree"]="tree(value): create a tree node, with value as a value. Value can have any types";
	kifInformationsTree["tree n=100"]="tree n=100: modify the value of a tree node with anything, here with an integer, but it could any object.";
	kifInformationsTree["next"]="next(): return the next tree node as a tree object";
	kifInformationsTree["previous"]="previous(): return the first tree node as a tree object";
	kifInformationsTree["child"]="child(): return the first tree node as a tree object";
	kifInformationsTree["parent"]="parent(): return the parent tree node as a tree object";
	kifInformationsTree["last"]="last(): return the last child tree node as a tree object";
	kifInformationsTree["next"]="next(tree n): compare the next tree node with n";
	kifInformationsTree["previous"]="previous(tree n): compare the previous tree node with n";
	kifInformationsTree["child"]="child(tree n): Test if the current node is a child of n";
	kifInformationsTree["parent"]="parent(tree n): Test if the current node is a parent of n";
	kifInformationsTree["last"]="last(tree n): Test if the current node is the last child of n";
	kifInformationsTree["addchild"]="addchild(tree n): Add n at the end of the children of the current tree node";
	kifInformationsTree["addnext"]="addnext(tree n): Add n after the current tree node";
	kifInformationsTree["addprevious"]="addprevious(tree n): Add n before the current tree node";
	kifInformationsTree["extract"]="extract(): Extract the current node from its tree";
	kifInformationsTree["remove"]="remove(): Delete the current sub-tree from the global tree";
	kifInformationsTree["depth"]="depth(): Return the depth of the node in the tree";
	kifInformationsMatrix["instances"]="instances(): return the number of  instances in the matrix";
	kifInformationsMatrix["set"]="set(int instance,string class,string attribute, value): Add an element with a class instance value, according to an attribute and an instance Id.";
	kifInformationsMatrix["get"]="get(int instance,string class,string attribute): Return the element with a specific class instance value, according to an attribute and an instance Id.";
	kifInformationsMatrix["clear"]="clear(): clean the vector";
	kifInformationsMatrix["save"]="save(filename,type): save the matrix on the disk. type can take two values";
	kifInformationsIterator["value"]="value(): return the value of the current element";
	kifInformationsIterator["key"]="key(): return the key of the current element";
	kifInformationsIterator["valuetype"]="valuetype(): return the value type of the current element";
	kifInformationsIterator["isvaluetype"]="isvaluetype(string type): test the type of the current element";
	kifInformationsIterator["begin"]="begin(): initialiaze the iterator with the beginning of the collection";
	kifInformationsIterator["next"]="next(): next element in the collection";
	kifInformationsIterator["end"]="end(): return true when the end of the collection is reached";
	kifInformationsIterator["nend"]="nend(): return true while the end of the collection has not been reached (~end())";
	kifInformationsIterator["apply"]="apply(a,b,c): apply a XIP rule or a function";
	kifInformationsDate["setdate"]="setdate(year,month,day,hour,min,sec): set a time variable";
	kifInformationsDate["date"]="date(): return the date as a string";
	kifInformationsDate["year"]="year(): return the year as an integer";
	kifInformationsDate["month"]="month(): return the month as an integer";
	kifInformationsDate["day"]="day(): return the day as an integer";
	kifInformationsDate["hour"]="hour(): return the hour as an integer";
	kifInformationsDate["min"]="min(): return the min as an integer";
	kifInformationsDate["sec"]="sec(): return the sec as an integer";
	kifInformationsTime["reset"]="reset (): reinitialize a time variable";
	kifInformationsFile["openappend"]="openappend(string filename): open a file in append writing mode";
	kifInformationsFile["openwrite"]="openwrite(string filename): open a file in write mode";
	kifInformationsFile["openread"]="openread(string filename): open a file in read mode";
	kifInformationsFile["write"]="write(string s1,string s2,): write strings in the file";
	kifInformationsFile["get"]="get(): read one character from the file";
	kifInformationsFile["unget"]="unget(): return one character to the stream";
	kifInformationsFile["unget"]="unget(nb): return nb character to the stream";
	kifInformationsFile["read"]="read(): read a line from a file";
	kifInformationsFile["readln"]="readln(): read a line from a file";
	kifInformationsFile["seek"]="seek(int p): position the file cursor at p";
	kifInformationsFile["tell"]="tell(): return the position of the file cursor";
	kifInformationsFile["eof"]="eof(): return true when the end of file is reached";
	

	kifInformationsKif["load"]="load(string kifpathname): Load a KiF program";
	kifInformationsKif["name"]="name(): Return the pathname of the grm file";
	kifInformationsKif["_loader"]="_loader: A kif variable (of the type described here), which stores a pointer to the loading program.";
}

KifRaiseError::KifRaiseError(string mes,string file,long l,long r) {
	message=mes;
	char c[100];
	sprintf_s(c,100,"%d",l);
	message+=" (line:";
	message+=c;
	message+=")";

	filename=file;
	left=l;
	right=r;
}


void InitMapBooleanString(hmap<short,bool>& themap,string s,bool method=true) {
	short id=KifNewId(s);
	themap[id]=true;
	if (method)
		kifMethods[id]=true;
}

bool TestKifFunctions(string& n,bool func) {
	if (n=="subfunc" || n=="subfuncbis")
		return true;
	if (func==false) {
		if (n=="indexes" || n=="interval")
			return true;
	}
	return false;
}

void StaticInitialisation(KifCode* kifcodeptr) {
	if (kifNULL==NULL) {

		kifTypeEncoding[kifString]=1<<0;
		kifTypeEncoding[kifInteger]=1<<1;
		kifTypeEncoding[kifDate]=1<<2;
		kifTypeEncoding[kifCall]=1<<3;
		kifTypeEncoding[kifFloat]=1<<4;
		kifTypeEncoding[kifBoolean]=1<<5;
		kifTypeEncoding[kifFile]=1<<6;
		kifTypeEncoding[kifMap]=1<<7;
		kifTypeEncoding[kifMatrix]=1<<8;
		kifTypeEncoding[kifVector]=1<<9;
		kifTypeEncoding[kifList]=1<<10;
		kifTypeEncoding[kifIterator]=1<<11;
		kifTypeEncoding[kifFrame]=1<<12;
		kifTypeEncoding[kifSubframe]=1<<13;

		//It is compatible with all
		kifTypeEncoding[kifSelf]=1<<14-1;


		kifConversionNames["string"]=true;
		kifConversionNames["int"]=true;
		kifConversionNames["boolean"]=true;
		kifConversionNames["float"]=true;
		kifConversionNames["vector"]=true;
		kifConversionNames["map"]=true;

		//We only create these values ONCE
		kifStringType[kifString]="string";
		kifStringType[kifInteger]="int";
		kifStringType[kifFraction]="fraction";
		kifStringType[kifDate]="date";
		kifStringType[kifCall]="call";
		kifStringType[kifFloat]="float";
		kifStringType[kifBoolean]="boolean";
		kifStringType[kifSelf]="self";
		kifStringType[kifMap]="map";
		kifStringType[kifMatrix]="matrix";
		kifStringType[kifVector]="vector";
		kifStringType[kifList]="list";
		kifStringType[kifIterator]="iterator";
		kifStringType[kifFile]="file";

		kifStringType[kifAny]="kifAny";
		kifStringType[kifCouple]="kifCouple";
		kifStringType[kifCallFunction]="kifCallFunction";
		kifStringType[kifFrameDeclaration]="kifFrameDeclaration";
		kifStringType[kifFunctionDeclaration]="kifFunctionDeclaration";
		kifStringType[kifInstance]="kifInstance";
		kifStringType[kifIndex]="kifIndex";
		kifStringType[kifPredefined]="kifPredefined";
		kifStringType[kifVariableDeclaration]="kifVariableDeclaration";
		kifStringType[kifFrame]="kifFrame";
		kifStringType[kifFunction]="kifFunction";
		kifStringType[kifInstruction]="kifInstruction";

		//===================================================================	

		kifIdType[kifString]=KifNewId("string");
		kifIdType[kifInteger]=KifNewId("int");
		kifIdType[kifFraction]=KifNewId("fraction");
		kifIdType[kifDate]=KifNewId("date");
		kifIdType[kifCall]=KifNewId("call");
		kifIdType[kifFloat]=KifNewId("float");
		kifIdType[kifBoolean]=KifNewId("boolean");
		kifIdType[kifSelf]=KifNewId("self");
		kifIdType[kifMap]=KifNewId("map");
		kifIdType[kifMatrix]=KifNewId("matrix");
		kifIdType[kifVector]=KifNewId("vector");
		kifIdType[kifList]=KifNewId("list");
		kifIdType[kifIterator]=KifNewId("iterator");
		kifIdType[kifFile]=KifNewId("file");

		kifIdType[kifAny]=KifNewId("kifAny");
		kifIdType[kifCouple]=KifNewId("kifCouple");
		kifIdType[kifCallFunction]=KifNewId("kifCallFunction");
		kifIdType[kifFrameDeclaration]=KifNewId("kifFrameDeclaration");
		kifIdType[kifFunctionDeclaration]=KifNewId("kifFunctionDeclaration");
		kifIdType[kifInstance]=KifNewId("kifInstance");
		kifIdType[kifIndex]=KifNewId("kifIndex");
		kifIdType[kifPredefined]=KifNewId("kifPredefined");
		kifIdType[kifVariableDeclaration]=KifNewId("kifVariableDeclaration");
		kifIdType[kifFrame]=KifNewId("kifFrame");
		kifIdType[kifFunction]=KifNewId("kifFunction");
		kifIdType[kifInstruction]=KifNewId("kifInstruction");
		//===================================================================

		kifClean[kifString]=true;
		kifClean[kifInteger]=true;
		kifClean[kifFloat]=true;
		kifClean[kifBoolean]=true;
		//===================================================================
		
		idnull=KifNewId("null");
		idthis=KifNewId("this");
		idsequence=KifNewId("sequence");
		idcatch=KifNewId("catch");
		idself=KifNewId("self");
		idin=KifNewId("in");
		id_call=KifNewId("_call");
		id_initial=KifNewId("_initial");
		idsize=KifNewId("size");
		idinferior=KifNewId("<");
		idsuperior=KifNewId(">");
		idequal=KifNewId("==");
		iddifferent=KifNewId("!=");
		idinferiorequal=KifNewId("<=");
		idsuperiorequal=KifNewId(">=");
		idmethods=KifNewId("methods");
		idvector=KifNewId("vector");
		idmap=KifNewId("map");
		idapply=KifNewId("apply");
		idsynchronous=KifNewId("synchronous");
		idget=KifNewId("get");
		idstring=KifNewId("string");
		idint=KifNewId("int");
		idfloat=KifNewId("float");
		idboolean=KifNewId("boolean");
		idfraction=KifNewId("fraction");

		idorset=KifNewId("|");
		idandset=KifNewId("&");
		idxorset=KifNewId("^");
		idplusplus=KifNewId("++");
		idminusminus=KifNewId("--");
		idplus=KifNewId("+");
		idminus=KifNewId("-");
		idmultiply=KifNewId("*");
		iddivide=KifNewId("/");
		idmod=KifNewId("%");
		idshiftright=KifNewId(">>");
		idshiftleft=KifNewId("<<");
		idpower=KifNewId("^^");
		idinterval=KifNewId("[:]");
		idindex=KifNewId("[]");
		
		kifTypes["kif"]=&KifCode::KifParseVarKifKiF;
		kifTypes["self"]=&KifCode::KifParseVarSelf;
		kifTypes["int"]=&KifCode::KifParseVarInt;
		kifTypes["fraction"]=&KifCode::KifParseVarFraction;
		kifTypes["date"]=&KifCode::KifParseVarDate;
		kifTypes["time"]=&KifCode::KifParseVarTime;
		kifTypes["call"]=&KifCode::KifParseVarCall;
		kifTypes["string"]=&KifCode::KifParseVarString;
		kifTypes["float"]=&KifCode::KifParseVarFloat;
		kifTypes["vector"]=&KifCode::KifParseVarVector;
		kifTypes["list"]=&KifCode::KifParseVarList;
		kifTypes["map"]=&KifCode::KifParseVarMap;
		kifTypes["matrix"]=&KifCode::KifParseVarMatrix;
		kifTypes["dictionary"]=&KifCode::KifParseVarMap;
		kifTypes["boolean"]=&KifCode::KifParseVarBoolean;
		kifTypes["bool"]=&KifCode::KifParseVarBoolean;
		kifTypes["file"]=&KifCode::KifParseVarFile;
		kifTypes["iterator"]=&KifCode::KifParseVarIterator;
		kifTypes["riterator"]=&KifCode::KifParseVarRIterator;
		kifTypes["tree"]=&KifCode::KifParseVarTree;

		//Specific to XIP
		kifFunctions["xpathexpression"]=&KifCode::KifParseXPath;
		kifFunctions["bodyrule"]=&KifCode::KifParseXipRule;

		kifFunctions["frame"]=&KifCode::KifParseFrame;
		kifFunctions["valmap"]=&KifCode::KifParseValMap;
		kifFunctions["valvector"]=&KifCode::KifParseValVector;
		kifFunctions["alist"]=&KifCode::KifParseList;
		kifFunctions["dico"]=&KifCode::KifParseDico;
		kifFunctions["declaration"]=&KifCode::KifParseDeclaration;
		kifFunctions["multideclaration"]=&KifCode::KifParseMultiDeclaration;
		kifFunctions["function"]=&KifCode::KifParseFunction;
		kifFunctions["autorun"]=&KifCode::KifParseFunction;
		kifFunctions["polynomial"]=&KifCode::KifParseFunction;
		kifFunctions["increment"]=&KifCode::KifParseIncrement;
		kifFunctions["affectation"]=&KifCode::KifParseAffectation;
		kifFunctions["operatoraffectation"]=&KifCode::KifParseOperator;
		kifFunctions["variable"]=&KifCode::KifParseVariable;
		kifFunctions["subfunc"]=&KifCode::KifParseSubFunc;
		kifFunctions["subfuncbis"]=&KifCode::KifParseSubFunc;
		kifFunctions["subvar"]=&KifCode::KifParseSubVar;
		kifFunctions["operator"]=&KifCode::KifParseOperator;
		kifFunctions["comparator"]=&KifCode::KifParseOperator;
		kifFunctions["orand"]=&KifCode::KifParseOperator;
		kifFunctions["operation"]=&KifCode::KifParseOperation;
		kifFunctions["plusplus"]=&KifCode::KifParsePlusPlus;
		kifFunctions["operationin"]=&KifCode::KifParseOperationIn;
		kifFunctions["comparison"]=&KifCode::KifParseComparison;
		kifFunctions["abool"]=&KifCode::KifParseABoolean;
		kifFunctions["astringdouble"]=&KifCode::KifParseAString;
		kifFunctions["astringsimple"]=&KifCode::KifParseAString;
		kifFunctions["anumber"]=&KifCode::KifParseANumber;
		kifFunctions["indexes"]=&KifCode::KifParseIndexes;
		kifFunctions["interval"]=&KifCode::KifParseInterval;
		kifFunctions["regularcall"]=&KifCode::KifParseCall;
		kifFunctions["nonlimited"]=&KifCode::KifNonLimited;
		kifFunctions["breakcall"]=&KifCode::KifParseUniqueCall;
		kifFunctions["returncall"]=&KifCode::KifParseUniqueCall;
		kifFunctions["breakpointcall"]=&KifCode::KifParseUniqueCall;
		kifFunctions["continuecall"]=&KifCode::KifParseUniqueCall;
		kifFunctions["optional"]=&KifCode::KifParseBloc;
		kifFunctions["test"]=&KifCode::KifParseTest;
		kifFunctions["switch"]=&KifCode::KifParseSwitch;
		kifFunctions["trycatch"]=&KifCode::KifParseTryCatch;
		kifFunctions["testswitch"]=&KifCode::KifParseTestSwitch;
		kifFunctions["testelif"]=&KifCode::KifParseTest;
		kifFunctions["loop"]=&KifCode::KifParseWhile;
		kifFunctions["for"]=&KifCode::KifParseFor;
		kifFunctions["negation"]=&KifCode::KifParseNegation;
		kifFunctions["booleanexpression"]=&KifCode::KifParseBoolean;
		kifFunctions["optionalboolean"]=&KifCode::KifParseBloc;

		//===================================================================
		kifOperators["=="]=kifEQUAL;
		kifOperators["<"]=kifINFERIOR;
		kifOperators[">"]=kifSUPERIOR;
		kifOperators[">="]=kifSUPEQU;
		kifOperators["<="]=kifINFEQU;
		kifOperators["="]=kifAFFECTATION;
		kifOperators["<>"]=kifDIFFERENT;
		kifOperators["~="]=kifDIFFERENT;
		kifOperators["!="]=kifDIFFERENT;
		kifOperators["+"]=kifPLUS;
		kifOperators["-"]=kifMINUS;
		kifOperators["*"]=kifMULTIPLY;
		kifOperators["/"]=kifDIVIDE;
		kifOperators["%"]=kifMOD;
		kifOperators["^^"]=kifPOWER;
		kifOperators["|"]=kifUNION;
		kifOperators["^"]=kifXOR;
		kifOperators["&"]=kifINTERSECTION;
		kifOperators["<<"]=kifSHIFTLEFT;
		kifOperators[">>"]=kifSHIFTRIGHT;
		kifOperators["+="]=kifPLUSEQU;
		kifOperators["++"]=kifPLUSPLUS;
		kifOperators["-="]=kifMINUSEQU;
		kifOperators["--"]=kifMINUSMINUS;
		kifOperators["*="]=kifMULTIPLYEQU;
		kifOperators["/="]=kifDIVIDEEQU;
		kifOperators["%="]=kifMODEQU;
		kifOperators["^^="]=kifPOWEREQU;
		kifOperators["<<="]=kifSHIFTLEFTEQU;
		kifOperators[">>="]=kifSHIFTRIGHTEQU;
		kifOperators["|="]=kifUNIONEQU;
		kifOperators["^="]=kifXOREQU;
		kifOperators["&="]=kifINTERSECTIONEQU;
		kifOperators["||"]=kifOR;
		kifOperators["&&"]=kifAND;
		kifOperators["in"]=kifIN;
		kifOperators["notin"]=kifNOTIN;


		for (int i=0;i<=kifLASTDECLARATION;i++)
			kifOperatorMath[i]=false;

		kifOperatorMath[kifPLUS]=true;
		kifOperatorMath[kifMINUS]=true;
		kifOperatorMath[kifMULTIPLY]=true;
		kifOperatorMath[kifDIVIDE]=true;
		kifOperatorMath[kifMOD]=true;
		kifOperatorMath[kifPOWER]=true;
		kifOperatorMath[kifUNION]=true;
		kifOperatorMath[kifXOR]=true;
		kifOperatorMath[kifINTERSECTION]=true;
		kifOperatorMath[kifSHIFTLEFT]=true;
		kifOperatorMath[kifSHIFTRIGHT]=true;

		//===================================================================		

#ifdef KIF_REGEX	
		kifReturnString[KifNewId("replacergx")]=true;
#endif
		kifReturnString[KifNewId("replacergxip")]=true;
		kifReturnString[KifNewId("replace")]=true;
		kifReturnString[KifNewId("removefirst")]=true;
		kifReturnString[KifNewId("removelast")]=true;
		kifReturnString[KifNewId("utf8")]=true;
		kifReturnString[KifNewId("latin")]=true;
		kifReturnString[KifNewId("left")]=true;
		kifReturnString[KifNewId("right")]=true;
		kifReturnString[KifNewId("mid")]=true;
		kifReturnString[KifNewId("upper")]=true;
		kifReturnString[KifNewId("lower")]=true;
		kifReturnString[KifNewId("trim")]=true;
		kifReturnString[KifNewId("trimleft")]=true;
		kifReturnString[KifNewId("trimright")]=true;
		kifReturnString[KifNewId("pop")]=true;
		kifReturnString[KifNewId("last")]=true;
		kifReturnString[KifNewId("infos")]=true;
		kifReturnString[KifNewId("type")]=true;
		kifReturnString[KifNewId("string")]=true;

		kifReturnInt[KifNewId("int")]=true;
		kifReturnInt[idsize]=true;
		kifReturnInt[KifNewId("find")]=true;
		kifReturnInt[KifNewId("rfind")]=true;
		
		kifReturnFloat[KifNewId("float")]=true;

		//===================================================================		

		InitMapBooleanString(kifPredefinedFunctions,"string");
		InitMapBooleanString(kifPredefinedFunctions,"int");
		InitMapBooleanString(kifPredefinedFunctions,"float");
		InitMapBooleanString(kifPredefinedFunctions,"boolean");
		InitMapBooleanString(kifPredefinedFunctions,"methods");
		InitMapBooleanString(kifPredefinedFunctions,"infos");
		InitMapBooleanString(kifPredefinedFunctions,"isa");
		InitMapBooleanString(kifPredefinedFunctions,"type");
		InitMapBooleanString(kifPredefinedFunctions,"size");
		InitMapBooleanString(kifPredefinedFunctions,"clear");
		InitMapBooleanString(kifPredefinedFunctions,"vector");
		InitMapBooleanString(kifPredefinedFunctions,"map");

		InitMapBooleanString(kifTreeFunctions,"string");
		InitMapBooleanString(kifTreeFunctions,"float");
		InitMapBooleanString(kifTreeFunctions,"boolean");
		InitMapBooleanString(kifTreeFunctions,"int");
		InitMapBooleanString(kifTreeFunctions,"map");
		InitMapBooleanString(kifTreeFunctions,"vector");
		InitMapBooleanString(kifTreeFunctions,"next");
		InitMapBooleanString(kifTreeFunctions,"previous");
		InitMapBooleanString(kifTreeFunctions,"parent");
		InitMapBooleanString(kifTreeFunctions,"child");
		InitMapBooleanString(kifTreeFunctions,"last");
		InitMapBooleanString(kifTreeFunctions,"addchild");
		InitMapBooleanString(kifTreeFunctions,"depth");
		InitMapBooleanString(kifTreeFunctions,"addprevious");
		InitMapBooleanString(kifTreeFunctions,"addnext");
		InitMapBooleanString(kifTreeFunctions,"remove");
		InitMapBooleanString(kifTreeFunctions,"extract");

		InitMapBooleanString(kifStringFunctions,"string");
		InitMapBooleanString(kifStringFunctions,"int");
		InitMapBooleanString(kifStringFunctions,"float");
		InitMapBooleanString(kifStringFunctions,"boolean");
		InitMapBooleanString(kifStringFunctions,"vector");
		InitMapBooleanString(kifStringFunctions,"map");

		InitMapBooleanString(kifStringFunctions,"hash");
		InitMapBooleanString(kifStringFunctions,"size");
		InitMapBooleanString(kifStringFunctions,"get");
		InitMapBooleanString(kifStringFunctions,"reverse");
		InitMapBooleanString(kifStringFunctions,"ord",false);
		InitMapBooleanString(kifStringFunctions,"fill");

#ifdef KIF_REGEX	
		InitMapBooleanString(kifStringFunctions,"regex");
		InitMapBooleanString(kifStringFunctions,"splitrgx");
		InitMapBooleanString(kifStringFunctions,"replacergx");
#endif
		InitMapBooleanString(kifStringFunctions,"regexip");
		InitMapBooleanString(kifStringFunctions,"replacergxip");
		InitMapBooleanString(kifStringFunctions,"replace");
		InitMapBooleanString(kifStringFunctions,"split");
		InitMapBooleanString(kifStringFunctions,"find");
		InitMapBooleanString(kifStringFunctions,"rfind");
		InitMapBooleanString(kifStringFunctions,"removefirst");
		InitMapBooleanString(kifStringFunctions,"removelast");
		InitMapBooleanString(kifStringFunctions,"utf8");
		InitMapBooleanString(kifStringFunctions,"latin");
		InitMapBooleanString(kifStringFunctions,"left");
		InitMapBooleanString(kifStringFunctions,"right");
		InitMapBooleanString(kifStringFunctions,"mid");
		InitMapBooleanString(kifStringFunctions,"isalpha");
		InitMapBooleanString(kifStringFunctions,"isdigit");
		InitMapBooleanString(kifStringFunctions,"isupper");
		InitMapBooleanString(kifStringFunctions,"islower");
		InitMapBooleanString(kifStringFunctions,"upper");
		InitMapBooleanString(kifStringFunctions,"lower");
		InitMapBooleanString(kifStringFunctions,"trim");
		InitMapBooleanString(kifStringFunctions,"trimleft");
		InitMapBooleanString(kifStringFunctions,"trimright");
		InitMapBooleanString(kifStringFunctions,"pop");
		InitMapBooleanString(kifStringFunctions,"last");
		InitMapBooleanString(kifStringFunctions,"insert");
		InitMapBooleanString(kifStringFunctions,"isa");
		InitMapBooleanString(kifStringFunctions,"methods");
		InitMapBooleanString(kifStringFunctions,"infos");
		InitMapBooleanString(kifStringFunctions,"type");
		InitMapBooleanString(kifStringFunctions,"clear");

		InitMapBooleanString(kifVectorFunctions,"size");
		InitMapBooleanString(kifVectorFunctions,"reverse");
		InitMapBooleanString(kifVectorFunctions,"insert");
		InitMapBooleanString(kifVectorFunctions,"push");
		InitMapBooleanString(kifVectorFunctions,"join");
		InitMapBooleanString(kifVectorFunctions,"pop");
		InitMapBooleanString(kifVectorFunctions,"last");
		InitMapBooleanString(kifVectorFunctions,"sort");
		InitMapBooleanString(kifVectorFunctions,"sum");
		InitMapBooleanString(kifVectorFunctions,"product");
		InitMapBooleanString(kifVectorFunctions,"clear");
		InitMapBooleanString(kifVectorFunctions,"apply");
		InitMapBooleanString(kifVectorFunctions,"isa");
		InitMapBooleanString(kifVectorFunctions,"methods");
		InitMapBooleanString(kifVectorFunctions,"infos");
		InitMapBooleanString(kifVectorFunctions,"type");
		InitMapBooleanString(kifVectorFunctions,"string");
		InitMapBooleanString(kifVectorFunctions,"int");
		InitMapBooleanString(kifVectorFunctions,"float");
		InitMapBooleanString(kifVectorFunctions,"boolean");

		InitMapBooleanString(kifListFunctions,"size");
		InitMapBooleanString(kifListFunctions,"reverse");
		InitMapBooleanString(kifListFunctions,"insert");
		InitMapBooleanString(kifListFunctions,"pushfirst");
		InitMapBooleanString(kifListFunctions,"poplast");
		InitMapBooleanString(kifListFunctions,"pushlast");
		InitMapBooleanString(kifListFunctions,"popfirst");
		InitMapBooleanString(kifListFunctions,"sum");
		InitMapBooleanString(kifListFunctions,"product");
		InitMapBooleanString(kifListFunctions,"join");
		InitMapBooleanString(kifListFunctions,"apply");
		InitMapBooleanString(kifListFunctions,"last");
		InitMapBooleanString(kifListFunctions,"first");
		InitMapBooleanString(kifListFunctions,"clear");		
		InitMapBooleanString(kifListFunctions,"isa");
		InitMapBooleanString(kifListFunctions,"methods");
		InitMapBooleanString(kifListFunctions,"infos");
		InitMapBooleanString(kifListFunctions,"type");
		InitMapBooleanString(kifListFunctions,"string");
		InitMapBooleanString(kifListFunctions,"int");
		InitMapBooleanString(kifListFunctions,"float");
		InitMapBooleanString(kifListFunctions,"boolean");


		InitMapBooleanString(kifKiFFunctions,"load");
		InitMapBooleanString(kifKiFFunctions,"name");

		InitMapBooleanString(kifMapFunctions,"size");
		InitMapBooleanString(kifMapFunctions,"clear");
		InitMapBooleanString(kifMapFunctions,"sum");
		InitMapBooleanString(kifMapFunctions,"product");
		InitMapBooleanString(kifMapFunctions,"pop");
		InitMapBooleanString(kifMapFunctions,"isa");
		InitMapBooleanString(kifMapFunctions,"keys");
		InitMapBooleanString(kifMapFunctions,"values");
		InitMapBooleanString(kifMapFunctions,"methods");
		InitMapBooleanString(kifMapFunctions,"infos");
		InitMapBooleanString(kifMapFunctions,"type");
		InitMapBooleanString(kifMapFunctions,"string");
		InitMapBooleanString(kifMapFunctions,"int");
		InitMapBooleanString(kifMapFunctions,"float");
		InitMapBooleanString(kifMapFunctions,"boolean");

		InitMapBooleanString(kifMatrixFunctions,"size");
		InitMapBooleanString(kifMatrixFunctions,"clear");
		InitMapBooleanString(kifMatrixFunctions,"write");
		InitMapBooleanString(kifMatrixFunctions,"set");
		InitMapBooleanString(kifMatrixFunctions,"instances");
		InitMapBooleanString(kifMatrixFunctions,"get");
		InitMapBooleanString(kifMatrixFunctions,"isa");
		InitMapBooleanString(kifMatrixFunctions,"methods");
		InitMapBooleanString(kifMatrixFunctions,"infos");
		InitMapBooleanString(kifMatrixFunctions,"type");

		InitMapBooleanString(kifFileFunctions,"openwrite");
		InitMapBooleanString(kifFileFunctions,"openappend");
		InitMapBooleanString(kifFileFunctions,"flush");
		InitMapBooleanString(kifFileFunctions,"openread");
		InitMapBooleanString(kifFileFunctions,"get");
		InitMapBooleanString(kifFileFunctions,"unget");
		InitMapBooleanString(kifFileFunctions,"close");
		InitMapBooleanString(kifFileFunctions,"seek");
		InitMapBooleanString(kifFileFunctions,"tell");
		InitMapBooleanString(kifFileFunctions,"write");
		InitMapBooleanString(kifFileFunctions,"read");
		InitMapBooleanString(kifFileFunctions,"readln");
		InitMapBooleanString(kifFileFunctions,"size");
		InitMapBooleanString(kifFileFunctions,"isa");
		InitMapBooleanString(kifFileFunctions,"methods");
		InitMapBooleanString(kifFileFunctions,"infos");
		InitMapBooleanString(kifFileFunctions,"type");
		InitMapBooleanString(kifFileFunctions,"eof");
		InitMapBooleanString(kifFileFunctions,"string");
		InitMapBooleanString(kifFileFunctions,"int");
		InitMapBooleanString(kifFileFunctions,"float");
		InitMapBooleanString(kifFileFunctions,"boolean");

		InitMapBooleanString(kifDateFunctions,"setdate");
		InitMapBooleanString(kifDateFunctions,"date");
		InitMapBooleanString(kifDateFunctions,"year");
		InitMapBooleanString(kifDateFunctions,"month");
		InitMapBooleanString(kifDateFunctions,"day");
		InitMapBooleanString(kifDateFunctions,"hour");
		InitMapBooleanString(kifDateFunctions,"minute");
		InitMapBooleanString(kifDateFunctions,"format");
		InitMapBooleanString(kifDateFunctions,"second");
		InitMapBooleanString(kifDateFunctions,"isa");
		InitMapBooleanString(kifDateFunctions,"methods");
		InitMapBooleanString(kifDateFunctions,"infos");
		InitMapBooleanString(kifDateFunctions,"type");

		InitMapBooleanString(kifDateFunctions,"string");
		InitMapBooleanString(kifDateFunctions,"int");
		InitMapBooleanString(kifDateFunctions,"float");
		InitMapBooleanString(kifDateFunctions,"boolean");

		InitMapBooleanString(kifTimeFunctions,"methods");
		InitMapBooleanString(kifTimeFunctions,"infos");
		InitMapBooleanString(kifTimeFunctions,"type");

		InitMapBooleanString(kifTimeFunctions,"reset");
		InitMapBooleanString(kifTimeFunctions,"string");
		InitMapBooleanString(kifTimeFunctions,"int");
		InitMapBooleanString(kifTimeFunctions,"float");
		InitMapBooleanString(kifTimeFunctions,"boolean");

		//"log","ln","exp","sqrt", "tan","sin","cos","atan","@pi","@e"
		//Mathematics Function
		kifMathFunctions[KifNewId("log")]=log10;
		kifMathFunctions[KifNewId("ln")]=log;
		kifMathFunctions[KifNewId("exp")]=exp;
		kifMathFunctions[KifNewId("sqrt")]=sqrt;
		kifMathFunctions[KifNewId("tan")]=tan;
		kifMathFunctions[KifNewId("sin")]=sin;
		kifMathFunctions[KifNewId("cos")]=cos;
		kifMathFunctions[KifNewId("atan")]=atan;

		InitMapBooleanString(kifNumericalFunctions,"isa");
		InitMapBooleanString(kifNumericalFunctions,"type");
		InitMapBooleanString(kifNumericalFunctions,"methods");
		InitMapBooleanString(kifNumericalFunctions,"infos");
		InitMapBooleanString(kifNumericalFunctions,"chr",false);

		InitMapBooleanString(kifNumericalFunctions,"string");
		InitMapBooleanString(kifNumericalFunctions,"fraction");
		InitMapBooleanString(kifNumericalFunctions,"format");
		InitMapBooleanString(kifNumericalFunctions,"int");
		InitMapBooleanString(kifNumericalFunctions,"float");
		InitMapBooleanString(kifNumericalFunctions,"boolean");
		InitMapBooleanString(kifNumericalFunctions,"#",false);
		InitMapBooleanString(kifNumericalFunctions,"simplify");
		InitMapBooleanString(kifNumericalFunctions,"nd");
		InitMapBooleanString(kifNumericalFunctions,"d");
		InitMapBooleanString(kifNumericalFunctions,"n");
		InitMapBooleanString(kifNumericalFunctions,"euclidian");


		InitMapBooleanString(kifIteratorFunctions,"next");
		InitMapBooleanString(kifIteratorFunctions,"end");
		InitMapBooleanString(kifIteratorFunctions,"set");
		InitMapBooleanString(kifIteratorFunctions,"nend");
		InitMapBooleanString(kifIteratorFunctions,"begin");
		InitMapBooleanString(kifIteratorFunctions,"key");
		InitMapBooleanString(kifIteratorFunctions,"value");
		InitMapBooleanString(kifIteratorFunctions,"apply");
		InitMapBooleanString(kifIteratorFunctions,"valuetype");
		InitMapBooleanString(kifIteratorFunctions,"isa");
		InitMapBooleanString(kifIteratorFunctions,"methods");
		InitMapBooleanString(kifIteratorFunctions,"infos");
		InitMapBooleanString(kifIteratorFunctions,"type");



#ifdef WIN32
		kifMetaCharacters["\\n"]="\r\n";
#else
		kifMetaCharacters["\\n"]=13;
#endif
		kifMetaCharacters["\\r"]=10;
		kifMetaCharacters["\\\""]=34;
		kifMetaCharacters["\\t"]=9;	
		//===================================================================
		if (kifcodeptr==NULL) {


			kifNULL=new KifConst(NULL,NULL,idnull);
			kifNOELEMENT=new KifConst(NULL,NULL,KifNewId("_noelement"));

			kifBREAK=new KifConst(NULL,NULL,KifNewId("_break"));

			kifBREAKPOINT=new KifConst(NULL,NULL,KifNewId("_breakpoint"));

			kifDEFAULT=new KifConst(NULL,NULL,KifNewId("_default"));

			kifCONTINUE=new KifConst(NULL,NULL,KifNewId("_continue"));

			kifNEG=new KifConst(NULL,NULL,KifNewId("_negation"));

			kifMINUSONE=new KifInteger(NULL,NULL,-1);

			kifTRUE=new KifBoolean(NULL,NULL,true);
			kifFALSE=new KifBoolean(NULL,NULL,false);

			KifInitInformations();
		}
		else {
			kifStringId=kifcodeptr->kkifStringId;
			kifIdString=kifcodeptr->kkifIdString;
			kifNULL=kifcodeptr->kkifNULL;
			kifTRUE=kifcodeptr->kkifTRUE;
			kifFALSE=kifcodeptr->kkifFALSE;
			kifMINUSONE=kifcodeptr->kkifMINUSONE;
			kifDEFAULT=kifcodeptr->kkifDEFAULT;
			kifBREAK=kifcodeptr->kkifBREAK;
			kifBREAKPOINT=kifcodeptr->kkifBREAKPOINT;
			kifCONTINUE=kifcodeptr->kkifCONTINUE;
			kifNEG=kifcodeptr->kkifNEG;
		}
	}
}

//===================================================================
bool PureKifInstance(KifElement* i) {
	if (i->type!=kifInstance)
		return false;
	KifInstance* inst=(KifInstance*)i;
	if (inst->index!=NULL)
		return false;
	if (inst->value!=NULL) {
		if (inst->value->type==kifInstanceFunction)
			return false;
		if (inst->value->type==kifInstance)
			return PureKifInstance(inst->value);
	}
	return true;
}


bool KifAnalyzeParameter(KifElement* arg,KifElement* callparameter,bool strict) {
	
	//for a self, anything goes...
	if (arg->type==kifSelf)
		return true;

	//The simplest case. No strict equivalence, and arg is a simple type such as: integer, float, boolean or string
	if (strict==false && arg->Simple())
		return true;
	
	KifElement* param=callparameter;
	KifInstructionPARAMETER* parameter=NULL;
	if (callparameter->type==kifInstructionPARAMETER) {
		parameter=(KifInstructionPARAMETER*)callparameter;
		param=parameter->instructions[0];
	}

	KifType typeparam=param->inType();

	//we have two specific cases: if the call is done with "this" or with "null"
	//then these two specific values are still valid...
	if ((typeparam==kifthis && arg->type==kifFrame)	|| typeparam==kifnull || typeparam==kifSelf)	
		return true;
	
	//The simplest case, they both share the same type...
	if (typeparam==arg->type) {
		//However, if we are dealing with two frames...
		if (arg->type==kifFrame)
			//then the parameter should be either the same frame or a subframe... 
			return arg->Subframe((KifFrame*)param->Linkedvalue());
		return true;
	}
	//If we have reached this part of the code, and arg is still a frame, then error...
	if (arg->type==kifFrame)
		return false;
	
	//If we demand a strict checking of the paramater, we still have different cases
	//We are in this part of the code, in the case where the parameter is a mathematical formula...
	if (strict==true) {
		if (arg->Simple()) {
			if (parameter==NULL) {
				switch(arg->type) {
				case kifBoolean:
				case kifInteger:
				case kifFloat:
					if (param->type==kifInteger || param->type==kifFloat || param->type==kifBoolean)
						return true;
				}
				return false;
			}

			if (parameter->root!=NULL) {
				switch(arg->type) {
				case kifBoolean:
				case kifInteger:
				case kifFloat:
					//The parameters could be an mathematical formula, which of course already have a type
					if (parameter->instructiontype!=kifFULLINTEGER && parameter->instructiontype!=kifFULLFLOAT)
						return false;
					break;
				case kifString:
					if (parameter->instructiontype!=kifFULLSTRING)
						return false;
					break;
				}
				return true;
			}
		}
		else
			if (arg->type!=typeparam)
				return false;
	}

	//if it is a function call, then we can only decide at runtime...
	//so it is not an error
	if (PureKifInstance(param)==false)
		return true;

	return false;
}


char KifCheckParameters(KifFunction* kfunction,KifCallFunction* kcf,bool add,KifFunction** body) {
	//If we have more than one function available, we go for the 
	//the call with the most compatible arguments...		
	int arg;
	if (kfunction->next==NULL) {
		if (kfunction->Unlimited()==false && kfunction->arguments.size()!=kcf->parameters.size())
			return 1;
		if (add==false)
			*body=kfunction;
		for (arg=0;arg<kfunction->arguments.size();arg++) {
			if (KifAnalyzeParameter(kfunction->arguments[arg]->Linkedvalue(),kcf->parameters[arg],kfunction->strict)==false)
				return 2;
		}
		return 0;
	}

	bool found;
	while (kfunction!=NULL) {
		if (kfunction->Unlimited()==false && kfunction->arguments.size()!=kcf->parameters.size()) {
			kfunction=kfunction->next;
			continue;
		}
		found=true;
		for (arg=0;arg<kfunction->arguments.size();arg++) {
			if (KifAnalyzeParameter(kfunction->arguments[arg]->Linkedvalue(),kcf->parameters[arg],true)==false) {
				found=false;
				break;
			}
		}
		if (found==true)
			break;
		kfunction=kfunction->next;
	}
	if (kfunction==NULL)
		return 2;
	if (add)
		kcf->Setbody(kfunction);
	else
		*body=kfunction;
	return 0;
}


//===================================================================

KifElement* KifCode::Returnerror(string message) {
#ifdef PROFILING
	profilingcall("Code::Returnerror");
#endif

	if (error)
		return errorptr;

	message+=" at line: ";	
	long line=tabledebugline[currentline];
	map<long,string>::reverse_iterator it;
	string filename="";
	for (it=tabledebugfilename.rbegin();it!=tabledebugfilename.rend();it++) {
		if (it->first<=currentline) {
			filename=it->second;
			break;
		}
	}
	char ch[100];
	sprintf_s(ch,100,"%d",line);
	message+=ch;
	message+=" in "+filename;

	error=true;
	errorptr=new KifError(this,NULL,message);
	return errorptr;
}


//--------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------


//===================================================================
void KifInitFunctions(KifCode* kifcodeptr,KifFrame* kstart) {
	StaticInitialisation(NULL);

	kifcodeptr->kkifStringId=kifStringId;
	kifcodeptr->kkifIdString=kifIdString;

	kifcodeptr->kkifNULL=kifNULL;
	kifcodeptr->kkifTRUE=kifTRUE;
	kifcodeptr->kkifFALSE=kifFALSE;
	kifcodeptr->kkifMINUSONE=kifMINUSONE;
	kifcodeptr->kkifDEFAULT=kifDEFAULT;
	kifcodeptr->kkifBREAK=kifBREAK;
	kifcodeptr->kkifBREAKPOINT=kifBREAKPOINT;
	kifcodeptr->kkifCONTINUE=kifCONTINUE;
	kifcodeptr->kkifNEG=kifNEG;
	
	kifcodeptr->kifTypeSTRING=new KifBaseString(kifcodeptr,NULL);
	kifcodeptr->kifTypeINTEGER=new KifInteger(kifcodeptr,NULL);
	kifcodeptr->kifTypeFLOAT=new KifFloat(kifcodeptr,NULL);
	kifcodeptr->kifTypeBOOLEAN=new KifBoolean(kifcodeptr,NULL);

	kifcodeptr->kkifLastType=&kifLastType;
	kifcodeptr->kkifStringType=&kifStringType;

	kstart->instructions.push_back(kifNULL);
	kstart->instructions.push_back(kifBREAK);
	kstart->instructions.push_back(kifBREAKPOINT);
	kstart->instructions.push_back(kifDEFAULT);
	kstart->instructions.push_back(kifCONTINUE);
	kstart->instructions.push_back(kifNEG);
	kstart->instructions.push_back(kifMINUSONE);
	kstart->instructions.push_back(kifTRUE);
	kstart->instructions.push_back(kifFALSE);

	
	kstart->Set(KifNewId("true"),kifTRUE,NULL);
	kstart->Set(KifNewId("false"),kifTRUE,NULL);
	kstart->Set(KifNewId("null"),kifNULL,NULL);
//===================================================================

//===================================================================


	kifcodeptr->KifCreatePredefined("next",&PreTreeNext,true);
	kifcodeptr->KifCreatePredefined("previous",&PreTreePrevious,true);
	kifcodeptr->KifCreatePredefined("parent",&PreTreeParent,true);
	kifcodeptr->KifCreatePredefined("child",&PreTreeChild,true);
	kifcodeptr->KifCreatePredefined("last",&PreTreeLast,true);
	kifcodeptr->KifCreatePredefined("addchild",&PreTreeAddChild,true);
	kifcodeptr->KifCreatePredefined("depth",&PreTreeDepth,true);
	kifcodeptr->KifCreatePredefined("addprevious",&PreTreeAddPrevious,true);
	kifcodeptr->KifCreatePredefined("addnext",&PreTreeAddNext,true);
	kifcodeptr->KifCreatePredefined("remove",&PreTreeRemove,true);
	kifcodeptr->KifCreatePredefined("extract",&PreTreeExtract,true);
	kifcodeptr->KifCreatePredefined("string",&PreConvertString,true);
	kifcodeptr->KifCreatePredefined("float",&PreConvertFloat,true);
	kifcodeptr->KifCreatePredefined("fraction",&PreConvertFraction,true);
	kifcodeptr->KifCreatePredefined("int",&PreConvertInteger,true);
	kifcodeptr->KifCreatePredefined("boolean",&PreConvertBoolean,true);
	kifcodeptr->KifCreatePredefined("vector",&PreConvertVector,true);
	kifcodeptr->KifCreatePredefined("map",&PreConvertMap,true);


	kifcodeptr->KifCreatePredefined("gcsize",&PreGCSize);
	kifcodeptr->KifCreatePredefined("hash",&PreHash);
	kifcodeptr->KifCreatePredefined("next",&PreNext);

	kifcodeptr->KifCreatePredefined("string",&PreConvertString);
	kifcodeptr->KifCreatePredefined("float",&PreConvertFloat);
	kifcodeptr->KifCreatePredefined("fraction",&PreConvertFraction);
	kifcodeptr->KifCreatePredefined("int",&PreConvertInteger);
	kifcodeptr->KifCreatePredefined("boolean",&PreConvertBoolean);
	kifcodeptr->KifCreatePredefined("vector",&PreConvertVector);
	kifcodeptr->KifCreatePredefined("map",&PreConvertMap);

	kifcodeptr->KifCreatePredefined("log",&PreMath);
	kifcodeptr->KifCreatePredefined("ln",&PreMath);
	kifcodeptr->KifCreatePredefined("exp",&PreMath);
	kifcodeptr->KifCreatePredefined("sqrt",&PreMath);
	kifcodeptr->KifCreatePredefined("tan",&PreMath);
	kifcodeptr->KifCreatePredefined("sin",&PreMath);
	kifcodeptr->KifCreatePredefined("cos",&PreMath);
	kifcodeptr->KifCreatePredefined("atan",&PreMath);

	kifcodeptr->KifCreatePredefined("pause",&PrePause);
	kifcodeptr->KifCreatePredefined("sleep",&PreSleep);
	kifcodeptr->KifCreatePredefined("_eval",&PreEval);
	kifcodeptr->KifCreatePredefined("_run",&PreRun);
	kifcodeptr->KifCreatePredefined("_open",&PreOpenSession);
	kifcodeptr->KifCreatePredefined("_close",&PreCloseSession);
	kifcodeptr->KifCreatePredefined("_compile",&PreCompile);
	kifcodeptr->KifCreatePredefined("range",&PreRange);


	kifcodeptr->KifCreatePredefined("methods",&PreMethods);
	kifcodeptr->KifCreatePredefined("infos",&PreInfos);
	kifcodeptr->KifCreatePredefined("isa",&PreTypeIs);
	kifcodeptr->KifCreatePredefined("type",&PreType);
	kifcodeptr->KifCreatePredefined("environment",&PreEnvironment);
	kifcodeptr->KifCreatePredefined("catch",&PreCatch);
	kifcodeptr->KifCreatePredefined("raise",&PreRaise);
	
	kifcodeptr->KifCreatePredefined("load",&PreLoad);

	kifcodeptr->KifCreatePredefined("reverse",&PreReverse);
	
	kifcodeptr->KifCreatePredefined("lock",&PreLock);
	kifcodeptr->KifCreatePredefined("unlock",&PreUnlock);
	kifcodeptr->KifCreatePredefined("wait",&PreWait);
	kifcodeptr->KifCreatePredefined("waitonfalse",&PreWaitOnFalse);	
	kifcodeptr->KifCreatePredefined("waiting",&PreWaiting);
	kifcodeptr->KifCreatePredefined("cast",&PreCast);
	kifcodeptr->KifCreatePredefined("kill",&PreKill);
	
	kifcodeptr->KifCreatePredefined("version",&PreVersion);
	kifcodeptr->KifCreatePredefined("print",&PrePrint);
	kifcodeptr->KifCreatePredefined("setutf8",&PreSetutf8);
	kifcodeptr->KifCreatePredefined("exit",&PreExit);
	kifcodeptr->KifCreatePredefined("pflush",&PrePrintFlush);
	kifcodeptr->KifCreatePredefined("println",&PrePrintLN);
	kifcodeptr->KifCreatePredefined("printerr",&PrePrinterr);
	kifcodeptr->KifCreatePredefined("printlnerr",&PrePrinterrLN);
	kifcodeptr->KifCreatePredefined("openread",&PreOpenReadfile);
	kifcodeptr->KifCreatePredefined("openwrite",&PreOpenWritefile);
	kifcodeptr->KifCreatePredefined("openappend",&PreOpenAppendfile);
	kifcodeptr->KifCreatePredefined("threadid",&PreThreadId);
	
	kifcodeptr->KifCreatePredefined("flush",&PreFlushFile);
	kifcodeptr->KifCreatePredefined("eof",&PreEndOfFile);
	kifcodeptr->KifCreatePredefined("read",&PreRead);
	kifcodeptr->KifCreatePredefined("readln",&PreReadOneLine);
	kifcodeptr->KifCreatePredefined("seek",&PreSeek);
	kifcodeptr->KifCreatePredefined("tell",&PreTell);
	kifcodeptr->KifCreatePredefined("write",&PreWrite);
	kifcodeptr->KifCreatePredefined("close",&PreClose);
	kifcodeptr->KifCreatePredefined("insert",&PreInsert);
	kifcodeptr->KifCreatePredefined("push",&PrePush);
	kifcodeptr->KifCreatePredefined("pushfirst",&PrePushFirst);
	kifcodeptr->KifCreatePredefined("pushlast",&PrePushLast);
	kifcodeptr->KifCreatePredefined("join",&PreJoin);
	kifcodeptr->KifCreatePredefined("pop",&PrePop);
	kifcodeptr->kstart->declarations[KifNewId("pop")]=new KifPredefined(kifcodeptr,&PrePop,KifStringId("pop"));
	kifcodeptr->KifCreatePredefined("poplast",&PrePopLast);
	kifcodeptr->KifCreatePredefined("popfirst",&PrePopFirst);
	kifcodeptr->KifCreatePredefined("last",&PreLast);
	kifcodeptr->KifCreatePredefined("first",&PreFirst);
	kifcodeptr->KifCreatePredefined("sort",&PreSort);
	kifcodeptr->KifCreatePredefined("sum",&PreSum);
	kifcodeptr->KifCreatePredefined("product",&PreProduct);
	kifcodeptr->KifCreatePredefined("clear",&PreClear);

	kifcodeptr->KifCreatePredefined("values",&PreValues);
	kifcodeptr->KifCreatePredefined("keys",&PreKeys);

	kifcodeptr->KifCreatePredefined("simplify",&PreFractionSimplify);
	kifcodeptr->KifCreatePredefined("euclidian",&PreEuclidian);
	kifcodeptr->KifCreatePredefined("d",&PreDenominator);
	kifcodeptr->KifCreatePredefined("n",&PreNumerator);
	kifcodeptr->KifCreatePredefined("nd",&PreNumeratorDenominator);

	kifcodeptr->KifCreatePredefined("chr",&PreChr);
	kifcodeptr->KifCreatePredefined("ord",&PreOrd);
	kifcodeptr->KifCreatePredefined("fill",&PreFill);
	kifcodeptr->KifCreatePredefined("format",&PreFormat);

	kifcodeptr->KifCreatePredefined("instances",&PreNbInstances);

	//Rules	
	kifcodeptr->KifCreatePredefined("set",&PreSet);
	kifcodeptr->KifCreatePredefined("get",&PreGet);
	kifcodeptr->KifCreatePredefined("getc",&PreGetc);
	kifcodeptr->KifCreatePredefined("random",&PreRandom);
	kifcodeptr->KifCreatePredefined("apply",&PreApply);

	kifcodeptr->KifCreatePredefined("unget",&PreUnGet);

	
	//String functions
#ifdef KIF_REGEX	
	kifcodeptr->KifCreatePredefined("regex",&PreRegex);
	kifcodeptr->KifCreatePredefined("splitrgx",&PreSplitRegex);
	kifcodeptr->KifCreatePredefined("replacergx",&PreReplaceRgx);
#endif
	kifcodeptr->KifCreatePredefined("#",&PreComplement);
	kifcodeptr->KifCreatePredefined("regexip",&PreXipRegex);
	kifcodeptr->KifCreatePredefined("replacergxip",&PreXipReplaceRgx);
	kifcodeptr->KifCreatePredefined("replace",&PreReplace);
	kifcodeptr->KifCreatePredefined("split",&PreSplit);
	kifcodeptr->KifCreatePredefined("find",&PreFind);
	kifcodeptr->KifCreatePredefined("rfind",&PreRFind);
	kifcodeptr->KifCreatePredefined("removefirst",&PreRemovefirst);
	kifcodeptr->KifCreatePredefined("removelast",&PreRemovelast);
	kifcodeptr->KifCreatePredefined("utf8",&PreLatinToUTF8);
	kifcodeptr->KifCreatePredefined("latin",&PreUTF8ToLatin);
	kifcodeptr->KifCreatePredefined("left",&PreLeft);
	kifcodeptr->KifCreatePredefined("right",&PreRight);
	kifcodeptr->KifCreatePredefined("mid",&PreMid);
	kifcodeptr->KifCreatePredefined("islower",&PreIsLower);
	kifcodeptr->KifCreatePredefined("isupper",&PreIsUpper);
	kifcodeptr->KifCreatePredefined("isalpha",&PreIsAlpha);
	kifcodeptr->KifCreatePredefined("isdigit",&PreIsDigit);
	kifcodeptr->KifCreatePredefined("lower",&PreLower);
	kifcodeptr->KifCreatePredefined("upper",&PreUpper);
	kifcodeptr->KifCreatePredefined("trim",&PreTrim);
	kifcodeptr->KifCreatePredefined("trimleft",&PreTrimleft);
	kifcodeptr->KifCreatePredefined("trimright",&PreTrimright);

	//Time
	kifcodeptr->KifCreatePredefined("setdate",&PreSetDate);
	kifcodeptr->KifCreatePredefined("reset",&PreResetTime);
	kifcodeptr->KifCreatePredefined("date",&PreDate);
	kifcodeptr->KifCreatePredefined("month",&PreMonth);
	kifcodeptr->KifCreatePredefined("year",&PreYear);
	kifcodeptr->KifCreatePredefined("day",&PreDay);
	kifcodeptr->KifCreatePredefined("hour",&PreHour);
	kifcodeptr->KifCreatePredefined("minute",&PreMinute);
	kifcodeptr->KifCreatePredefined("second",&PreSecond);

	//Iterator functions
	kifcodeptr->KifCreatePredefined("begin",&PreBegin);
	kifcodeptr->KifCreatePredefined("end",&PreEnd);
	kifcodeptr->KifCreatePredefined("nend",&PreNend);
	kifcodeptr->KifCreatePredefined("key",&PreIteratorKey);
	kifcodeptr->KifCreatePredefined("value",&PreValue);
	kifcodeptr->KifCreatePredefined("valuetype",&PreValueType);
	kifcodeptr->KifCreatePredefined("valueisa",&PreValueTypeIs);



	//Function for: string,map,vector
	kifcodeptr->KifCreatePredefined("size",&PreSize);

	//Function for: dependencies


}

//===================================================================

bool KifCode::KifCreatePredefined(string name,Predefined func,bool tree) {
#ifdef PROFILING
	profilingcall("Code::KifCreatePredefined");
#endif
	int idname=KifNewId(name);
	if (tree==false) {
		if (kifBaseFunctions.find(idname)!=kifBaseFunctions.end())
			return false;

		kifBaseFunctions[idname]=new KifPredefined(NULL,func,idname);
		kifBaseFunctions[idname]->kifcode=this;
	}
	else {
		if (kifBaseTreeFunctions.find(idname)!=kifBaseTreeFunctions.end())
			return false;

		kifBaseTreeFunctions[idname]=new KifPredefined(NULL,func,idname);
		kifBaseTreeFunctions[idname]->kifcode=this;
	}

	return true;
}

KifElement* KifCode::KifBaseFunctionTest(short name) {
#ifdef PROFILING
	profilingcall("Code::KifBaseFunctionTest");
#endif
	if (kifBaseFunctions.find(name)!=kifBaseFunctions.end())
		return kifBaseFunctions[name];
	if (kifBaseTreeFunctions.find(name)!=kifBaseTreeFunctions.end())
		return kifBaseTreeFunctions[name];
	return NULL;
}


bool KifCode::KifDeclaredFunctionTest(short name) {
#ifdef PROFILING
	profilingcall("Code::KifDeclaredFunctionTest");
#endif
	if (kifDeclaredFunction.find(name)!=kifDeclaredFunction.end())
		return true;
	return false;
}

void KifCode::KifInitLib() {
	if (kifStringId==NULL) {
		kifStringId=kkifStringId;
		kifIdString=kkifIdString;
	}
	StaticInitialisation(this);
}



string KifElement::Type() {
	return kifStringType[type];
}


Exported string KifFrame::Type() {
	return (*kifIdString)[name];
}	

Exported string KifFunction::Type() {
	return kifStringType[type];
}

string KifVariableDeclaration::Type() {
	if (value==this)
		return kifStringType[type];
	return value->Type();
}

string KifConst::Type() {
	if (value==this)
		return kifStringType[type];
	return value->Type();
}

string KifMetaCharacters(string& m) {
	if (m.size()==1)
		return "";

	if (kifMetaCharacters.find(m)!=kifMetaCharacters.end())
		return kifMetaCharacters[m];
	string s;
	s=m[1];
	return s;
}

//===================================================================
KifConst::KifConst(KifCode* klc,KifElement* kp,short n) : KifElement(klc,kp,kifVOID) {
	name=n;
	value=this;
	if (n==idnull)
		type=kifnull;
}
//===================================================================

long KifString::Size() {	
	return c_size(value,kifcode->utf8);
}

long KifString::Integer() {
	if (value=="")
		return 0;
	long i=atoi(STR(value));
	return i;
}
double KifString::Float() {
	if (value=="")
		return 0;
	double i=atof(STR(value));
	return i;
}

long KifFile::Size() {
	ThreadLock _lock(type);
	struct stat scible;
	int stcible=-1;
	long size=-1;
	bool closeit=false;
	if (fileread==NULL) {
#ifdef WIN32
		fopen_s(&fileread,STR(filename),"rb");
#else
		fileread=fopen(STR(filename),"rb");
#endif
		closeit=true;
	}

	if (fileread!=NULL) {

#if  defined(WIN32) | defined(APPLE) | defined(XIPFSTAT64)
		stcible=fstat(fileread->_file,&scible);
#else
		stcible=fstat(fileread->_fileno,&scible);
#endif
		if (stcible>=0)
			size=scible.st_size;
		if (closeit==true)
			fclose(fileread);
	}
	return size;
}

long KifFile::Integer() {
	return Size();
}

double KifFile::Float() {
	return Size();
}


string KifMap::String() {
	string res;
	hmap<string,KifElement*>::iterator it;
	res="{";
	bool beg=true;
	string sx;
	for (it=values.begin();it!=values.end();it++) {
		if (beg==false)
			res+=",";
		beg=false;
		res+="'";
		sx=it->first;
		res+=Trim(sx);
		res+="'";
		res+=":";
		sx=it->second->String();
		sx=Trim(sx);
		if (it->second->type!=kifString)
			res+=sx;
		else {			
			if (sx.find("'")!=-1) {
				res+="\"";
				res+=sx;
				res+="\"";
			}
			else {
				res+="'";
				res+=sx;
				res+="'";
			}
		}
	}
	res+="}";
	return res;
}

string KifVector::String() {
	string res;
	int it;
	res="[";
	bool beg=true;
	string sx;
	KifElement* element;
	for (it=0;it<values.size();it++) {
		element=values[it];
		if (beg==false)
			res+=",";
		beg=false;
		sx=element->String();
		sx=Trim(sx);
		if (element->type!=kifString)
			res+=sx;
		else {			
			if (sx.find("'")!=-1) {
				res+="\"";
				res+=sx;
				res+="\"";
			}
			else {
				res+="'";
				res+=sx;
				res+="'";
			}
		}
	}
	res+="]";
	return res;
}

string KifList::String() {
	string res;
	list<KifElement*>::iterator it;
	res="[";
	bool beg=true;
	string sx;
	for (it=values.begin();it!=values.end();it++) {
		if (beg==false)
			res+=",";
		beg=false;
		sx=(*it)->String();
		sx=Trim(sx);
		if ((*it)->type!=kifString)
			res+=sx;
		else {			
			if (sx.find("'")!=-1) {
				res+="\"";
				res+=sx;
				res+="\"";
			}
			else {
				res+="'";
				res+=sx;
				res+="'";
			}
		}
	}
	res+="]";
	return res;
}

//===================================================================
KifFrame::KifFrame(KifCode* klc,KifElement* kp,short n,KifType ktype) : KifDomainInstruction(klc,kp,n,ktype) {
	declared=false;
	parent=NULL;
	function=NULL;
	if (kp!=NULL && kp->type==kifFrame)
		parent=(KifFrame*)kp;		
}

Exported bool KifFrame::Setvalue(KifElement* ke,KifElement* kkey,KifElement* dom) {
	ThreadLock _lock(type);
	string key=kkey->String();
	short skey=KifNewId(key);
	if (declarations.find(skey)!=declarations.end()) {
		string message=kifErrorStrings[234];
		message+=key;
		return kifcode->Returnerror(message);
	}

	if (!ke->Variable()) {
		KifVariable* var=new KifVariable(kifcode,NULL,ke,skey);				
		ke=var;
	}

	declarations[skey]=ke;
	ke->Setreference();
	return true;
}

Exported KifElement* KifFunctionSynchronous::Execute(KifElement* var,KifDomain* dom,KifElement* newvalue,bool rcouple) {
	//var is our variable
	ThreadLock _lock(kifLoquet);
	int idvar=var->idgarbage;
	if (newvalue->Boolean()==false) {
		//we use its idgarbage, which is unique as a way to trigger our semaphore
		//then we check, if we have any specific semaphore on this variable
		if (kifcode->loquets.find(idvar)==kifcode->loquets.end())
			return kifTRUE;
		//Else we release it
		LockedThread* l=kifcode->loquets[idvar];
		if (l->blocked==true)
			//the destruction will be done in PreSynchronized
			l->Released();		
		else {
			kifcode->loquets.erase(idvar);			
			delete l;		
		}
		return kifTRUE;
	}

	//else, we create our semaphore, if it does not exist
	if (kifcode->loquets.find(idvar)==kifcode->loquets.end())
		kifcode->loquets[idvar]=new LockedThread;
	return kifTRUE;
}

Exported KifElement* KifFrame::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
	ThreadLock _lock(type);
	if (val!=NULL && val->type==kifIndex) {
		string key=((KifIndex*)val)->key->String();
		short skey=KifStringId(key);
		if (skey==-1 || declarations.find(skey)==declarations.end()) {
			string message=kifErrorStrings[233];
			message+=key;
			return kifcode->Returnerror(message);
		}

		return declarations[skey]->Returnvalue();
	}
	string message=kifErrorStrings[233];
	return kifcode->Returnerror(message);
}

Exported KifElement* KifFrame::Map(KifElement* context) {
	ThreadLock _lock(type);
	KifMap* kmap=Selectmap(this,context);
	hmap<short,KifElement*>::iterator it;
	for (it=declarations.begin();it!=declarations.end();it++) {
		string s=KifIdString(it->first);
		if (it->second->type==kifFunction)
			kmap->Push(s,kifcode->Providestringraw("function"));
		else 
			if (it->second->type==kifDomain) {
				KifDomain* d=(KifDomain*)it->second;
				if (d->frame!=NULL) {
					string sx=KifIdString(d->frame->Name());
					kmap->Push(s,kifcode->Providestring(sx));
				}
				else
					kmap->Push(s,kifcode->Providestringraw("frame"));
			}
			else {
				string sx=it->second->String();
				if (sx=="")
					sx=kifStringType[it->second->type];
				kmap->Push(s,kifcode->Providestring(sx));
			}
	}
	return kmap;
}

Exported string KifFrame::String() {
	KifMap* m=(KifMap*)Map(this);
	return m->String();
}

Exported KifElement* KifFrame::Pop(KifElement* kkey) {
	ThreadLock _lock(type);
	string key=kkey->String();
	short skey=KifStringId(key);
	if (skey==-1) {
		string message=kifErrorStrings[233];
		message+=key;
		return kifcode->Returnerror(message);
	}
	KifElement* res=declarations[skey];
	declarations.erase(skey);
	res->popped=true;
	res->Resetreference();
	return res;
}

//===================================================================
KifDate::KifDate(KifCode* klc,KifElement* kp,time_t v) : KifElement(klc,kp,kifDate) {
	if (v==0)
		time(&value);
	else
		value=v;
}

Exported KifElement* KifFraction::applyinitial(KifDomain* dom,KifElement* ke) {
	KifElement* kinit=ke->Instruction(0)->Execute(kifNULL,dom);
	if (ke->InstructionSize()==2) {
		numerator=kinit->Integer();
		denominator=ke->Instruction(1)->Execute(kifNULL,dom)->Integer();
	}
	else {
		numerator=kinit->N();
		denominator=kinit->D();		
	}

	return this;
}

Exported KifElement* KifDate::applyinitial(KifDomain* dom,KifElement* ke) {
	KifElement* kinit=ke->Instruction(0)->Execute(kifNULL,dom);
	
	if (kinit->type==kifDate) {
		memcpy((void*)&value,(void*)&((KifDate*)kinit)->value,sizeof(time_t));
		return kifTRUE;
	}
	
	struct tm* temps;
	time_t x=0;
	temps=localtime(&x);
	
	int fulldate=0;
	
	
	//Year
	long res=kinit->Integer();
	if (res>0) {
		temps->tm_year=res-1900;
		fulldate=100;
	}
	
	
	//Month
	if (ke->InstructionSize()>=2) {
		res=ke->Instruction(1)->Execute(kifNULL,dom)->Integer();
		if (res>0) {
			fulldate+=10;
			temps->tm_mon=res-1;
		}
	}
	
	//Day
	if (ke->InstructionSize()>=3) {
		res=ke->Instruction(2)->Execute(kifNULL,dom)->Integer();
		if (res>0) {
			fulldate+=1;
			temps->tm_mday=res;		
		}
	}

	//Hour
	if (ke->InstructionSize()>=4) {
		res=ke->Instruction(3)->Execute(kifNULL,dom)->Integer();
		if (res>=0 && res<24) {
			//reference is 1AM
			if (fulldate==0)
				res+=2;
			else
				if (fulldate==1)
					res+=1;
			temps->tm_hour=res;
		}
	}

	
	//Minute
	if (ke->InstructionSize()>=5) {
		res=ke->Instruction(4)->Execute(kifNULL,dom)->Integer();
		if (res>=0 && res<60)
			temps->tm_min=res;
	}
	
	//Second
	if (ke->InstructionSize()>=6) {
		res=ke->Instruction(5)->Execute(kifNULL,dom)->Integer();
		if (res>=0 && res<60)
			temps->tm_sec=res;
	}
	
	
	x=mktime(temps);
	if (x<=0)
		return kifFALSE;
	value=x;
	return kifTRUE;
	
}

KifElement* KifDate::Copy(KifDomain* kp,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Time::Copy");
#endif
	KifElement* ke=new KifDate(kifcode,(KifElement*)kp,0);
	return ke;
}

KifElement* KifDate::Newinstance() {
	KifDate* ke=new KifDate(kifcode,NULL);
	return ke;
}
//----------------------------------------------------------------------------------------

KifTime::KifTime(KifCode* klc,KifElement* kp) : KifElement(klc,kp,kifTime) {
	gettimeofday(&value, NULL);
}

KifElement* KifTime::Copy(KifDomain* kp,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Time::Copy");
#endif
	KifElement* ke=new KifTime(kifcode,(KifElement*)kp);
	return ke;
}

KifElement* KifTime::Newinstance() {
	KifTime* ke=new KifTime(kifcode,NULL);
	return ke;
}

//===================================================================
KifInstance::KifInstance(KifCode* klc,KifElement* kp,string n,KifVariableDeclaration* d) : KifInstanceCommon(klc,kp,-1,d) {
	value=d->value;
	index=NULL;
	self=false;
	name=KifNewId(n);
}

KifVariableDeclaration::KifVariableDeclaration(KifCode* klc,KifElement* kp,string n,KifType kt) : KifElement(klc,kp,kt) {
	value=kifNULL;		
	name=KifNewId(n);
	line=-1;
	initialisation=kifNULL;
	xip=false;
	function=NULL;
}

//===================================================================
KifCallFunctionExternal::KifCallFunctionExternal(KifCode* klc,KifElement* kp,short n,KifFunction* b) : KifCallFunction(klc,kp,n) {
	body=(KifCallMethod*)b;
	type=kifCallFunctionExternal;
}
//===================================================================
bool KifFile::Write(string n) {
	ThreadLock _lock(type);
	if (mode!=2)
		return false;
	*thefile<<STR(n);
	return true;
}

KifElement* KifFile::Read() {
	ThreadLock _lock(type);
	if (EndOfFile()->Boolean()==true)
		return kifNULL;

	if (fileread!=NULL) {
		fgets(kifcode->buffer,4096,fileread);
		localstring->value=kifcode->buffer;
	}
	else
		getline(*thefile,localstring->value);
	return localstring;
}

KifElement* KifFile::Readoneline() {
	ThreadLock _lock(type);
	if (EndOfFile()->Boolean()==true)
		return kifNULL;

	if (fileread!=NULL) {
		fgets(kifcode->buffer,4096,fileread);
		localstring->value=kifcode->buffer;
	}
	else
		getline(*thefile,localstring->value);
	return localstring;
}

//===================================================================
//A variable is looked for, first in the function declarations, then in the domain, then among the global
//variables

KifElement* KifCode::Getbasic(short n,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Code::Getbasic");
#endif
	ThreadLock _lock(kifStack);
	KifElement* v;
	if (dom!=NULL) {
		v=dom->Declaration(n);
		if (v!=NULL)
			return v;
	}
	vector<KifDomain*>::reverse_iterator it;	
	int id=GetThreadid();
	if (id==-1) {
		for (it=stacking.rbegin();it!=stacking.rend();it++) {
			v=(*it)->Declared(n);
			if (v!=NULL)
				return v;
		}
	}
	else {
		for (it=threadstacks[id].rbegin();it!=threadstacks[id].rend();it++) {
			v=(*it)->Declared(n);
			if (v!=NULL)
				return v;
		}
	}
	return NULL;
}

KifElement* KifCode::Get(short n,KifDomain* dom) {
	KifElement* v;
	if (dom!=NULL) {
		v=dom->Declared(n);
		if (v!=NULL)
			return v;
	}
	vector<KifDomain*>::reverse_iterator it;	
	ThreadLock _lock(kifStack);
	int id=GetThreadid();
	if (id==-1) {
		for (it=stacking.rbegin();it!=stacking.rend();it++) {
			v=(*it)->Declared(n);
			if (v!=NULL)
				return v;
		}
	}
	else {
		for (it=threadstacks[id].rbegin();it!=threadstacks[id].rend();it++) {
			v=(*it)->Declared(n);
			if (v!=NULL)
				return v;
		}
	}
	return NULL;
}

KifElement* KifCode::Getframe(short n,KifElement* dom) {
	ThreadLock _lock(kifStack);
	KifElement* v;
	if (dom!=NULL && dom->type==kifFrame) {
		v=dom->Declaration(n);
		if (v!=NULL)
			return v;
	}
	vector<KifDomain*>::reverse_iterator it;	
	int id=GetThreadid();
	if (id==-1) {
		for (it=stacking.rbegin();it!=stacking.rend();it++) {
			if ((*it)->type!=kifFrame)
				continue;
			v=(*it)->Declared(n);
			if (v!=NULL && v->type==kifFrame)
				return v;
		}
	}
	else {
		for (it=threadstacks[id].rbegin();it!=threadstacks[id].rend();it++) {
			if ((*it)->type!=kifFrame)
				continue;
			v=(*it)->Declared(n);
			if (v!=NULL && v->type==kifFrame)
				return v;
		}
	}
	return NULL;
}
//===================================================================

KifElement* KifDate::plus(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Time::plus");
#endif
	if (autoself==false) {
		value+=b->Integer();
		return this;
	}
	long i=a->Integer()+b->Integer();
	KifElement* kv= new KifDate(kifcode,NULL,i);
	return kv;

}
KifElement* KifDate::minus(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Time::minus");
#endif
	if (autoself==false) {
		value=difftime(value,b->Integer());
		return this;
	}
	time_t i=difftime(a->Integer(),b->Integer());
	KifElement* kv= new KifDate(kifcode,NULL,i);
	return kv;
}

KifElement* KifTime::plus(KifElement* aa,KifElement* bb,bool autoself) {
#ifdef PROFILING
	profilingcall("Time::minus");
#endif
	if (aa->type!=kifTime && bb->type!=kifTime)
		return kifNULL;

	KifTime* a=(KifTime*)aa;
	KifTime* b=(KifTime*)bb;
	
	KifFloat* kv= kifcode->Providefloat(a->Float()+b->Float());
	return kv;
}

KifElement* KifTime::minus(KifElement* aa,KifElement* bb,bool autoself) {
#ifdef PROFILING
	profilingcall("Time::minus");
#endif
	if (aa->type!=kifTime && bb->type!=kifTime)
		return kifNULL;

	KifTime* a=(KifTime*)aa;
	KifTime* b=(KifTime*)bb;
	double v=a->Float()-b->Float();
	KifFloat* kv= kifcode->Providefloat(v);
	return kv;
}
//===================================================================

Exported void KifTree::Flatten(KifVector* kvect,KifTree* t) {
	if (t==NULL)
		return;
	kvect->Push(t);
	Flatten(kvect,t->child);
	Flatten(kvect,t->next);
}

Exported KifElement* KifTree::Vector(KifElement*) {
	KifVector* kvect=kifcode->Providevector();
	Flatten(kvect,this);
	return kvect;
}

Exported void KifTree::Mapping(KifMap* kmap,KifTree* t) {
	if (t==NULL)
		return;
	sprintf_s(kifcode->buffer,100,"%d",t->hight);
	KifVector* kvect;
	if (kmap->values.find(kifcode->buffer)==kmap->values.end()) {
		kvect=kifcode->Providevector();
		kmap->Push(kifcode->buffer,kvect);
	}
	else
		kvect=(KifVector*)kmap->values[kifcode->buffer];

	kvect->Push(t);
	Mapping(kmap,t->child);
	Mapping(kmap,t->next);
}

Exported KifElement* KifTree::Map(KifElement*) {
	KifMap* kmap=kifcode->Providemap();
	Mapping(kmap,this);
	return kmap;
}


Exported  KifElement* KifTree::TreeAddchild(KifTree* t) {
	if (t==NULL)
		return kifFALSE;
	t->TreeExtract(this);
	t->SetHight(hight+1);
	t->parent=this;
	if (last==NULL) {
		child=t;
		last=t;
	}
	else {
		t->previous=last;
		last->next=t;
		last=t;
	}
	t->Initreference();
	return kifTRUE;
}

Exported KifElement* KifTree::TreeAddnext(KifTree* t) {
	if (t==NULL)
		return kifFALSE;
	t->TreeExtract(this);
	t->SetHight(hight);
	t->previous=this;
	t->next=next;
	if (next!=NULL)
		next->previous=t;
	next=t;
	t->parent=parent;
	if (parent!=NULL && parent->last==this)
		parent->last=t;		
	t->Initreference();
	return kifTRUE;
}

void KifTree::Initreference() {
	if (next!=NULL)
		Setreference();
	if (previous!=NULL)
		Setreference();
	if (parent!=NULL)
		Setreference();
	if (child!=NULL)
		Setreference();
}

Exported KifElement* KifTree::TreeAddprevious(KifTree* t) {
	if (t==NULL)
		return kifFALSE;
	t->TreeExtract(this);
	t->SetHight(hight);
	t->next=this;
	t->parent=parent;
	t->previous=previous;
	if (previous!=NULL)
		previous->next=t;
	previous=t;	
	if (parent!=NULL && parent->child==this)
		parent->child=t;		
	t->Initreference();
	return kifTRUE;
}

Exported void KifTree::SetHight(int seed) {
	hight=seed;
	if (child!=NULL)
		child->SetHight(seed+1);
	if (next!=NULL)
		next->SetHight(seed);
}

//Extract remove a node from its position in the tree, if this node is a new node, we also increment its reference
//Note that if the node has a child, it is NOT removed from it. We can move a subtree in this way...
Exported KifElement* KifTree::TreeExtract(KifTree* node) {		
	if (node==this)
		return kifcode->Returnerror(kifErrorStrings[205]);
	if (parent!=NULL) {
		if (node!=NULL) {
			KifTree* p=node->parent;
			//We put a constraint, which is that is the current node is under the node,
			//which it should play with, then we return an error
			while (p!=NULL) {
				if (p==this)
					return kifcode->Returnerror(kifErrorStrings[204]);
				p=p->parent;
			}
		}
		Resetreference();
		if (parent->child==this)
			parent->child=next;
		if (parent->last==this)
			parent->last=previous;
	}

	if (next!=NULL) {
		if (next->previous!=NULL)
			next->previous=previous;
		Resetreference();
	}

	if (previous!=NULL) {
		if (previous->next!=NULL)
			previous->next=next;
		Resetreference();
	}

	next=NULL;
	previous=NULL;
	parent=NULL;
	if (node==NULL)
		SetHight(0);
	return this;
}


Exported KifElement* KifTree::TreeRemove() {
	if (child!=NULL) {
		Resetreference();
		while (child!=NULL) {
			child->TreeRemove();
			child=child->next;
		}
	}
	if (next!=NULL) {
		Resetreference();
		if (next->previous!=NULL)
			next->previous=previous;
	}
	if (previous!=NULL) {
		Resetreference();
		if (previous->next!=NULL)
			previous->next=next;
	}
	if (parent!=NULL) {
		Resetreference();
		if (parent->child==this)
			parent->child=next;
		if (parent->last==this)
			parent->last=previous;
	}
	next=NULL;
	previous=NULL;
	parent=NULL;
	child=NULL;
	Setpopped();
	return kifTRUE;
}

//==================================(KifElement* a,KifElement* b,bool autoself)=================================

KifElement* KifVector::orset(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::orset");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifVector* ref=this;
	KifVector* A=(KifVector*)a;
	if (autoself==false)
		ref=(KifVector*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifVector*)a;
	
	int it;
	KifElement* ke;
	KifElement* kref;
	bool found;

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int itref;
		for (itref=0;itref<bref->values.size();itref++) {
			kref=bref->values[itref];
			found=false;
			for (it=0;it<A->values.size();it++) {
				ke=A->values[it];
				if (kref->same(ke)==kifTRUE) {
					found=true;
					break;
				}
			}	
			if (found==false)
				ref->Push(kref);
		}
		return ref;
	}

	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itref;
		for (itref=bref->values.begin();itref!=bref->values.end();itref++) {
			kref=*itref;
			found=false;
			for (it=0;it<A->values.size();it++) {
				ke=A->values[it];
				if (kref->same(ke)==kifTRUE) {
					found=true;
					break;
				}
			}	
			if (found==false)
				ref->Push(kref);
		}
		return ref;
	}

	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (;itmap!=bref->values.end();itmap++) {
			kref=itmap->second;
			for (it=0;it<A->values.size();it++) {
				ke=A->values[it];
				if (kref->same(ke)==kifTRUE) {
					found=true;
					break;
				}
			}
			if (found==false)
				ref->Push(kref);
		}
		return ref;
	}
	return kifNULL;
}

KifElement* KifVector::andset(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::andset");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifVector* A=(KifVector*)a;
	KifVector* ref;
	int it;
	KifElement* ke;
	KifElement* kref;
	bool found;
	if (b->type==kifVector) {
		ref=kifcode->Providevector();
		KifVector* bref=(KifVector*)b;		
		int itref;
		for (itref=0;itref<bref->values.size();itref++) {
			kref=bref->values[itref];
			found=false;
			for (it=0;it<A->values.size();it++) {
				ke=A->values[it];
				if (kref->same(ke)==kifTRUE) {
					found=true;
					break;
				}
			}	
			if (found==true)
				ref->Push(kref);
		}
		return ref;
	}

	if (b->type==kifList) {
		ref=kifcode->Providevector();
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itref;
		for (itref=bref->values.begin();itref!=bref->values.end();itref++) {
			kref=*itref;
			found=false;
			for (it=0;it<A->values.size();it++) {
				ke=A->values[it];
				if (kref->same(ke)==kifTRUE) {
					found=true;
					break;
				}
			}	
			if (found==true)
				ref->Push(kref);
		}
		return ref;
	}

	if (b->type==kifMap) {
		ref=kifcode->Providevector();
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (;itmap!=bref->values.end();itmap++) {
			kref=itmap->second;
			found=false;
			for (it=0;it<A->values.size();it++) {
				ke=A->values[it];
				if (kref->same(ke)==kifTRUE) {
					found=true;
					break;
				}
			}
			if (found==true)
				ref->Push(kref);
		}
		return ref;
	}
	return kifNULL;
}

Exported KifElement* KifVector::same(KifElement* a) {
	
	if (a->type!=kifVector)
		return kifFALSE;
	KifVector* v=(KifVector*)a;
	if (v->values.size()!=values.size())
		return kifFALSE;
	for (int i=0;i<values.size();i++) {
		if (values[i]->same(v->values[i])==kifFALSE)
			return kifFALSE;
	}
	return kifTRUE;
}

Exported KifElement* KifList::same(KifElement* a) {
	
	if (a->type!=kifList)
		return kifFALSE;
	KifList* v=(KifList*)a;
	if (v->values.size()!=values.size())
		return kifFALSE;
	list<KifElement*>::iterator it;
	list<KifElement*>::iterator itv;
	for (it=values.begin(),itv=v->values.begin();it!=values.end();it++,itv++) {
		if ((*it)->same(*itv)==kifFALSE)
			return kifFALSE;
	}
	return kifTRUE;
}

KifElement* KifVector::plus(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::plus");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifVector* ref=this;
	if (autoself==false)
		ref=(KifVector*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifVector*)a;

	int it;
	KifElement* ke;
	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=0;it<ref->values.size();it++) {
			if (j>=bref->values.size())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->plus(ke,bref->values[j++],true);
		}
		return ref;
	}
	
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=0;itl!=bref->values.end(),it<ref->values.size();it++,itl++) {
			ke=ref->values[it];
			ke->Resetreference();
			ke->plus(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=0;it<ref->values.size();it++) {
			if (itmap==bref->values.end())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->plus(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}
	for (it=0;it<ref->values.size();it++) {
		ke=ref->values[it];
		ke->Resetreference();
		ke->plus(ke,b,true);
	}
	return ref;
}

KifElement* KifVector::minus(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::minus");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifVector* ref=this;
	if (autoself==false)
		ref=(KifVector*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifVector*)a;

	int it;
	KifElement* ke;
	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=0;it<ref->values.size();it++) {
			if (j>=bref->values.size())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->minus(ke,bref->values[j++],true);
		}
		return ref;
	}
	
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=0;itl!=bref->values.end(),it<ref->values.size();it++,itl++) {
			ke=ref->values[it];
			ke->Resetreference();
			ke->minus(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=0;it<ref->values.size();it++) {
			if (itmap==bref->values.end())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->minus(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}
	for (it=0;it<ref->values.size();it++) {
		ke=ref->values[it];
		ke->Resetreference();
		ke->minus(ke,b,true);
	}
	return ref;
}

KifElement* KifVector::multiply(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::multiply");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifVector* ref=this;
	if (autoself==false)
		ref=(KifVector*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifVector*)a;

	int it;
	KifElement* ke;
	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=0;it<ref->values.size();it++) {
			if (j>=bref->values.size())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->multiply(ke,bref->values[j++],true);
		}
		return ref;
	}
	
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=0;itl!=bref->values.end(),it<ref->values.size();it++,itl++) {
			ke=ref->values[it];
			ke->Resetreference();
			ke->multiply(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=0;it<ref->values.size();it++) {
			if (itmap==bref->values.end())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->multiply(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}
	for (it=0;it<ref->values.size();it++) {
		ke=ref->values[it];
		ke->Resetreference();
		ke->multiply(ke,b,true);
	}
	return ref;
}

KifElement* KifVector::divide(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::divide");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifVector* ref=this;
	if (autoself==false)
		ref=(KifVector*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifVector*)a;

	int it;
	KifElement* ke;
	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=0;it<ref->values.size();it++) {
			if (j>=bref->values.size())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->divide(ke,bref->values[j++],true);
		}
		return ref;
	}
	
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=0;itl!=bref->values.end(),it<ref->values.size();it++,itl++) {
			ke=ref->values[it];
			ke->Resetreference();
			ke->divide(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=0;it<ref->values.size();it++) {
			if (itmap==bref->values.end())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->divide(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}
	for (it=0;it<ref->values.size();it++) {
		ke=ref->values[it];
		ke->Resetreference();
		ke->divide(ke,b,true);
	}
	return ref;
}

KifElement* KifVector::mod(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::mod");
#endif
	if (a->type!=kifVector)
		return kifNULL;
	
	KifVector* ref=this;
	if (autoself==false)
		ref=(KifVector*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifVector*)a;

	int it;
	KifElement* ke;
	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=0;it<ref->values.size();it++) {
			if (j>=bref->values.size())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->mod(ke,bref->values[j++],true);
		}
		return ref;
	}
	
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=0;itl!=bref->values.end(),it<ref->values.size();it++,itl++) {
			ke=ref->values[it];
			ke->Resetreference();
			ke->mod(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=0;it<ref->values.size();it++) {
			if (itmap==bref->values.end())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->mod(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}
	for (it=0;it<ref->values.size();it++) {
		ke=ref->values[it];
		ke->Resetreference();
		ke->mod(ke,b,true);
	}
	return ref;
}

KifElement* KifVector::shiftright(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::shiftright");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifVector* ref=this;
	if (autoself==false)
		ref=(KifVector*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifVector*)a;

	int it;
	KifElement* ke;
	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=0;it<ref->values.size();it++) {
			if (j>=bref->values.size())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->shiftright(ke,bref->values[j++],true);
		}
		return ref;
	}
	
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=0;itl!=bref->values.end(),it<ref->values.size();it++,itl++) {
			ke=ref->values[it];
			ke->Resetreference();
			ke->shiftright(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=0;it<ref->values.size();it++) {
			if (itmap==bref->values.end())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->shiftright(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}
	for (it=0;it<ref->values.size();it++) {
		ke=ref->values[it];
		ke->Resetreference();
		ke->shiftright(ke,b,true);
	}
	return ref;
}
KifElement* KifVector::shiftleft(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::shiftleft");
#endif
	if (a->type!=kifVector)
		return kifNULL;
	
	KifVector* ref=this;
	if (autoself==false)
		ref=(KifVector*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifVector*)a;

	int it;
	KifElement* ke;
	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=0;it<ref->values.size();it++) {
			if (j>=bref->values.size())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->shiftleft(ke,bref->values[j++],true);
		}
		return ref;
	}
	
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=0;itl!=bref->values.end(),it<ref->values.size();it++,itl++) {
			ke=ref->values[it];
			ke->Resetreference();
			ke->shiftleft(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=0;it<ref->values.size();it++) {
			if (itmap==bref->values.end())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->shiftleft(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}
	for (it=0;it<ref->values.size();it++) {
		ke=ref->values[it];
		ke->Resetreference();
		ke->shiftleft(ke,b,true);
	}
	return ref;
}

KifElement* KifVector::power(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::power");
#endif
	if (a->type!=kifVector)
		return kifNULL;
	
	KifVector* ref=this;
	if (autoself==false)
		ref=(KifVector*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifVector*)a;

	int it;
	KifElement* ke;
	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=0;it<ref->values.size();it++) {
			if (j>=bref->values.size())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->power(ke,bref->values[j++],true);
		}
		return ref;
	}
	
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=0;itl!=bref->values.end(),it<ref->values.size();it++,itl++) {
			ke=ref->values[it];
			ke->Resetreference();
			ke->power(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=0;it<ref->values.size();it++) {
			if (itmap==bref->values.end())
				break;
			ke=ref->values[it];
			ke->Resetreference();
			ke->power(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}
	for (it=0;it<ref->values.size();it++) {
		ke=ref->values[it];
		ke->Resetreference();
		ke->power(ke,b,true);
	}
	return ref;
}

//===================================================================

KifElement* KifMap::orset(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Map::orset");
#endif
	
	if (a->type!=kifMap || b->type!=kifMap)
		return kifNULL;

	KifMap* A=(KifMap*)a;
	hmap<string,KifElement*>::iterator it;

	KifMap* ref=this;
	if (autoself==false)
		ref=(KifMap*)a->Copy(NULL);

	KifMap* bref=(KifMap*)b;		
	string ky;
	for (it=bref->values.begin();it!=bref->values.end();it++) {
		if (A->values.find(it->first)==A->values.end()) {
			ky=it->first;
			ref->Push(ky,it->second);
			it->second->Setreference();
		}
	}
	return ref;
}

KifElement* KifMap::andset(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Map::andset");
#endif
	
	if (a->type!=kifMap || b->type!=kifMap)
		return kifNULL;

	KifMap* A=(KifMap*)a;
	hmap<string,KifElement*>::iterator it;
	hmap<string,KifElement*>::iterator itres;

	KifMap* ref=kifcode->Providemap();
	KifMap* bref=(KifMap*)b;		
	string ky;
	for (it=bref->values.begin();it!=bref->values.end();it++) {
		itres=A->values.find(it->first);
		if (itres!=A->values.end()) {
			ky=it->first;
			ref->Push(ky,it->second);
			itres->second->Setreference();
		}
	}
	return ref;
}

Exported KifElement* KifMap::same(KifElement* a) {
	
	if (a->type!=kifMap)
		return kifFALSE;
	KifMap* m=(KifMap*)a;
	if (m->values.size()!=values.size())
		return kifFALSE;
	
	hmap<string,KifElement*>::iterator it=m->values.begin();
	while (it!=m->values.end()) {
		if (values.find(it->first)==values.end())
			return kifFALSE;
		if (it->second->same(values[it->first])==kifFALSE)
			return kifFALSE;
		it++;
	}
	return kifTRUE;
}



KifElement* KifMap::plus(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Map::plus");
#endif
	
	if (a->type!=kifMap)
		return kifNULL;
	
	KifMap* ref=this;
	if (autoself==false)
		ref=(KifMap*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifMap*)a;

	hmap<string,KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=it->second;
			ke->Resetreference();
			ke->plus(ke,*itl,true);
		}
		return ref;
	}
	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=it->second;
			ke->Resetreference();
			ke->plus(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;				
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (bref->values.find(it->first)!=bref->values.end()) {
				ke=it->second;
				ke->Resetreference();
				ke->plus(ke,bref->values[it->first],true);
			}
		}
		return ref;
	}
	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=it->second;
		ke->Resetreference();
		ke->plus(ke,b,true);
	}
	return ref;
}

KifElement* KifMap::minus(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Map::minus");
#endif
	
	if (a->type!=kifMap)
		return kifNULL;
	
	KifMap* ref=this;
	if (autoself==false)
		ref=(KifMap*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifMap*)a;

	hmap<string,KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=it->second;
			ke->Resetreference();
			ke->minus(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=it->second;
			ke->Resetreference();
			ke->minus(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;				
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (bref->values.find(it->first)!=bref->values.end()) {
				ke=it->second;
				ke->Resetreference();
				ke->minus(ke,bref->values[it->first],true);
			}
		}
		return ref;
	}
	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=it->second;
		ke->Resetreference();
		ke->minus(ke,b,true);
	}
	return ref;
}


KifElement* KifMap::multiply(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Map::multiply");
#endif
	
	if (a->type!=kifMap)
		return kifNULL;
	
	KifMap* ref=this;
	if (autoself==false)
		ref=(KifMap*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifMap*)a;

	hmap<string,KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=it->second;
			ke->Resetreference();
			ke->multiply(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=it->second;
			ke->Resetreference();
			ke->multiply(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;				
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (bref->values.find(it->first)!=bref->values.end()) {
				ke=it->second;
				ke->Resetreference();
				ke->multiply(ke,bref->values[it->first],true);
			}
		}
		return ref;
	}
	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=it->second;
		ke->Resetreference();
		ke->multiply(ke,b,true);
	}
	return ref;
}

KifElement* KifMap::divide(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Map::divide");
#endif
	
	if (a->type!=kifMap)
		return kifNULL;
	
	KifMap* ref=this;
	if (autoself==false)
		ref=(KifMap*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifMap*)a;

	hmap<string,KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=it->second;
			ke->Resetreference();
			ke->divide(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=it->second;
			ke->Resetreference();
			ke->divide(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;				
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (bref->values.find(it->first)!=bref->values.end()) {
				ke=it->second;
				ke->Resetreference();
				ke->divide(ke,bref->values[it->first],true);
			}
		}
		return ref;
	}
	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=it->second;
		ke->Resetreference();
		ke->divide(ke,b,true);
	}
	return ref;
}

KifElement* KifMap::mod(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Map::mod");
#endif
	
	if (a->type!=kifMap)
		return kifNULL;
	
	KifMap* ref=this;
	if (autoself==false)
		ref=(KifMap*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifMap*)a;

	hmap<string,KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=it->second;
			ke->Resetreference();
			ke->mod(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=it->second;
			ke->Resetreference();
			ke->mod(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;				
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (bref->values.find(it->first)!=bref->values.end()) {
				ke=it->second;
				ke->Resetreference();
				ke->mod(ke,bref->values[it->first],true);
			}
		}
		return ref;
	}
	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=it->second;
		ke->Resetreference();
		ke->mod(ke,b,true);
	}
	return ref;
}

KifElement* KifMap::shiftright(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Map::shiftright");
#endif
	
	if (a->type!=kifMap)
		return kifNULL;
	
	KifMap* ref=this;
	if (autoself==false)
		ref=(KifMap*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifMap*)a;

	hmap<string,KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=it->second;
			ke->Resetreference();
			ke->shiftright(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=it->second;
			ke->Resetreference();
			ke->shiftright(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;				
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (bref->values.find(it->first)!=bref->values.end()) {
				ke=it->second;
				ke->Resetreference();
				ke->shiftright(ke,bref->values[it->first],true);
			}
		}
		return ref;
	}
	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=it->second;
		ke->Resetreference();
		ke->shiftright(ke,b,true);
	}
	return ref;
}

KifElement* KifMap::shiftleft(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Map::shiftleft");
#endif
	
	if (a->type!=kifMap)
		return kifNULL;
	
	KifMap* ref=this;
	if (autoself==false)
		ref=(KifMap*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifMap*)a;

	hmap<string,KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=it->second;
			ke->Resetreference();
			ke->shiftleft(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=it->second;
			ke->Resetreference();
			ke->shiftleft(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;				
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (bref->values.find(it->first)!=bref->values.end()) {
				ke=it->second;
				ke->Resetreference();
				ke->shiftleft(ke,bref->values[it->first],true);
			}
		}
		return ref;
	}
	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=it->second;
		ke->Resetreference();
		ke->shiftleft(ke,b,true);
	}
	return ref;
}

KifElement* KifMap::power(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Map::power");
#endif
	
	if (a->type!=kifMap)
		return kifNULL;
	
	KifMap* ref=this;
	if (autoself==false)
		ref=(KifMap*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifMap*)a;

	hmap<string,KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=it->second;
			ke->Resetreference();
			ke->power(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=it->second;
			ke->Resetreference();
			ke->power(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;				
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (bref->values.find(it->first)!=bref->values.end()) {
				ke=it->second;
				ke->Resetreference();
				ke->power(ke,bref->values[it->first],true);
			}
		}
		return ref;
	}
	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=it->second;
		ke->Resetreference();
		ke->power(ke,b,true);
	}
	return ref;
}
//-----------------------------------------------------------------------------------------------
KifElement* KifList::orset(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::orset");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifList* ref=this;
	KifList* A=(KifList*)a;
	if (autoself==false)
		ref=(KifList*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifList*)a;
	
	list<KifElement*>::iterator it;
	KifElement* ke;
	KifElement* kref;
	bool found;

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int itref;
		for (itref=0;itref<bref->values.size();itref++) {
			kref=bref->values[itref];
			found=false;
			for (it=A->values.begin();it!=A->values.end();it++) {
				ke=*it;
				if (kref->same(ke)==kifTRUE) {
					found=true;
					break;
				}
			}	
			if (found==false)
				ref->Push(kref);
		}
		return ref;
	}

	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itref;
		for (itref=bref->values.begin();itref!=bref->values.end();itref++) {
			kref=*itref;
			found=false;
			for (it=A->values.begin();it!=A->values.end();it++) {
				ke=*it;
				if (kref->same(ke)==kifTRUE) {
					found=true;
					break;
				}
			}	
			if (found==false)
				ref->Push(kref);
		}
		return ref;
	}

	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (;itmap!=bref->values.end();itmap++) {
			kref=itmap->second;
			for (it=A->values.begin();it!=A->values.end();it++) {
				ke=*it;
				if (kref->same(ke)==kifTRUE) {
					found=true;
					break;
				}
			}
			if (found==false)
				ref->Push(kref);
		}
		return ref;
	}
	return kifNULL;
}

KifElement* KifList::andset(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::andset");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifList* A=(KifList*)a;
	KifList* ref;
	list<KifElement*>::iterator it;
	KifElement* ke;
	KifElement* kref;
	bool found;
	if (b->type==kifVector) {
		ref=new KifList(kifcode,NULL);
		KifVector* bref=(KifVector*)b;		
		int itref;
		for (itref=0;itref<bref->values.size();itref++) {
			kref=bref->values[itref];
			found=false;
			for (it=A->values.begin();it!=A->values.end();it++) {
				ke=*it;
				if (kref->same(ke)==kifTRUE) {
					found=true;
					break;
				}
			}	
			if (found==true)
				ref->Push(kref);
		}
		return ref;
	}

	if (b->type==kifList) {
		ref=new KifList(kifcode,NULL);
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itref;
		for (itref=bref->values.begin();itref!=bref->values.end();itref++) {
			kref=*itref;
			found=false;
			for (it=A->values.begin();it!=A->values.end();it++) {
				ke=*it;
				if (kref->same(ke)==kifTRUE) {
					found=true;
					break;
				}
			}	
			if (found==true)
				ref->Push(kref);
		}
		return ref;
	}

	if (b->type==kifMap) {
		ref=new KifList(kifcode,NULL);
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (;itmap!=bref->values.end();itmap++) {
			kref=itmap->second;
			found=false;
			for (it=A->values.begin();it!=A->values.end();it++) {
				ke=*it;
				if (kref->same(ke)==kifTRUE) {
					found=true;
					break;
				}
			}
			if (found==true)
				ref->Push(kref);
		}
		return ref;
	}
	return kifNULL;
}


KifElement* KifList::plus(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::plus");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifList* ref=this;
	if (autoself==false)
		ref=(KifList*)a->Copy(NULL);
	else
		if (a!=this)
			ref=(KifList*)a;

	list<KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=*it;
			ke->Resetreference();
			ke->plus(ke,bref->values[j++],true);
		}
		return ref;
	}
	
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=*it;
			ke->Resetreference();
			ke->plus(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (itmap==bref->values.end())
				break;
			ke=*it;
			ke->Resetreference();
			ke->plus(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}
	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=*it;
		ke->Resetreference();
		ke->plus(ke,b,true);
	}
	return ref;
}

KifElement* KifList::minus(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::minus");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifList* ref=this;
	if (autoself==false)
		ref=(KifList*)a->Copy(NULL);
		else
			if (a!=this)
				ref=(KifList*)a;

	list<KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=*it;
			ke->Resetreference();
			ke->plus(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=*it;
			ke->Resetreference();
			ke->plus(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (itmap==bref->values.end())
				break;
			ke=*it;
			ke->Resetreference();
			ke->minus(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}

	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=*it;
		ke->Resetreference();
		ke->minus(ke,b,true);
	}
	return ref;
}

KifElement* KifList::multiply(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::multiply");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifList* ref=this;
	if (autoself==false)
		ref=(KifList*)a->Copy(NULL);
		else
			if (a!=this)
				ref=(KifList*)a;

	list<KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=*it;
			ke->Resetreference();
			ke->multiply(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=*it;
			ke->Resetreference();
			ke->multiply(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (itmap==bref->values.end())
				break;
			ke=*it;
			ke->Resetreference();
			ke->multiply(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}

	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=*it;
		ke->Resetreference();
		ke->multiply(ke,b,true);
	}
	return ref;
}
KifElement* KifList::divide(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::divide");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifList* ref=this;
	if (autoself==false)
		ref=(KifList*)a->Copy(NULL);
		else
			if (a!=this)
				ref=(KifList*)a;

	list<KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=*it;
			ke->Resetreference();
			ke->divide(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=*it;
			ke->Resetreference();
			ke->divide(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (itmap==bref->values.end())
				break;
			ke=*it;
			ke->Resetreference();
			ke->divide(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}

	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=*it;
		ke->Resetreference();
		ke->divide(ke,b,true);
	}
	return ref;
}
KifElement* KifList::mod(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::mod");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifList* ref=this;
	if (autoself==false)
		ref=(KifList*)a->Copy(NULL);
		else
			if (a!=this)
				ref=(KifList*)a;

	list<KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=*it;
			ke->Resetreference();
			ke->mod(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=*it;
			ke->Resetreference();
			ke->mod(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (itmap==bref->values.end())
				break;
			ke=*it;
			ke->Resetreference();
			ke->mod(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}

	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=*it;
		ke->Resetreference();
		ke->mod(ke,b,true);
	}
	return ref;
}
KifElement* KifList::shiftright(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::shiftright");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifList* ref=this;
	if (autoself==false)
		ref=(KifList*)a->Copy(NULL);
		else
			if (a!=this)
				ref=(KifList*)a;

	list<KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=*it;
			ke->Resetreference();
			ke->shiftright(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=*it;
			ke->Resetreference();
			ke->shiftright(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (itmap==bref->values.end())
				break;
			ke=*it;
			ke->Resetreference();
			ke->shiftright(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}

	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=*it;
		ke->Resetreference();
		ke->shiftright(ke,b,true);
	}
	return ref;
}
KifElement* KifList::shiftleft(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::shiftleft");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifList* ref=this;
	if (autoself==false)
		ref=(KifList*)a->Copy(NULL);
		else
			if (a!=this)
				ref=(KifList*)a;

	list<KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=*it;
			ke->Resetreference();
			ke->shiftleft(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=*it;
			ke->Resetreference();
			ke->shiftleft(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (itmap==bref->values.end())
				break;
			ke=*it;
			ke->Resetreference();
			ke->shiftleft(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}

	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=*it;
		ke->Resetreference();
		ke->shiftleft(ke,b,true);
	}
	return ref;
}
KifElement* KifList::power(KifElement* a,KifElement* b,bool autoself) {
#ifdef PROFILING
	profilingcall("Vector::power");
#endif
	
	if (a->type!=kifVector)
		return kifNULL;
	
	KifList* ref=this;
	if (autoself==false)
		ref=(KifList*)a->Copy(NULL);
		else
			if (a!=this)
				ref=(KifList*)a;

	list<KifElement*>::iterator it;
	KifElement* ke;
	if (b->type==kifList) {
		KifList* bref=(KifList*)b;		
		list<KifElement*>::iterator itl;
		for (itl=bref->values.begin(),it=ref->values.begin();itl!=bref->values.end(),it!=ref->values.end();it++,itl++) {
			ke=*it;
			ke->Resetreference();
			ke->power(ke,*itl,true);
		}
		return ref;
	}

	if (b->type==kifVector) {
		KifVector* bref=(KifVector*)b;		
		int j=0;
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (j>=bref->values.size())
				break;
			ke=*it;
			ke->Resetreference();
			ke->power(ke,bref->values[j++],true);
		}
		return ref;
	}
	if (b->type==kifMap) {
		KifMap* bref=(KifMap*)b;		
		hmap<string,KifElement*>::iterator itmap=bref->values.begin();
		for (it=ref->values.begin();it!=ref->values.end();it++) {
			if (itmap==bref->values.end())
				break;
			ke=*it;
			ke->Resetreference();
			ke->power(ke,itmap->second,true);
			itmap++;
		}
		return ref;
	}
	for (it=ref->values.begin();it!=ref->values.end();it++) {
		ke=*it;
		ke->Resetreference();
		ke->power(ke,b,true);
	}
	return ref;
}
//-----------------------------------------------------------------------------------------------
Exported KifElement* KifInteger::divide(KifElement* a,KifElement* b,bool autoself) {
	long ib=b->Integer();
	if (ib==0)
		return kifcode->Returnerror(kifErrorStrings[225]);
	if (autoself) {
		value/=ib;
		return this;
	}
	long i=a->Integer()/ib;
	KifElement* kv= kifcode->Provideinteger(i);
	return kv;
}

Exported KifElement* KifInteger::power(KifElement* a,KifElement* b,bool autoself) {
	if (autoself) {
		value=pow((double)value,b->Float());
		return this;
	}
	double i=pow(a->Float(),b->Float());
	return kifcode->Provideinteger(i);
}

Exported KifElement* KifFraction::power(KifElement* a,KifElement* b,bool autoself) {
	double i=pow(a->Float(),b->Float());
	return kifcode->Provideinteger(i);
}

Exported KifElement* KifFloat::divide(KifElement* a,KifElement* b,bool autoself) {
	double ib=b->Float();
	if (ib==0)
		return kifcode->Returnerror(kifErrorStrings[225]);
	if (autoself) {
		value/=ib;
		update();
		return this;
	}
	double i=a->Float()/ib;
	KifElement* kv= kifcode->Providefloat(i);
	return kv;
}

Exported KifElement* KifFloat::power(KifElement* a,KifElement* b,bool autoself) {
	if (autoself) {
		value=pow(value , b->Float());
		update();
		return this;
	}
	double i=pow(a->Float(),b->Float());
	return kifcode->Providefloat(i);
}

//===================================================================
Exported void KifIteratorTree::Flatten(KifTree* t) {
	if (t==NULL)
		return;
	flat.push_back(t);
	Flatten(t->child);
	Flatten(t->next);
}

Exported KifElement* KifIteratorTree::IteratorKey() {
	return kifcode->Provideinteger(idx);
}

Exported KifElement* KifIteratorTree::IteratorValue() {
	return flat[idx];
}

Exported KifElement* KifIteratorTree::Next() {	
	if (reverse==false) {
		idx++;
		if (idx>=flat.size())
			return kifNULL;
	}
	else {
		idx--;
		if (idx<0)
			return kifNULL;
	}
	return flat[idx];
}

Exported KifElement* KifIteratorTree::End() {
	if (reverse==false) {
		if (idx>=flat.size())
			return kifTRUE;
	}
	else {
		if (idx<0)
			return kifTRUE;
	}

	return kifFALSE;
}
	
Exported KifElement* KifIteratorTree::Begin() {
	if (tree==NULL)
		return kifNULL;
	Flatten(tree);
	if (reverse==true)
		idx=flat.size()-1;
	else
		idx=0;
	return flat[idx];
}
//----------------------------------------------------------
KifElement* KifIteratorString::IteratorKey() {
	int i=itx;
	if (reverse==true)
		i=value.size()-itx-1;
	KifElement* ke=kifcode->Provideinteger(i);		
	return ke;
}

KifElement* KifIteratorString::IteratorValue() {
	if (itx==value.size())
		return kifNULL;
	int i=itx;
	string s=c_char_get(USTR(value),i,kifcode->utf8);
	return kifcode->Providestring(s);
}

KifElement* KifIteratorString::Next() {
	itx++;
	if (itx==value.size())
		return kifNULL;
	int i=itx;
	string s=c_char_get(USTR(value),i,kifcode->utf8);
	return kifcode->Providestring(s);
}

KifElement* KifIteratorString::End() {
	if (itx==value.size())
		return kifTRUE;
	return kifFALSE;
}

KifElement* KifIteratorString::Begin() {
	itx=0;
	if (itx==value.size())
		return kifNULL;

	if (reverse==true)
		value=c_char_reverse(value,kifcode->utf8);
	
	int i=itx;
	string s=c_char_get(USTR(value),i,kifcode->utf8);
	return kifcode->Providestring(s);
}

//===================================================================


KifElement* KifString::Newiterator(bool rev) {
#ifdef PROFILING
	profilingcall("String::Newiterator");
#endif
	KifIteratorString* iter=new KifIteratorString(kifcode,NULL);
	iter->reverse=rev;
	iter->value=value;
	return iter;
}

KifElement* KifList::Newiterator(bool rev) {
#ifdef PROFILING
	profilingcall("Vector::Newiterator");
#endif
	KifIteratorList* iter=new KifIteratorList(kifcode,NULL);
	iter->reverse=rev;
	iter->values=&values;
	return iter;
}

KifElement* KifVector::Newiterator(bool rev) {
#ifdef PROFILING
	profilingcall("Vector::Newiterator");
#endif
	KifIteratorVector* iter=new KifIteratorVector(kifcode,NULL);
	iter->reverse=rev;
	iter->values=&values;
	return iter;
}
KifElement* KifMap::Newiterator(bool rev) {
#ifdef PROFILING
	profilingcall("Map::Newiterator");
#endif
	KifIteratorMap* iter=new KifIteratorMap(kifcode,NULL);
	iter->reverse=rev;
	iter->values=&values;
	return iter;
}
//===================================================================
//===================================================================



Exported void KifDomain::Setdeclaration(string n,KifElement* ke,hmap<short,KifElement*>* stacks) {
	short id=KifNewId(n);
	Setdeclaration(id,ke,stacks);
}

//-------------------------------------Add--------------------------------------------------------

void KifFunction::Add(KifElement* ke) {
	if (choice==0)
		arguments.push_back(ke);
	else
		if (adding)
			instructions.push_back(ke);		
}



Exported KifType KifInstance::inType() {
	if (value!=NULL) {
		if (value->type==kifInstance || value->type==kifInstanceFunction)
			return value->inType();
		return value->type;
	}
	return type;
}

KifType KifCallFunctionPredefined::inType() {
	if (body!=NULL) {
		short nm=body->name;
		if (kifMathFunctions.find(nm)!=kifMathFunctions.end())
			return kifFloat;
		if (kifReturnString.find(nm)!=kifReturnString.end())
			return kifString;
		if (kifReturnInt.find(nm)!=kifReturnInt.end())
			return kifInteger;
		if (kifReturnFloat.find(nm)!=kifReturnFloat.end())
			return kifFloat;
	}

	return kifAny;
}

KifType KifInstanceFunction::inType() {
	if (function==NULL)
		return kifAny;
	return function->inType();
}


bool TestNumericalBloc(KifInstruction* kbloc,KifInstructionType& t,bool all) {	
	for (int i=0;i<kbloc->instructions.size();i++) {
		KifElement* k=kbloc->instructions[i];
		if (k->type==kifInstruction) {
			KifOperator op=k->Action();
			if (op<kifPLUS || op>kifINTERSECTION)
				if (op!=kifBLOC)
					return false;
			if (op==kifDIVIDEEQU || op==kifDIVIDE)
				if (t==kifNOTYPE || t==kifFULLINTEGER)
					t=kifFULLFLOAT;
				
			if (TestNumericalBloc((KifInstruction*)k,t,all)==false)
				return false;
		}
		else {
			switch(k->inType()) {
			case kifInteger:
				if (t==kifNOTYPE)
					t=kifFULLINTEGER;
				break;
			case kifFloat:
				if (t==kifNOTYPE)
					t=kifFULLFLOAT;
				break;
			case kifString:
				if (t==kifNOTYPE)
					t=kifFULLSTRING;
				break;
			case kifVector:
			case kifMap:
			case kifList:
				break;
			default:
				return false;
			}
			if (all==false)
				return true;
		}
	}
	return true;
}

KifNumber::~KifNumber() {
	if (child!=NULL)
		delete child;
}

KifValue* KifCreateInteger(KifNumber* knumber,KifElement* ke,KifInstructionType instype) {
	KifValue* kval;
	if (instype==kifFULLSTRING) {
		kval=new KifStringValue(IntegerString(ke->Integer()));
		knumber->type=ckifString;
	}
	else
		if (instype==kifFULLFLOAT) {			
			kval=new KifFloatValue(ke->Float());
			knumber->type=ckifFloat;
		}
		else {
			kval=new KifIntegerValue(ke->Integer());
			knumber->type=ckifInteger;
		}
	return kval;
}

KifValue* KifCreateFloat(KifNumber* knumber,KifElement* ke,KifInstructionType instype) {
	KifValue* kval;
	if (instype==kifFULLSTRING) {
		kval=new KifStringValue(IntegerString(ke->Float()));
		knumber->type=ckifString;
	}
	else
		if (instype==kifFULLFLOAT) {
			kval=new KifFloatValue(ke->Float());
			knumber->type=ckifFloat;
		}
		else {
			kval=new KifIntegerValue(ke->Integer());
			knumber->type=ckifInteger;
		}
	return kval;
}

KifValue* KifCreateString(KifNumber* knumber,KifElement* ke,KifInstructionType instype) {
	KifValue* kval;
	if (instype==kifFULLSTRING) {
		kval=new KifStringValue(ke->String());
		knumber->type=ckifString;
	}
	else
		if (instype==kifFULLFLOAT) {
			kval=new KifFloatValue(atof(STR(ke->String())));
			knumber->type=ckifFloat;
		}
		else {
			kval=new KifIntegerValue(atoi(STR(ke->String())));
			knumber->type=ckifInteger;
		}
	return kval;
}

KifChild* KifInstruction::BuildNumericalExpression(char first) {
	KifInstructionType instype=kifNOTYPE;
	if (first==0) {
		if (action==kifINITIALISATION)
			instype=instructiontype;

		if (TestNumericalBloc(this,instype,true)==false)
			return NULL;

		if (action>=kifAFFECTATION && action<=kifINTERSECTIONEQU) {
			if (instructions[1]->type==kifInstruction) {
				KifInstruction* kinst=(KifInstruction*)instructions[1];
				kinst->instructiontype=instype;
				if (action!=kifAFFECTATION)
					instructiontype=kifEQU;
				return kinst->BuildNumericalExpression(1);
			}
			return NULL;
		}
		else
			if (action==kifINITIALISATION) {				
				if (instructions[0]->type==kifInstruction) {
					KifInstruction* kinst=(KifInstruction*)instructions[0];
					kinst->instructiontype=instype;
					return kinst->BuildNumericalExpression(1);
				}
				return NULL;
			}
			else
				instructiontype=instype;
	}

	KifChild* kchild=new KifChild(instructiontype);
	if (first!=2) {
		root=new KifRoot(kifcode,instructiontype);
		root->child=kchild;
	}
	//instructiontype defines if we are dealing with a string, integer or float expressions
	instype=root->instructiontype;
	
	KifValue* kvalue;
	kchild->op=action;
	string sx;
	for (int i=0;i<instructions.size();i++) {
		KifElement* ke=instructions[i];		
		KifType localtype=ke->type;
		KifNumber* knumber=new KifNumber();
		kvalue=NULL;

		switch (localtype) {
		case kifInstruction:
			if (action==kifBLOC && first!=0) {
				root->instructiontype=kifNOTYPE;
				TestNumericalBloc((KifInstruction*)ke,root->instructiontype,false);
			}
			kchild->instructiontype=root->instructiontype;
			((KifInstruction*)ke)->root=root;
			knumber->type=ckifInstruction;
			knumber->Append(ke->BuildNumericalExpression(2));
			((KifInstruction*)ke)->root=NULL;
			root->instructiontype=instype;
			break;
		case kifInteger:			
			kvalue=KifCreateInteger(knumber,ke,root->instructiontype);
			break;
		case kifFloat:
			kvalue=kvalue=KifCreateFloat(knumber,ke,root->instructiontype);
			break;
		case kifString:
			kvalue=kvalue=KifCreateString(knumber,ke,root->instructiontype);
			break;
		default:	
			//We isolate variables, which will be compute out of the main algo
			//Thus, if a variable is used more than once in the expression, we will
			//extract its value only once...
			sx=ke->Keyvalue();			
			short idsx;
			if (sx!="") {
				idsx=KifNewId(sx);
				if (root->declarations.find(idsx)==root->declarations.end()) {
					kvalue=new KifComputeValue(ke,root->instructiontype);
					root->declarations[idsx]=(KifComputeValue*)kvalue;
				}
				else {
					kvalue=root->declarations[idsx];
					if (((KifComputeValue*)kvalue)->instructiontype!=root->instructiontype) {
						sx+="*";
						bool createnew=true;
						idsx=KifNewId(sx);
						while (root->declarations.find(idsx)!=root->declarations.end()) {
							kvalue=root->declarations[idsx];
							if (((KifComputeValue*)kvalue)->instructiontype==root->instructiontype) {
								createnew=false;
								break;
							}
							sx+="*";
							idsx=KifNewId(sx);
						}
						if (createnew==true) {
							kvalue=new KifComputeValue(ke,root->instructiontype);
							root->declarations[idsx]=(KifComputeValue*)kvalue;
						}
					}
				}
			}
			else {
				sx="*";
				idsx=KifNewId(sx);
				while (root->declarations.find(idsx)!=root->declarations.end()) {
					sx+="*";
					idsx=KifNewId(sx);
				}
				kvalue=new KifComputeValue(ke,root->instructiontype);
				root->declarations[idsx]=(KifComputeValue*)kvalue;
			}
			kvalue=((KifComputeValue*)kvalue)->value;
			knumber->type=kvalue->type;
		}
		knumber->value=kvalue;
		kchild->Append(knumber);
	}
	return kchild;
}

void KifInstruction::Addparent(KifElement* p) {
	parent=p;
}

void KifObjectInstruction::Addinstruction(int i,KifElement* ke) {
	if (i<instructions.size())
		instructions[i]=ke;		
	else
		instructions.push_back(ke);		
}

void KifObjectInstruction::Add(KifElement* ke) {		
	if (adding)
		instructions.push_back(ke);
}


void KifCallFunction::Add(KifElement* ke) {
#ifdef PROFILING
	profilingcall("CallFunction::Add");
#endif
	if (add==1)
		parameters.push_back(ke);
	else
		if (add==2)
			function=(KifCallFunction*)ke;
}

//-------------------------------------Add--------------------------------------------------------

Exported void KifInstruction::Set(short op,KifElement* kf,hmap<short,KifElement*>* stacks) {
#ifdef PROFILING
	profilingcall("Instruction::Set");
#endif
	ThreadLock _lock(type);
	action=(KifOperator)op;
}

void KifDomain::Sharedeclaration(KifDomain* k) {
#ifdef PROFILING
	profilingcall("Domain::Sharedeclaration");
#endif
	hmap<short,KifElement*>::iterator it;
	short n;
	for (it=declarations.begin();it!=declarations.end();it++) {
		n=it->first;
		k->declarations[n]=it->second;
	}
}


Exported void KifFrame::Set(short s,KifElement* k,hmap<short,KifElement*>* stacks) {
#ifdef PROFILING
	profilingcall("Frame::Set");
#endif
	ThreadLock _lock(type);	
	Setdeclaration(s,k,stacks);
}

Exported void KifFrame::Setstring(string sx,KifElement* k,hmap<short,KifElement*>* stacks) {
#ifdef PROFILING
	profilingcall("Frame::Set");
#endif
	ThreadLock _lock(type);	
	short s=KifNewId(sx);
	Setdeclaration(s,k,stacks);
}


short KifFrame::Newfield(string n,KifElement* val) {
#ifdef PROFILING
	profilingcall("Frame::Newfield");
#endif
	ThreadLock _lock(type);
	short name=KifNewId(n);
	KifFrameDeclaration* var=new KifFrameDeclaration(kifcode,this,name,this);
	var->Add(val);
	Set(name,var,NULL);
	return name;
}


void KifCallFunction::SetParameters(vector<KifElement*>& vect,hmap<short,KifElement*>* stacks) {
#ifdef PROFILING
	profilingcall("CallFunction::SetParameters");
#endif
	ThreadLock _lock(type);
	int it;
	for (it=0;it<vect.size();it++) {
		KifElement* ke=vect[it];
		short thename=ke->Name();
		if (ke->type==kifInstance)
			Setdeclaration(thename,((KifInstance*)ke)->value,stacks);
		else
			Setdeclaration(thename,ke,stacks);
		parameters.push_back(ke);
	}
}


void KifMatrix::Addvalue(string& c,string& a,KifElement* v,long line) {
#ifdef PROFILING
	profilingcall("Matrix::Addvalue");
#endif
	ThreadLock _lock(type);
	int nb=values.size();
	if (nb<=line) {
		for (int i=nb;i<=line;i++) {
			map<string, map<string,KifElement*> > v;
			values.push_back(v);
			values[i][c][a]=kifNULL;
		}
	}
	
	if (attributes.find(a)==attributes.end()) {
		if (v->type==kifString)
			attributes[a]=true;
		else
			attributes[a]=false;
	}

	classes[c]=true;
	KifElement* ke=values[line][c][a];
	if (ke!=kifNULL && ke!=NULL)
		values[line][c][a]->Resetreference();
	else
		nbelements++;
	v->Setreference();
	values[line][c][a]=v;
}


Exported bool KifDate::Setvalue(KifElement* ke,KifElement* index,KifElement* dom) {
	long x=ke->Integer();
	if (x<=0)
		return false;
	value=x;
	return true;
}

Exported bool KifTime::Setvalue(KifElement* ke,KifElement* index,KifElement* dom) {	
	if (ke->type!=kifTime)
		return false;
	value=((KifTime*)ke)->value;
	return true;
}

Exported bool KifInteger::Setvalue(KifElement* ke,KifElement* index,KifElement* dom) {	
	value=ke->Integer();
	return true;
}

Exported bool KifFloat::Setvalue(KifElement* ke,KifElement* index,KifElement* dom) {	
	value=ke->Float();
	return true;
}

Exported bool KifBoolean::Setvalue(KifElement* ke,KifElement* index,KifElement* dom) {	
	value=ke->Boolean();
	return true;
}

Exported bool KifIterator::Setvalue(KifElement* k,KifElement* idx,KifElement* dom) {
	ThreadLock _lock(type);
	if (value!=NULL && value->type==kifIteration)
		value->Resetreference();
	value=k->Newiterator(reverse);
	value->Setreference();
	return true;
}

Exported bool KifIterator::Putvalue(KifElement* k) {
	ThreadLock _lock(type);
	if (value!=NULL && value->type==kifIteration)
		value->Resetreference();
	value=k->Newiterator(reverse);
	value->Setreference();
	return true;
}

Exported bool KifTree::Setvalue(KifElement* k,KifElement* index,KifElement* dom) {
	ThreadLock _lock(type);
	if (value!=kifNULL)
		value->Resetreference();
	if (k->type==kifTree) 
		value=k->TreeValue()->Atom();
	else 
		value=k;
	value->Setreference();
	return true;
}

bool KifMatrix::Setvalue(KifElement* ke,KifElement* index,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Matrix::Setvalue");
#endif
	ThreadLock _lock(type);
	if (ke->type!=kifMatrix)
		return true;

	vector<map<string,map<string,KifElement*> > >::iterator itins;
	map<string,map<string,KifElement*> >::iterator itclass;
	map<string, KifElement*>::iterator itatt;
	long i=0;
	for (itins=values.begin();itins!=values.end();itins++) {
		for (itclass=(*itins).begin();itclass!=(*itins).end();itclass++) {
			string c=itclass->first;
			for (itatt=itclass->second.begin();itatt!=itclass->second.end();itatt++) {
				string a=itatt->first;
				Addvalue(c,a,itatt->second,i);
			}
		}
		i++;
	}
	return true;
}

Exported KifElement* KifSelf::Copy(KifDomain* kp,KifElement* dom) {
	ThreadLock _lock(type);
	return new KifSelf(kifcode,kp,kifNULL);
}

bool KifSelf::Setvalue(KifElement* ke,KifElement* index,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Self::Setvalue");
#endif
	ThreadLock _lock(type);
	value=ke;
	return true;
}
bool KifVariable::Setvalue(KifElement* k,KifElement* idx,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Variable::Setvalue");
#endif	
	ThreadLock _lock(type);
	callfunction(value,k,(KifDomain*)dom);
	
	if (value->type==kifDomain && k->type==kifFrame) {
		//In the case of a postpone variable, then this new affectation replaces any
		//delayed initialisation...
		if (value->reference>1)			
			//Simpler case, value and k have the same type
			value->Resetreference();
		
			//Then we have either a new instance, if k is a kifFrame
		//we need to check if we can use it...
		KifDomain* vdom=(KifDomain*)value;
		//If the value is postponed, it means that it has been created within a frame
		//which is waiting for its initialisation to take place...
		//In that case, we do not create a new object...
		if (!value->Postpone() && vdom->frame==k) {
			value=k->Copy(NULL,k);
			value->Setframe(k);
			value->reference++;
		}
		return false;
	}

	if (value->reference>1) {		
		
		//Simpler case, value and k have the same type
		value->Resetreference();
		if (k->type==value->type && value->type!=kifDomain) {
			if (value->type==kifVector || value->type==kifMap) {
				value=k->Copy(NULL);
				value->reference++;
				return true;
			}

			k->Setreference();
			value=k;
			return true;
		}

		//In the other cases, we create a new instance and we set our value with k
		value=value->Newinstance();
		value->Setreference();
		value->Setvalue(k,idx,dom);
	}
	else
		value->Setvalue(k,idx,dom);
	return true;
}

bool KifVariableDeclaration::Setvalue(KifElement* k,KifElement* idx,KifElement* dom) {
#ifdef PROFILING
	profilingcall("VariableDeclaration::Setvalue");
#endif
	ThreadLock _lock(type);
	if (value->reference>1) {		
		
		//Simpler case, value and k have the same type
		value->Resetreference();
		if (k->type==value->type && value->type!=kifDomain) {
			k->Setreference();
			value=k;
			return true;
		}

		if (value->type==kifDomain && k->type==kifFrame) {
			//Then we have either a new instance, if k is a kifFrame
			//we need to check if we can use it...
			KifDomain* vdom=(KifDomain*)value;
			if (vdom->frame==k) {
				value=k->Copy(NULL,k);
				value->Setframe(k);
				value->reference++;
			}
			return false;
		}
		//In the other cases, we create a new instance and we set our value with k
		value=value->Newinstance();
		value->Setreference();
		value->Setvalue(k,idx,dom);
	}
	else
		value->Setvalue(k,idx,dom);
	return true;
}


bool KifCouple::Setvalue(KifElement* k,KifElement* idx,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Couple::Setvalue");
#endif
	ThreadLock _lock(type);
	//We simply replace, the current element with k
	if (indexes->interval==true)
		return true;

	KifElement* kres=recipient;
	KifElement* key=indexes->key->Execute(kifNULL,domain);
	//Specific case, where the function is also an index reference...
	if (indexes->function!=NULL && indexes->function->type==kifIndex) {
		KifIndex* kidx=(KifIndex*)indexes->function;
		while (kidx!=NULL) {
			//In this case, what we try to do is first to get the element with this index
			kres=kres->Execute(kifNULL,domain,indexes,false);					
			if (kidx->function!=NULL && kidx->function->type==kifIndex) {
				indexes=kidx;
				kidx=(KifIndex*)kidx->function;
			}
			else
				break;
		}

		key=kidx->key->Execute(kifNULL,domain);
		kres->Setvalue(k,key,dom);
	}
	else
		recipient->Setvalue(k,key,dom);
	return true;
}


//In this case, we use the VALUE as the type
string KifCouple::Type() {
	ThreadLock _lock(type);
	if (indexes->interval==true)
		return "";

	KifElement* key=indexes->key->Execute(kifNULL,domain);
	KifElement* value=recipient->Execute(this,domain,key,false);
	return value->Type();
}

bool KifVector::Setvalue(KifElement* ke,KifElement* idx,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Vector::Setvalue");
#endif
	ThreadLock _lock(type);
	if (ke==this)
		return true;

	int nb;

	if (idx==NULL || idx==kifNULL) {
		if (ke->type==kifList) {
			KifList* kvect=(KifList*)ke;
			//We copy all values from ke to this
			Clear();
			list<KifElement*>::iterator it;
			for (it=kvect->values.begin();it!=kvect->values.end();it++)
				Push(*it);
		}
		else {
			if (ke->type==kifVector) {
				KifVector* kvect=(KifVector*)ke;
				//We copy all values from ke to this
				Clear();
				for (int it=0;it<kvect->values.size();it++)
					Push(kvect->values[it]);
			}
			else {
				//We gather all the keys from the MAP
				if (ke->type==kifMap) {
					hmap<string,KifElement*>::iterator itmap;
					KifMap* kmap=(KifMap*)ke;
					Clear();
					KifBaseString localstring(NULL,NULL);
					localstring.kifcode=kifcode;
					for (itmap=kmap->values.begin();itmap!=kmap->values.end();itmap++) {
						localstring.value=itmap->first;
						Push(&localstring);
					}
				}
				else {
					Clear();
					if (ke!=kifNULL) {
						ke=ke->Vector(dom);
						if (ke==kifNULL) {
							kifcode->Returnerror(kifErrorStrings[206]);
							return true;
						}
						KifVector* kvect=(KifVector*)ke;
						//We copy all values from ke to this
						for (int it=0;it<kvect->values.size();it++)
							Push(kvect->values[it]);
					}
				}
			}
		}
		return true;
	}

	int ikey=idx->Integer();

	if (ikey>=values.size())
		Push(ke);
	else {
		nb=reference;
		ke=ke->Atom();
		if (values[ikey]!=NULL) {			
			while (nb>=0) {
				values[ikey]->Resetreference();
				ke->Setreference();
				nb--;
			}
		}
		else {
			while (nb>=0) {
				ke->Setreference();
				nb--;
			}			
		}
		values[ikey]=ke;
	}

	return true;
}

bool KifList::Setvalue(KifElement* ke,KifElement* idx,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Vector::Setvalue");
#endif
	ThreadLock _lock(type);
	if (ke==this)
		return true;

	if (ke->type==kifList) {
		KifList* kvect=(KifList*)ke;
		//We copy all values from ke to this
		Clear();
		list<KifElement*>::iterator it;
		for (it=kvect->values.begin();it!=kvect->values.end();it++)
			Push(*it);
	}
	else {
		if (ke->type==kifVector) {
			KifVector* kvect=(KifVector*)ke;
			//We copy all values from ke to this
			Clear();
			for (int it=0;it<kvect->values.size();it++)
				Push(kvect->values[it]);
		}
		else {
			//We gather all the keys from the MAP
			if (ke->type==kifMap) {
				hmap<string,KifElement*>::iterator itmap;
				KifMap* kmap=(KifMap*)ke;
				Clear();
				KifBaseString localstring(NULL,NULL);
				localstring.kifcode=kifcode;

				for (itmap=kmap->values.begin();itmap!=kmap->values.end();itmap++) {
					localstring.value=itmap->first;
					Push(&localstring);
				}
			}
			else {
				Clear();
				if (ke!=kifNULL) {
					ke=ke->Vector(dom);
					if (ke==kifNULL) {
						kifcode->Returnerror(kifErrorStrings[220]);
						return true;
					}
					KifVector* kvect=(KifVector*)ke;
					//We copy all values from ke to this
					for (int it=0;it<kvect->values.size();it++)
						Push(kvect->values[it]);
				}
			}
		}
	}
	return true;
}


bool KifMap::Setvalue(KifElement* ke,KifElement* idx,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Map::Setvalue");
#endif
	ThreadLock _lock(type);
	if (ke==this)
		return true;

	int nb;
	if (idx==NULL || idx==kifNULL) {
		if (ke->type==kifMap) {
			KifMap* kvect=(KifMap*)ke;
			//We copy all values from ke to this
			Clear();
			hmap<string,KifElement*>::iterator it;
			for (it=kvect->values.begin();it!=kvect->values.end();it++) {
				string n=it->first;
				Push(n,it->second);
			}
		}
		else {
			if (ke->type==kifVector) {
				KifVector* kvect=(KifVector*)ke;
				Clear();
				nb=0;
				for (int it=0;it<kvect->values.size();it++) {
					sprintf_s(kifcode->buffer,100,"%d",nb);
					Push(kifcode->buffer,kvect->values[it]);
					nb++;
				}
			}
			else {
				if (ke->type==kifList) {
					KifList* kvect=(KifList*)ke;
					list<KifElement*>::iterator it;
					Clear();
					nb=0;
					for (it=kvect->values.begin();it!=kvect->values.end();it++) {
						sprintf_s(kifcode->buffer,100,"%d",nb);
						Push(kifcode->buffer,*it);
						nb++;
					}
				}
				else {
					Clear();
					if (ke!=kifNULL) {
						ke=ke->Map(dom);
						if (ke==kifNULL) {
							kifcode->Returnerror(kifErrorStrings[207]);
							return false;
						}
						KifMap* kvect=(KifMap*)ke;
						//We copy all values from ke to this
						hmap<string,KifElement*>::iterator it;
						for (it=kvect->values.begin();it!=kvect->values.end();it++) {
							string n=it->first;
							Push(n,it->second);
						}
					}
				}
			}
		}
	}
	else
		Push(STR(idx->String()),ke);
	return true;
}

bool KifString::Setvalue(KifElement* ke,KifElement* idx,KifElement* dom) {
#ifdef PROFILING
	profilingcall("String::Setvalue");
#endif
	if (ke==this)
		return true;
	bool ret=true;
	if (idx==NULL || idx==kifNULL)
		value=ke->String();
	else {
		int ikey=idx->Integer();
		string s=ke->String();
		ret=c_char_index_assign(value,s,ikey,kifcode->utf8);
	}
	update();
	return ret;
}

KifElement* KifString::Map(KifElement* dom) {
	ThreadLock _lock(type);
	string smap=value;
	kifcode->Push((KifDomain*)dom);
	KifElement* ke=kifcode->EvaluateMap(dom,smap);
	kifcode->Pop();
	if (ke->type!=kifMap)
		return kifNULL;
	ke=ke->Execute(kifNULL,(KifDomain*)dom);
	return ke;
}


KifElement* KifString::Vector(KifElement* dom) {
	ThreadLock _lock(type);	
	string svect=value;
	kifcode->Push((KifDomain*)dom);
	KifElement* ke=kifcode->EvaluateVector(dom,svect);
	kifcode->Pop();
	if (ke->type!=kifVector)
		return kifNULL;
	ke=ke->Execute(kifNULL,(KifDomain*)dom);
	return ke;
}

KifElement* KifVector::Map(KifElement* dom) {
	ThreadLock _lock(type);
	KifMap* kmap=kifcode->Providemap();
	int nb=0;
	for (int it=0;it<values.size();it++) {
		sprintf_s(kifcode->buffer,100,"%d",nb);
		kmap->Push(kifcode->buffer,values[it]);
		nb++;
	}
	return kmap;
}

KifElement* KifList::Map(KifElement* dom) {
	ThreadLock _lock(type);
	KifMap* kmap=kifcode->Providemap();
	list<KifElement*>::iterator it;
	int nb=0;
	for (it=values.begin();it!=values.end();it++) {
		sprintf_s(kifcode->buffer,100,"%d",nb);
		kmap->Push(kifcode->buffer,*it);
		nb++;
	}
	return kmap;
}

KifElement* KifList::Vector(KifElement* dom) {
	ThreadLock _lock(type);

	KifVector* kvect=kifcode->Providevector();
	//We copy all values from ke to this
	Clear();
	list<KifElement*>::iterator it;
	for (it=values.begin();it!=values.end();it++) {
		kvect->Push(*it);
	}
	return kvect;
}

KifElement* KifMap::Vector(KifElement* dom) {
	ThreadLock _lock(type);

	KifVector* kvect=kifcode->Providevector();
	//We copy all values from ke to this
	Clear();
	hmap<string,KifElement*>::iterator it;
	for (it=values.begin();it!=values.end();it++) {
		KifElement* x=it->second;
		kvect->Push(x);
	}
	return kvect;
}


//===================================================================
KifElement* KifElement::Kifpredefined(short n) {
#ifdef PROFILING
	profilingcall("Element::Kifpredefined");
#endif
	if (TestkifFunctions(n,kifPredefinedFunctions)==true)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}

KifElement* KifElement::Kifpredefined(string n) {
#ifdef PROFILING
	profilingcall("Element::Kifpredefined");
#endif
	short id=KifNewId(n);
	if (TestkifFunctions(id,kifPredefinedFunctions)==true)
		return kifcode->kifBaseFunctions[id];
	return NULL;
}

KifElement* KifSelf::Declaration(short n) {
#ifdef PROFILING
	profilingcall("Self::Declaration");
#endif
	KifElement* kret=kifcode->KifBaseFunctionTest(n);
	if (kret!=NULL)
		return kret;
	if (kifcode->KifDeclaredFunctionTest(n)==true)
		return kifTRUE;
	
	string message="a 'self' object can only call functions: "+n;			
	throw new KifRaiseError(message,kifcode->current->name,kifcode->current_start,kifcode->current_end);
	return NULL;
}

KifElement* KifIndex::Declaration(short n) {
#ifdef PROFILING
	profilingcall("Self::Declaration");
#endif
	if (kifcode->KifBaseFunctionTest(n))
		return kifcode->kifBaseFunctions[n];
	if (kifcode->KifDeclaredFunctionTest(n)==true)
		return kifTRUE;
	
	string message="Only functions can be called from an index: "+n;			
	throw new KifRaiseError(message,kifcode->current->name,kifcode->current_start,kifcode->current_end);
	return NULL;
}



KifElement* KifDomain::Declaration(short s) {
	if (s==idthis)
		return this;

	ThreadLock _lock(type);
	if (s==idmethods)
		return kifcode->kifBaseFunctions[s];

	if (declarations.find(s)==declarations.end())
		return NULL;
	return declarations[s];
}


KifElement* KifDomain::Declared(short s) {
	if (s==idthis)
		return this;
	
	ThreadLock _lock(type);
	if (s==idmethods)
		return kifcode->kifBaseFunctions[s];
	
	if (declarations.find(s)==declarations.end())
		return NULL;
	return declarations[s];
}



KifElement* KifMatrix::Declaration(short n) {
#ifdef PROFILING
	profilingcall("Matrix::Declaration");
#endif
	if (TestkifFunctions(n,kifMatrixFunctions)==true)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}

KifElement* KifCallFunctionPredefined::Declaration(short n) {
#ifdef PROFILING
	profilingcall("CallFunction::Declaration");
#endif
	if (kifcode->KifBaseFunctionTest(n))
		return kifcode->kifBaseFunctions[n];
	if (kifcode->KifDeclaredFunctionTest(n)==true)
		return kifTRUE;
	return NULL;
}

KifElement* KifCallFunction::Declaration(short s) {
	hmap<short,KifElement*>::iterator iter=declarations.find(s);
	if (iter==declarations.end())
		return NULL;
	return iter->second;
}

KifElement* KifTree::Declaration(short n) {
#ifdef PROFILING
	profilingcall("String::Declaration");
#endif
	if (TestkifFunctions(n,kifTreeFunctions)==true)
		return kifcode->kifBaseTreeFunctions[n];
	return NULL;
}



KifElement* KifString::Declaration(short n) {
#ifdef PROFILING
	profilingcall("String::Declaration");
#endif
	if (TestkifFunctions(n,kifStringFunctions)==true)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}

KifElement* KifFloat::Declaration(short n) {
#ifdef PROFILING
	profilingcall("Float::Declaration");
#endif
	if (kifMathFunctions.find(n)!=kifMathFunctions.end() || TestkifFunctions(n,kifNumericalFunctions)==true || n==idget)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}


KifElement* KifInteger::Declaration(short n) {
#ifdef PROFILING
	profilingcall("Integer::Declaration");
#endif
	if (kifMathFunctions.find(n)!=kifMathFunctions.end() || TestkifFunctions(n,kifNumericalFunctions)==true  || n==idget)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}

KifElement* KifFraction::Declaration(short n) {
#ifdef PROFILING
	profilingcall("Integer::Declaration");
#endif
	if (kifMathFunctions.find(n)!=kifMathFunctions.end() || TestkifFunctions(n,kifNumericalFunctions)==true  || n==idget)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}

KifElement* KifDate::Declaration(short n) {
#ifdef PROFILING
	profilingcall("Time::Declaration");
#endif
	if (TestkifFunctions(n,kifDateFunctions)==true)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}

KifElement* KifTime::Declaration(short n) {
#ifdef PROFILING
	profilingcall("Time::Declaration");
#endif
	if (TestkifFunctions(n,kifTimeFunctions)==true)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}


KifElement* KifKiF::Declaration(short n) {
#ifdef PROFILING
	profilingcall("KiF::Declaration");
#endif
	if (TestkifFunctions(n,kifKiFFunctions)==true)
		return kifcode->kifBaseFunctions[n];
	if (id!=-1) {
		KifCode* kifcode=kifCodeVector[id];
		if (kifcode!=NULL) {
			KifElement* res=kifcode->kstart->Declaration(n);
			if (res==NULL || res->Private())
				return NULL;
			return res;
		}
	}
	else
		return kifTRUE;
	return NULL;
}

KifElement* KifList::Declaration(short n) {
#ifdef PROFILING
	profilingcall("Vector::Declaration");
#endif
	if (TestkifFunctions(n,kifListFunctions)==true)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}

KifElement* KifVector::Declaration(short n) {
#ifdef PROFILING
	profilingcall("Vector::Declaration");
#endif
	if (TestkifFunctions(n,kifVectorFunctions)==true)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}

KifElement* KifMap::Declaration(short n) {
#ifdef PROFILING
	profilingcall("Map::Declaration");
#endif
	if (TestkifFunctions(n,kifMapFunctions)==true)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}

KifElement* KifFile::Declaration(short n) {
#ifdef PROFILING
	profilingcall("File::Declaration");
#endif	
	if (TestkifFunctions(n,kifFileFunctions)==true)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}

KifElement* KifIterator::Declaration(short n) {
#ifdef PROFILING
	profilingcall("Iterator::Declaration");
#endif
	if (TestkifFunctions(n,kifIteratorFunctions)==true)
		return kifcode->kifBaseFunctions[n];
	return NULL;
}

//===================================================================
Exported KifElement* KifString::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsString.find(s)==kifInformationsString.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsString[s]);
}

Exported KifElement* KifInteger::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsInt.find(s)==kifInformationsInt.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsInt[s]);
}

Exported KifElement* KifFraction::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsInt.find(s)==kifInformationsInt.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsInt[s]);
}

Exported KifElement* KifFloat::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsFloat.find(s)==kifInformationsFloat.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsFloat[s]);
}

Exported KifElement* KifVector::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsVector.find(s)==kifInformationsVector.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsVector[s]);
}

Exported KifElement* KifList::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsList.find(s)==kifInformationsList.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsList[s]);
}

Exported KifElement* KifMap::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsMap.find(s)==kifInformationsMap.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsMap[s]);
}

Exported KifElement* KifTree::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsTree.find(s)==kifInformationsTree.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsTree[s]);
}

Exported KifElement* KifMatrix::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsMatrix.find(s)==kifInformationsMatrix.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsMatrix[s]);
}

Exported KifElement* KifIterator::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsIterator.find(s)==kifInformationsIterator.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsIterator[s]);
}


Exported KifElement* KifDate::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsDate.find(s)==kifInformationsDate.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsDate[s]);
}

Exported KifElement* KifTime::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsTime.find(s)==kifInformationsTime.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsTime[s]);
}

Exported KifElement* KifFile::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsFile.find(s)==kifInformationsFile.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsFile[s]);
}


Exported KifElement* KifKiF::Information(KifElement* kstr) {
	string s=kstr->String();
	if (kifInformationsKif.find(s)==kifInformationsKif.end())
		return kifNULL;
	return kifcode->Providestring(kifInformationsKif[s]);
}

//===================================================================

void KifMatrix::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("Matrix::List");
#endif
	hmap<short,bool>::iterator it;
	for (it=kifMatrixFunctions.begin();it!=kifMatrixFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));		
}

void KifTree::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("String::List");
#endif
	hmap<short,bool>::iterator it;
	for (it=kifTreeFunctions.begin();it!=kifTreeFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));		
}


void KifString::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("String::List");
#endif
	hmap<short,bool>::iterator it;
	for (it=kifStringFunctions.begin();it!=kifStringFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));		
}

void KifFloat::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("Float::List");
#endif
	hmap<short,mathFunc>::iterator itx;
	for (itx=kifMathFunctions.begin();itx!=kifMathFunctions.end();itx++)
		fcts->Push(kifcode->Providestring((*kifIdString)[itx->first]));		
	hmap<short,bool>::iterator it;
	for (it=kifNumericalFunctions.begin();it!=kifNumericalFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));		
}


void KifInteger::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("Integer::List");
#endif
	hmap<short,mathFunc>::iterator itx;
	for (itx=kifMathFunctions.begin();itx!=kifMathFunctions.end();itx++)
		fcts->Push(kifcode->Providestring((*kifIdString)[itx->first]));		
	hmap<short,bool>::iterator it;
	for (it=kifNumericalFunctions.begin();it!=kifNumericalFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));		
}


void KifFraction::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("Integer::List");
#endif
	hmap<short,mathFunc>::iterator itx;
	for (itx=kifMathFunctions.begin();itx!=kifMathFunctions.end();itx++)
		fcts->Push(kifcode->Providestring((*kifIdString)[itx->first]));		
	hmap<short,bool>::iterator it;
	for (it=kifNumericalFunctions.begin();it!=kifNumericalFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));		
}

void KifDate::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("Time::List");
#endif
	hmap<short,bool>::iterator it;
	for (it=kifDateFunctions.begin();it!=kifDateFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));		
}


void KifTime::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("Time::List");
#endif
	hmap<short,bool>::iterator it;
	for (it=kifTimeFunctions.begin();it!=kifTimeFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));		
}

Exported void KifKiF::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("Time::List");
#endif
	hmap<short,bool>::iterator it;
	for (it=kifKiFFunctions.begin();it!=kifKiFFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));		
}


void KifVector::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("Vector::List");
#endif
	hmap<short,bool>::iterator it;
	for (it=kifVectorFunctions.begin();it!=kifVectorFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));		
}

void KifList::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("Vector::List");
#endif
	hmap<short,bool>::iterator it;
	for (it=kifListFunctions.begin();it!=kifListFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));
}


void KifMap::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("Map::List");
#endif
	hmap<short,bool>::iterator it;
	for (it=kifMapFunctions.begin();it!=kifMapFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));
}

void KifFile::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("File::List");
#endif	
	hmap<short,bool>::iterator it;
	for (it=kifFileFunctions.begin();it!=kifFileFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));
}

void KifIterator::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("Iterator::List");
#endif
	hmap<short,bool>::iterator it;
	for (it=kifIteratorFunctions.begin();it!=kifIteratorFunctions.end();it++)
		fcts->Push(kifcode->Providestring((*kifIdString)[it->first]));
}

void KifDomain::Methods(KifVector* fcts) {
#ifdef PROFILING
	profilingcall("Domain::List");
#endif
	hmap<short,KifElement*>::iterator iter;
	for (iter=declarations.begin();iter!=declarations.end();iter++) {
		fcts->Push(kifcode->Providestring((*kifIdString)[iter->first]));
	}
	fcts->Push(kifcode->Providestringraw("methods"));
	fcts->Push(kifcode->Providestringraw("vector"));
	fcts->Push(kifcode->Providestringraw("map"));
}

//===================================================================
KifElement* KifCallFunction::applyfunction(KifElement* a) {
#ifdef PROFILING
	profilingcall("CallFunction::applyfunction");
#endif
	a->reference++;
	KifElement* ret;
	if (a->type==kifDomain)
		ret=function->Execute(kifNULL,(KifDomain*)a,a,false);
	else
		ret=function->Execute(kifNULL,this,a,false);
	a->reference--;
	return ret;
}

KifElement* KifElement::applyfunc(KifElement* a,KifElement* b,KifDomain* func) {
#ifdef PROFILING
	profilingcall("Element::applyfunc");
#endif
	if (func==NULL)
		return kifcode->Returnerror(kifErrorStrings[232]);

	short name=func->Name();
	if (func->Size()!=2) {
		string message=kifErrorStrings[195];
		message+=(*kifIdString)[name];
		return kifcode->Returnerror(message);
	}
	KifCallFunctionGeneral kfunc(NULL,this,name,(KifFunction*)func);
	kfunc.kifcode=kifcode;
	kfunc.parameters.push_back(a);
	kfunc.parameters.push_back(b);
	a->reference++;
	b->reference++;
	KifElement* ret=kfunc.Execute(kifNULL,func);
	a->reference--;
	b->reference--;
	return ret;
}

KifElement* KifElement::applyfuncvariable(KifVariable* var,KifElement* a,KifElement* b,KifDomain* func) {
#ifdef PROFILING
	profilingcall("Element::applyfunc");
#endif
	if (func==NULL)
		return kifcode->Returnerror(kifErrorStrings[232]);

	//In the case of an object, we prefere avoiding applying the function, which might be applied on a field from that variable 
	if (var->Returnvalue()->type==kifDomain)
		return kifTRUE;

	if (func->PredefinedVariableFunction()) {
		func->Execute(var,NULL,b,false);
		return kifTRUE;
	}

	short name=func->Name();
	if (func->Size()!=2) {
		string message=kifErrorStrings[195];
		message+=(*kifIdString)[name];
		return kifcode->Returnerror(message);
	}
	KifCallFunctionGeneral kfunc(NULL,this,name,(KifFunction*)func);
	kfunc.kifcode=kifcode;
	kfunc.parameters.push_back(a);
	kfunc.parameters.push_back(b);
	a->reference++;
	b->reference++;
	KifElement* ret=kfunc.Execute(kifNULL,func);
	a->reference--;
	b->reference--;
	return ret;
}

KifElement* KifElement::applyfuncinframe(KifVariable* var,KifElement* dom,KifElement* a,KifElement* b,KifDomain* func) {
#ifdef PROFILING
	profilingcall("Element::applyfunc");
#endif
	if (func==NULL)
		return kifcode->Returnerror(kifErrorStrings[232]);

	if (func->PredefinedVariableFunction()) {
		func->Execute(var,NULL,b,false);
		return kifTRUE;
	}

	KifElement* arg0=func->Argument(0);
	short name=func->Name();
	KifVariable* vardom=NULL;
	KifCallFunctionGeneral kfunc(NULL,this,name,(KifFunction*)func);
	kfunc.kifcode=kifcode;

	if (func->Size()==3) {
		if (arg0==NULL || arg0->Name()==-1) {
			string message=kifErrorStrings[195];
			message+=(*kifIdString)[name];
			return kifcode->Returnerror(message);
		}
		vardom=new KifVariable(NULL,NULL,dom,arg0->Name());
		kfunc.parameters.push_back(vardom);	
	}
	else 
		if (func->Size()!=2) {
			string message=kifErrorStrings[195];
			message+=(*kifIdString)[name];
			return kifcode->Returnerror(message);
		}


	kfunc.parameters.push_back(a);
	kfunc.parameters.push_back(b);
	if (dom!=NULL)
		dom->reference++;
	a->reference++;
	b->reference++;
	KifElement* ret=kfunc.Execute(kifNULL,func);
	if (vardom!=NULL)
		delete vardom;
	if (dom!=NULL)
		dom->reference--;
	a->reference--;
	b->reference--;
	return ret;
}

KifElement* KifDomain::applycomparatorfunction(KifElement* a,KifElement* b,KifFunction* func) {

	short name=func->Name();
	if (func->Size()!=2) {
		string message=kifErrorStrings[195];
		message+=(*kifIdString)[name];
		return kifcode->Returnerror(message);
	}
	KifCallFunctionGeneral kfunc(NULL,this,name,func);
	kfunc.kifcode=kifcode;

	a->reference++;
	b->reference++;
	
	kfunc.parameters.push_back(a);
	kfunc.parameters.push_back(b);
	KifElement* ret=kfunc.Execute(kifNULL,(KifDomain*)this);

	a->reference--;
	b->reference--;
	return ret;
}

KifElement* KifDomain::Framedefined(short methodname,KifElement* contextualpattern,KifDomain* dom) {

	if (declarations.find(methodname)==declarations.end())
		return kifNULL;

	KifElement* func=declarations[methodname];
	KifCallFunctionGeneral kfunc(NULL,this,methodname,(KifFunction*)func);
	kfunc.kifcode=kifcode;
	return kfunc.Execute(contextualpattern,this);
}
//--------------------------------------------------------------------------------------
KifElement* KifVector::Copy(KifDomain* kp,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Vector::Copy");
#endif
	KifElement* ke=kifcode->Providevector();
	for (int itx=0;itx<values.size();itx++) {
		KifElement* kx=values[itx]->Copy(kp,dom);
		ke->Push(kx);
	}
	return ke;
}

KifElement* KifList::Copy(KifDomain* kp,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Vector::Copy");
#endif
	KifElement* ke=new KifList(kifcode,kp);
	list<KifElement*>::iterator itx;
	for (itx=values.begin();itx!=values.end();itx++) {
		KifElement* kx=(*itx)->Copy(kp,dom);
		ke->Push(kx);
	}

	return ke;
}


KifElement* KifMap::Copy(KifDomain* kp,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Map::Copy");
#endif
	KifMap* ke=kifcode->Providemap();
	hmap<string,KifElement*>::iterator itx;
	for (itx=values.begin();itx!=values.end();itx++) {
		string n=itx->first;
		if (itx->second!=NULL) {
			ke->values[n]=itx->second->Copy(kp,dom);		
			ke->values[n]->Setreference();
		}
		else
			ke->values[n]=NULL;
	}
	return ke;
}

//This function applies delayed _initial functions to frame elements...
void KifDomain::ApplyDelayedInitial() {
#ifdef PROFILING
	profilingcall("Domain::Copy");
#endif
	//The difference between delayed and postpone is the following:
	//delayed means that frame elements belonging to the current frame need to be initialised
	//postpone means that the local _initial method for the current frame has not been called yet...
	delayed--;
	hmap<short,KifElement*>::iterator it;
	KifElement* xe;
	KifElement* ke;
	for (it=declarations.begin();it!=declarations.end();it++) {
		//the initialisation method is attached to frame description of that element
		xe=((KifDomain*)frame)->declarations[it->first];
		ke=it->second->Returnvalue();
		if (ke->Postpone()) {
			ke->applyinitial(this,xe->Initialisation());
			//Do we still have elements to initialize?
			if (ke->Delayed())
				ke->ApplyDelayedInitial();
		}
	}
}


KifElement* KifDomain::Copy(KifDomain* dom,KifElement* decl) {
#ifdef PROFILING
	profilingcall("Domain::Copy");
#endif
	hmap<short,KifElement*>::iterator it;
	KifDomain* kFrameInstanciation=new KifDomain(kifcode,dom,decl->Name(),kifDomain);
	kFrameInstanciation->frame=frame;

	KifElement* xe;
	
	for (it=declarations.begin();it!=declarations.end();it++) {
		xe=it->second->Atom();
		kFrameInstanciation->Setdeclaration(it->first,xe,NULL);
	}
	
	return kFrameInstanciation;
}	

KifElement* KifFrame::Copy(KifDomain* dom,KifElement* decl) {
#ifdef PROFILING
	profilingcall("Domain::Copy");
#endif	

	if (ordered.size()==0) {
		hmap<short,KifElement*>::iterator it;
		//we put the initialisation in the right order...
		//This is done only once for a given frame...
		//First the functions, we could have done it at the compiling level
		//however, here is the only level when we know we have all our parts, hence
		//a little bit of compiling at execution time...
		for (it=declarations.begin();it!=declarations.end();it++) {
			if (it->second->type==kifFunction)
				ordered.push_back(it->first);
		}
		//Then the parent frame's variables
		KifFrame* parent=ParentFrame();
		if (parent!=NULL) {
			for (it=declarations.begin();it!=declarations.end();it++) {
				if (parent->declarations.find(it->first)!=parent->declarations.end())
					ordered.push_back(it->first);
			}
		}
		//the remaining variables...
		for (it=declarations.begin();it!=declarations.end();it++) {
			if (it->second->type==kifFunction)
				continue;
			if (parent!=NULL && parent->declarations.find(it->first)!=parent->declarations.end())
				continue;
			ordered.push_back(it->first);
		}
	}

	KifDomain* kFrameInstanciation=new KifDomain(kifcode,dom,decl->Name(),kifDomain);
	kFrameInstanciation->frame=this;

	KifElement* func;
	if (decl!=kifNULL) {
		func=decl->Returnfunction();
		if (func==NULL)
			func=kFrameInstanciation->frame->Returnfunction();
	}
	else 
		func=dom->Returnfunction();

	kFrameInstanciation->Disableadding();
	bool removefunction;
	KifElement* ke;
	KifElement* xe;
	

	for (int i=0;i<ordered.size();i++) {
		xe=declarations[ordered[i]];
		if (xe->type==kifFunction) {
			kFrameInstanciation->Setdeclaration(ordered[i],xe,NULL);
			continue;
		}
		removefunction=false;
		if (xe->Returnfunction()==NULL && func!=NULL) {
			removefunction=true;
			xe->Setfunction(func);
		}

		//If we are dealing with a frame element, then
		//we will delay the call to the associate _initial function
		//xe should have the postpone flag set to true
		if (xe->Postpone())
			//kFrameInstanciation is our new Domain element. A Domain element is an instanciation of a particular frame declaration
			//This element receives a delayed flag, which is general to all frames within this frame.
			kFrameInstanciation->Setdelayed();
		ke=xe->Copy(kFrameInstanciation,xe);

		//We keep a track of the variable frame
		ke->Setframe(kFrameInstanciation);
		kFrameInstanciation->Setdeclaration(ordered[i],ke,NULL);
		if (removefunction==true)
			xe->Setfunction(NULL);
	}

	return kFrameInstanciation;
}	

KifElement* KifDomain::Vector(KifElement* dom) {
	if (declarations.find(idvector)!=declarations.end())
		return Framedefined(idvector,kifNULL,this);

	KifVector* kvect=kifcode->Providevector();
	hmap<short,KifElement*>::iterator it;
	KifVariable* var;
	KifElement* katom;
	KifElement* x;
	
	for (it=declarations.begin();it!=declarations.end();it++) {
		x=it->second;
		if (x->type==kifVariable) {
			var=(KifVariable*)x;
			if (var->value->type==kifDomain)
				katom=var->value->Vector(this);
			else {
				katom=var->Atom();
				if (var->value==katom)
					katom=var->value;						
			}
			kvect->Push(katom);
		}
	}
	return kvect;
}	

KifElement* KifDomain::Map(KifElement* dom) {
	if (declarations.find(idmap)!=declarations.end())
		return Framedefined(idmap,kifNULL,this);

	KifMap* kmap=kifcode->Providemap();
	hmap<short,KifElement*>::iterator it;
	KifElement* x;
	KifVariable* var;
	KifElement* katom;
	
	for (it=declarations.begin();it!=declarations.end();it++) {
		x=it->second;
		if (x->type==kifVariable) {
			var=(KifVariable*)x;
			if (var->value->type==kifDomain)
				katom=var->value->Map(this);
			else {
				katom=var->Atom();
				if (var->value==katom)
					katom=var->value;						
			}
			string skey=(*kifIdString)[it->first];
			kmap->Push(skey,katom);
		}
	}
	return kmap;
}	

//--------------------------------------------------------------------------------------

KifElement* KifDomain::applyinitial(KifDomain* dom,KifElement* params) {
#ifdef PROFILING
	profilingcall("Domain::applyinitial");
#endif	
	KifElement* func=Declaration(id_initial);

	postpone=false;
	//If such a function has been defined, we use it...
	bool launch=true;
	bool delfunc=false;
	//otherwise we still create one, in order to launch autorun functions
	if (func==NULL) {
		launch=false;
		delfunc=true;
		func=new KifFunction(NULL,NULL,id_initial);
		func->kifcode=kifcode;
	}

	KifCallFunctionGeneral kfunc(NULL,this,id_initial,(KifFunction*)func);
	hmap<short,KifElement*>::iterator it;
	KifCallFunctionGeneral* kautorun;
	int iv=0;
	for (it=declarations.begin();it!=declarations.end();it++) {
		if (it->second->Autorun()) {
			short id=it->first;
			kautorun=new KifCallFunctionGeneral(kifcode,this,id,(KifFunction*)it->second);
			kautorun->Setreference();
			kfunc.body->instructions.insert(kfunc.body->instructions.begin()+iv,kautorun);
			//if we have autorun functions, we need to launch whether there is an _initial function or not...
			launch=true;
			iv++;
		}
	}

	if (launch==false) {
		delete func;
		return kifFALSE;
	}

	if (params->type==kifInstruction) {
		KifInstruction* ki=(KifInstruction*)params;
		for (int i=0;i<ki->instructions.size();i++)
			kfunc.parameters.push_back(ki->instructions[i]->Execute(kifNULL,dom));
	}
	kfunc.kifcode=kifcode;
	KifElement* ret=kfunc.Execute(kifNULL,this);
	//We need to clean our instruction set
	for (int i=0;i<iv;i++)
		kfunc.body->instructions.erase(kfunc.body->instructions.begin());
	if (delfunc)
		delete func;
	return ret;
}


bool KifDerivation(KifElement* frame,KifElement* derive,bool typetest) {
	if (frame->type!=kifFrame || derive->type!=kifFrame)
		return typetest;

	KifFrame* derivation=(KifFrame*)derive;
	while (derivation!=NULL) {
		if (frame==derivation)
			return true;
		derivation=derivation->parent;
	}
	return false;
}

KifElement* KifDomain::applyoperation(short na,KifElement* a,KifElement* b) {
	if (declarations.find(na)==declarations.end())
		return kifNULL;

	if (a->type!=kifDomain || KifDerivation(frame,a->Frame(),false)==false) {
		a=((KifDomain*)a)->Framedefined(frame->Name(),this,(KifDomain*)a);

		if (a==kifNULL || frame!=a->Frame())
			return kifcode->Returnerror(kifErrorStrings[242]);
	}

	if (b->type!=kifDomain || KifDerivation(frame,b->Frame(),false)==false) {
		b=((KifDomain*)b)->Framedefined(frame->Name(),this,(KifDomain*)b);

		if (b==kifNULL || frame!=b->Frame())
			return kifcode->Returnerror(kifErrorStrings[242]);
	}

	KifElement* func=declarations[na];
	//If such a function has been defined, we use it...
	KifCallFunctionGeneral kfunc(NULL,this,na,(KifFunction*)func);
	kfunc.kifcode=kifcode;
	kfunc.parameters.push_back(a);
	kfunc.parameters.push_back(b);
	return kfunc.Execute(kifNULL,this);
}


KifElement* KifDomain::applycomparison(short na,KifElement* a) {

	if (declarations.find(na)==declarations.end())
		return kifFALSE;
	
	if (a->type!=kifDomain || KifDerivation(frame,a->Frame(),false)==false) {
		a=((KifDomain*)a)->Framedefined(frame->Name(),this,(KifDomain*)a);

		if (a==kifNULL || frame!=a->Frame())
			return kifcode->Returnerror(kifErrorStrings[242]);
	}
	
	
	KifElement* func=declarations[na];
	//If such a function has been defined, we use it...
	KifCallFunctionGeneral kfunc(NULL,this,na,(KifFunction*)func);
	kfunc.kifcode=kifcode;
	//We add our parameters
	kfunc.parameters.push_back(a);
	return kfunc.Execute(kifNULL,this);
}

KifElement* KifDomain::applyincrement(short na) {

	if (declarations.find(na)==declarations.end())
		return kifFALSE;
		
	KifElement* func=declarations[na];
	//If such a function has been defined, we use it...
	KifCallFunctionGeneral kfunc(NULL,this,na,(KifFunction*)func);
	kfunc.kifcode=kifcode;
	return kfunc.Execute(kifNULL,this);
}

KifElement* KifFile::in(KifElement* var,KifElement* a,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
#ifdef PROFILING
	profilingcall("File::in");
#endif
	if (EndOfFile()==kifTRUE)
		return kifFALSE;
	a=var->Returnvalue();
	switch(a->type) {
	case kifInteger:
		c=(uchar)thefile->get();
		((KifInteger*)a)->value=c;
		break;
	case kifFloat:
		c=(uchar)thefile->get();
		((KifFloat*)a)->value=c;
		break;
	case kifString:
		getline(*thefile,((KifString*)a)->value,'\n');
		break;
	default:
		getline(*thefile,localstring->value,'\n');
		if (var->inType()==kifVector)			
			var->Push(localstring);
		else			
			var->Setvalue(localstring,kifNULL,kfunc);
	}
	return kifTRUE;
}

KifElement* KifFile::whilein(KifElement* var) {
#ifdef PROFILING
	profilingcall("File::in");
#endif
	if (EndOfFile()==kifTRUE)
		return kifFALSE;
	switch(localtype) {
	case kifInteger:
		c=(uchar)fgetc(fileread);
		((KifInteger*)local)->value=c;
		break;
	case kifFloat:
		c=(uchar)fgetc(fileread);
		((KifFloat*)local)->value=c;
		break;
	case kifString:
		fgets(kifcode->buffer,4096,fileread);
		((KifString*)local)->value=kifcode->buffer;
		break;
	default:
		fgets(kifcode->buffer,4096,fileread);
		localstring->value=kifcode->buffer;
		if (var->inType()==kifVector)			
			var->Push(localstring);
		else
			var->Setvalue(localstring);
	}
	return kifTRUE;
}

KifElement* KifDomain::in(KifElement* a,KifElement* b,KifDomain* kexfunc,KifElement* contextualpattern,bool idx) {
#ifdef PROFILING
	profilingcall("Domain::in");
#endif
	if (kexfunc!=NULL)
		return applyfunc(a,b,kexfunc);

	
	KifElement* func=Declaration(idin);
	//If such a function has been defined, we use it...
	if (func!=NULL) {
		KifCallFunctionGeneral kfunc(NULL,this,idin,(KifFunction*)func);
		kfunc.kifcode=kifcode;
		//We add our parameters
		kfunc.parameters.push_back(a);
		return kfunc.Execute(kifNULL,this);
	}	
	return kifNULL;
}


KifElement* KifMatrix::in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
#ifdef PROFILING
	profilingcall("Matrix::in");
#endif
	KifElement* res;
	vector<map<string,map<string,KifElement*> > >::iterator itins;
	map<string,map<string,KifElement*> >::iterator itclass;
	map<string, KifElement*>::iterator itatt;
	for (itins=values.begin();itins!=values.end();itins++) {
		for (itclass=(*itins).begin();itclass!=(*itins).end();itclass++) {
			for (itatt=itclass->second.begin();itatt!=itclass->second.end();itatt++) {
				res=itatt->second;
				res=res->in(a,res,kfunc,this,idx);
				if (res!=kifFALSE && res!=kifNULL)
					return kifTRUE;
			}
		}
	}
	return kifFALSE;
}

KifElement* KifString::in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
#ifdef PROFILING
	profilingcall("String::in");
#endif


	if (kfunc==NULL) {
		
		if (contextualpattern->type==kifBoolean && idx==false && b==this) {
			if (a->type==kifString) {
				if (value.find(((KifString*)a)->value)!=-1)
					return kifTRUE;
			}
			else {
				if (value.find(a->String())!=-1)
					return kifTRUE;
			}
			return kifFALSE;
		}

		if (b->type!=kifString)
			return b->in(a,b,kfunc,contextualpattern,true);

		string s1;
		if (a->type==kifString)
			s1=((KifString*)a)->value;
		else
			s1=a->String();
		string& s2=((KifString*)b)->value;
		if (contextualpattern->type==kifVector || contextualpattern->type==kifMap) {
			if (idx==false) {
				if (s1==s2)
					return kifTRUE;
				return kifFALSE;
			}
		}

		int rs=s2.find(s1);
		if (rs!=-1) {
			if (contextualpattern->type==kifString)
				return kifcode->Providestring(s1);

			if (idx==false)
				return kifTRUE;
			

			if (contextualpattern->type==kifVector) {
				KifInteger locint(NULL,NULL);
				locint.kifcode=kifcode;
				KifVector* kvect=Selectvector(this,contextualpattern);
				locint.value=rs;
				kvect->Push(&locint);
				rs=s2.find(s1,rs+1);
				while (rs!=-1) {
					locint.value=rs;
					kvect->Push(&locint);
					rs=s2.find(s1,rs+1);
				}
				return kvect;
			}			
			else
				if (contextualpattern->type==kifMap) {
					KifInteger locint(NULL,NULL);
					locint.kifcode=kifcode;
					int i=0;
					KifMap* kmap=Selectmap(this,contextualpattern);
					sprintf_s(kifcode->buffer,100,"%d",i);
					locint.value=rs;
					kmap->Push(kifcode->buffer,&locint);
					rs=s2.find(s1,rs+1);
					i++;
					while (rs!=-1) {
						sprintf_s(kifcode->buffer,100,"%d",i);
						locint.value=rs;
						kmap->Push(kifcode->buffer,&locint);
						rs=s2.find(s1,rs+1);
						i++;
					}
					return kmap;
				}			

			return kifcode->Provideinteger(rs);
		}
		if (contextualpattern->type==kifString)
			return kifNULL;

		if (idx==false)
			return kifFALSE;
		return kifMINUSONE;
	}
	else
		return applyfunc(a,b,kfunc);
}

Exported KifElement* KifTree::in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {


	KifElement* res;
	if (b->type!=kifTree)
		return b->in(a,b,kfunc,contextualpattern,true);

	KifIteratorTree itree(NULL,NULL,(KifTree*)b);


	KifElement* ktree=itree.Begin();
	KifVector* kvect=NULL;
	KifMap* kmap=NULL;
	while (itree.End()==kifFALSE) {
		KifElement* kval=ktree->TreeValue();
		res=kval->in(a,kval,kfunc,this,idx);
		if (res!=kifFALSE && res!=kifNULL) {
			if (idx==false)
				return kifTRUE;

			if (contextualpattern->type==kifVector) {
				if (kvect==NULL)
					kvect=Selectvector(this,contextualpattern);
				kvect->Push(ktree);
			}			
			else {
				if (contextualpattern->type==kifMap) {
					if (kmap==NULL)
						kmap=Selectmap(this,contextualpattern);
					sprintf_s(kifcode->buffer,100,"%d",itree.idx);
					kmap->Push(kifcode->buffer,ktree);
				}	
				else
					return kifcode->Provideinteger(itree.idx);
			}				
		}
		ktree=itree.Next();
	}
	if (kvect!=NULL)
		return kvect;
	if (kmap!=NULL)
		return kmap;
	return kifFALSE;
}

KifElement* KifList::in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
#ifdef PROFILING
	profilingcall("List::in");
#endif
	KifElement* ke;
	KifElement* k;
	KifElement* res;
	KifElement* found=kifFALSE;


	//If it's a while, then we loop among all elements

	if (b->type==kifMap) {
		Clear();
		KifMap* bb=(KifMap*)b;
		hmap<string,KifElement*>::iterator itx;
		KifBaseString localstring(NULL,NULL);
		localstring.kifcode=kifcode;

		for (itx=bb->values.begin();itx!=bb->values.end();itx++) {
			k=itx->second;
			res=k->in(a,k,kfunc,this,idx);
			if (res!=kifFALSE && res!=kifNULL) {
				localstring.value=itx->first;
				Push(&localstring);
			}
		}
		return this;
	}

	if (b->type==kifList) {
		if (b!=this)
			Clear();
			
		KifList* bb=(KifList*)b;
		list<KifElement*>::iterator itb;
		int ix=0;
		//A sub list in a list... Each element of a should be in b, in that order
		if (a->type==kifList) {
			KifList* aa=(KifList*)a;
			if (aa->values.size()==0) {
				if (idx==true)
					return kifNULL;
				return kifTRUE;
			}
			list<KifElement*>::iterator ita;
			list<KifElement*>::iterator it;
			
			for (itb=bb->values.begin();itb!=bb->values.end();itb++,ix++) {
				bool locfound=false;
				it=itb;
				for (ita=aa->values.begin();ita!=aa->values.end();ita++,it++) {
					locfound=true;
					if (it==bb->values.end()) {
						locfound=false;
						break;
					}
					k=*it;
					KifElement* ka=*ita;
					if (k->same(ka)==kifFALSE) {
						locfound=false;
						break;
					}
				}
				if (locfound==true) {
					if (b!=this) {
						Push(kifcode->Provideinteger(ix));
						found=this;
					}
					else {
						if (idx==true) {
							ke=kifcode->Provideinteger(ix);						
							return ke;
						}
						return kifTRUE;
					}				
				}
			}
			if (b==this && idx==true)
				return kifMINUSONE;
			
			return found;
		}
			
		for (itb=bb->values.begin();itb!=bb->values.end();itb++) {
			k=*itb;
			res=k->in(a,k,kfunc,this,idx);
			if (res!=kifFALSE && res!=kifNULL) {
				if (b!=this) {
					Push(kifcode->Provideinteger(ix));
					found=this;
				}
				else {
					if (idx==true) {
						ke=kifcode->Provideinteger(ix);						
						return ke;
					}
					return kifTRUE;
				}
			}
			ix++;
		}
		
		if (b==this && idx==true)
			return kifMINUSONE;

		return found;
	}

	if (b!=this)
		return b->in(a,b,kfunc,contextualpattern,true);
	if (idx==true)
		return kifMINUSONE;
	return kifFALSE;
}

KifElement* KifVector::in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
#ifdef PROFILING
	profilingcall("Vector::in");
#endif
	KifElement* res;

	if (b->type==kifVector) {
		KifElement* found=kifFALSE;
		KifVector* bb=(KifVector*)b;
		int itb;
		KifElement* kint;

		if (b!=this) {
			Clear();
			kint=new KifInteger(NULL,NULL);
			kint->kifcode=kifcode;
		}
			


		//A sub vector in a vector... Each element of a should be in b, in that order
		if (a->type==kifVector) {
			KifVector* aa=(KifVector*)a;
			if (aa->values.size()==0) {
				if (idx==true)
					return kifNULL;
				return kifTRUE;
			}

			int it;
			bool locfound;
			for (itb=0;itb!=bb->values.size();itb++) {
				locfound=false;
				it=itb;
				for (int ita=0;ita!=aa->values.size();ita++,it++) {
					locfound=true;
					if (it==bb->values.size()) {
						locfound=false;
						break;
					}
					if (bb->values[it]->same(aa->values[ita])==kifFALSE) {
						locfound=false;
						break;
					}
				}
				if (locfound==true) {
					if (b!=this) {
						((KifInteger*)kint)->value=itb;
						Push(kint);
						found=this;
					}
					else {
						if (idx==true)
							return kifcode->Provideinteger(itb);						
						return kifTRUE;
					}				
				}
			}

			if (b!=this)
				delete kint;
			else
				if (idx==true)
					return kifMINUSONE;
			
			return found;
		}
		
		for (itb=0;itb!=bb->values.size();itb++) {
			res=bb->values[itb];
			res=res->in(a,res,kfunc,this,idx);
			if (res!=kifFALSE && res!=kifNULL) {
				if (b!=this) {					
					((KifInteger*)kint)->value=itb;
					Push(kint);
					found=this;
				}
				else {
					if (idx==true)
						return kifcode->Provideinteger(itb);						
					return kifTRUE;
				}
			}
		}
		if (b!=this)
			delete kint;
		else
			if (idx==true)
				return kifMINUSONE;

		return found;
	}

	if (b->type==kifMap) {
		Clear();
		KifMap* bb=(KifMap*)b;
		hmap<string,KifElement*>::iterator itx;
		KifBaseString localstring(NULL,NULL);
		localstring.kifcode=kifcode;

		for (itx=bb->values.begin();itx!=bb->values.end();itx++) {
			res=itx->second;
			res=res->in(a,res,kfunc,this,idx);
			if (res!=kifFALSE && res!=kifNULL) {
				localstring.value=itx->first;
				Push(&localstring);
			}
		}
		return this;
	}


	if (b!=this)
		return b->in(a,b,kfunc,contextualpattern,true);
	if (idx==true)
		return kifMINUSONE;
	return kifFALSE;
}

KifElement* KifMap::in(KifElement* a,KifElement* b,KifDomain* kfunc,KifElement* contextualpattern,bool idx) {
#ifdef PROFILING
	profilingcall("Map::in");
#endif
	KifElement* ke;
	KifElement* k;
	KifElement* res;
	KifElement* found=kifFALSE;


	if (b->type==kifMap) {
		if (b!=this)
			Clear();
		KifMap* bb=(KifMap*)b;
		hmap<string,KifElement*>::iterator itx;
		if (a->type==kifMap) {
			KifMap* aa=(KifMap*)a;
			hmap<string,KifElement*>::iterator ita;
			bool locfound=true;
			
			for (ita=aa->values.begin();ita!=aa->values.end();ita++) {
				itx=bb->values.find(ita->first);
				if (itx==bb->values.end()) {
					locfound=false;
					break;
				}
				if (itx->second->same(ita->second)==kifFALSE) {
					locfound=false;
					break;
				}
			}
			if (locfound==true)
				return kifTRUE;
			
			if (idx==true)
				return kifNULL;
			return kifFALSE;			
		}
		for (itx=bb->values.begin();itx!=bb->values.end();itx++) {
			k=itx->second;
			res=k->in(a,k,kfunc,this,idx);
			if (res!=kifFALSE && res!=kifNULL) {				
				if (b!=this) {
					ke=kifcode->Providestringraw(itx->first);
					Setvalue(res,ke);
					found=this;
				}
				else 
					if (idx==true) {
						ke=kifcode->Providestringraw(itx->first);
						return ke;
					}
					else
						return kifTRUE;
			}
		}

		if (b==this && idx==true)
			return kifNULL;
		return found;
	}

	if (b->type==kifVector) {
		KifVector* bb=(KifVector*)b;
		int ix=0;
		for (int it=0;it<bb->values.size();it++) {
			k=bb->values[it];
			res=k->in(a,k,kfunc,this,idx);
			if (res!=kifFALSE && res!=kifNULL) {
				if (b!=this) {					
					ke=kifcode->Provideinteger(ix);
					Setvalue(res,ke);
				}
			}
			ix++;
		}
		return this;
	}

	if (b!=this)
		return b->in(a,b,kfunc,contextualpattern,true);

	if (idx==true)
		return kifNULL;

	return kifFALSE;
}

//--------------------------------------------------------------------------------------

void KifDomain::SetInstanceslocal(KifElement* dom,hmap<short,KifElement*>* stacks) {
	hmap<short,KifElement*>::iterator it;
	dom->Disableadding();
	KifElement* xe;
	for (it=declarations.begin();it!=declarations.end();it++) {
		xe=it->second;
		if (xe->type==kifFunction || xe->reference>=30000 || xe->idgarbage<=0)	
			continue;
		xe=xe->Copy(this,xe);
		dom->Setdeclaration(it->first,xe,stacks);
	}
}	


void KifDomain::Setreference() {
	reference++;
	hmap<short,KifElement*>::iterator it;
	for (it=declarations.begin();it!=declarations.end();it++) {
		if (it->second!=NULL)
			it->second->Setreference();
	}	
}

void KifDomain::Setpopped() {
	popped=true;
	hmap<short,KifElement*>::iterator it;
	for (it=declarations.begin();it!=declarations.end();it++) {
		if (it->second!=NULL)
			it->second->Setpopped();
	}	
}

void KifMatrix::Setreference() {
	reference++;
	vector<map<string,map<string,KifElement*> > >::iterator itins;
	map<string,map<string,KifElement*> >::iterator itclass;
	map<string, KifElement*>::iterator itatt;
	for (itins=values.begin();itins!=values.end();itins++) {
		for (itclass=(*itins).begin();itclass!=(*itins).end();itclass++) {
			for (itatt=itclass->second.begin();itatt!=itclass->second.end();itatt++) {
				if (itatt->second!=kifNULL)
					itatt->second->Setreference();
			}
		}
	}
}

void KifMatrix::Setpopped() {
	popped=true;
	vector<map<string,map<string,KifElement*> > >::iterator itins;
	map<string,map<string,KifElement*> >::iterator itclass;
	map<string, KifElement*>::iterator itatt;
	for (itins=values.begin();itins!=values.end();itins++) {
		for (itclass=(*itins).begin();itclass!=(*itins).end();itclass++) {
			for (itatt=itclass->second.begin();itatt!=itclass->second.end();itatt++) {
				if (itatt->second!=kifNULL)
					itatt->second->Setpopped();
			}
		}
	}
}

void KifMatrix::Clean() {	
	vector<map<string,map<string,KifElement*> > >::iterator itins;
	map<string,map<string,KifElement*> >::iterator itclass;
	map<string, KifElement*>::iterator itatt;
	for (itins=values.begin();itins!=values.end();itins++) {
		for (itclass=(*itins).begin();itclass!=(*itins).end();itclass++) {
			for (itatt=itclass->second.begin();itatt!=itclass->second.end();itatt++) {
				if (itatt->second!=kifNULL)
					itatt->second->Clean();
			}
		}
	}
	values.clear();
	KifElement::Resetreference();
}


Exported void KifIterator::Resetreference() {
	if (value!=NULL && value->type==kifIteration) {
		if (popped==true)
			value->popped=popped;
		value->Resetreference();
	}
	KifElement::Resetreference();
}

void KifMatrix::Resetreference() {
	vector<map<string,map<string,KifElement*> > >::iterator itins;
	map<string,map<string,KifElement*> >::iterator itclass;
	map<string, KifElement*>::iterator itatt;
	for (itins=values.begin();itins!=values.end();itins++) {
		for (itclass=(*itins).begin();itclass!=(*itins).end();itclass++) {
			for (itatt=itclass->second.begin();itatt!=itclass->second.end();itatt++) {
				if (itatt->second!=kifNULL) {
					if (popped==true)
						itatt->second->popped=popped;
					itatt->second->Resetreference();
				}
			}
		}
	}
	if (reference<=1 && !popped)
		values.clear();
	KifElement::Resetreference();
}

void KifMatrix::Clear() {
	vector<map<string,map<string,KifElement*> > >::iterator itins;
	map<string,map<string,KifElement*> >::iterator itclass;
	map<string, KifElement*>::iterator itatt;
	for (itins=values.begin();itins!=values.end();itins++) {
		for (itclass=(*itins).begin();itclass!=(*itins).end();itclass++) {
			for (itatt=itclass->second.begin();itatt!=itclass->second.end();itatt++) {
				if (itatt->second!=kifNULL)
					itatt->second->Resetreference();
			}
		}
	}
	values.clear();
}



void KifList::Resetreference() {
	list<KifElement*>::iterator itx;
	for (itx=values.begin();itx!=values.end();itx++) {		
		if (popped==true)
			(*itx)->popped=popped;
		(*itx)->Resetreference();
	}

	reference--;
	if (reference<=0) {
		if (popped)
			popped=false;
		else {
			values.clear();
			ThreadLock _lock(type);
			if (idgarbage!=-1 && idgarbage<kifcode->cursorlist)
				kifcode->cursorlist=idgarbage;
		}
	}
}

void KifList::Clear() {
	list<KifElement*>::iterator itx;	
	for (itx=values.begin();itx!=values.end();itx++) {
		int nb=reference;
		while (nb>=0) {
			(*itx)->Resetreference();
			nb--;
		}
	}
	values.clear();
}

void KifMap::Resetreference() {

	hmap<string,KifElement*>::iterator itx;
	for (itx=values.begin();itx!=values.end();itx++) {
		if (itx->second!=NULL) {
			if (popped==true)
				itx->second->popped=popped;
			itx->second->Resetreference();
		}
	}

	reference--;
	if (reference<=0) {
		if (popped)
			popped=false;
		else {
			values.clear();
			ThreadLock _lock(type);
			if (idgarbage!=-1 && idgarbage<kifcode->cursormap)
				kifcode->cursormap=idgarbage;
		}
	}
}

void KifMap::Clear() {
	hmap<string,KifElement*>::iterator itx;
	for (itx=values.begin();itx!=values.end();itx++) {
		int nb=reference;
		while (nb>=0) {
			itx->second->Resetreference();
			nb--;
		}
	}		
	values.clear();
}

void KifDomain::Clean() {	
	hmap<short,KifElement*>::iterator it;
	for (it=declarations.begin();it!=declarations.end();it++) {
		if (it->second!=NULL)
			it->second->Clean();
	}	
	declarations.clear();
	KifElement::Resetreference();
}

void KifDomain::Clear() {
	hmap<short,KifElement*>::iterator it;
	for (it=declarations.begin();it!=declarations.end();it++) {
		if (it->second!=NULL)
			it->second->Resetreference();
	}
	declarations.clear();
}

void KifDomain::Resetreference() {
	hmap<short,KifElement*>::iterator it;
	for (it=declarations.begin();it!=declarations.end();it++) {
		if (it->second!=NULL) {
			if (popped==true)
				it->second->popped=popped;
			it->second->Resetreference();
		}
	}
	if (reference<=1 && !popped)
		declarations.clear();
	KifElement::Resetreference();
}



bool KifDomain::Setvalue(KifElement* ke,KifElement* idx,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Domain::Setvalue");
#endif
	if (this==ke)
		return true;
	ThreadLock _lock(type);
	
	if (ke==kifNULL) {
		Clear();
		return true;
	}

	if (frame==kifNULL) {
		kifcode->Returnerror(kifErrorStrings[155]);
		return true;
	}
	
	if (idx!=NULL && idx !=kifNULL && declarations.find(idindex)!=declarations.end()) {
		//We set a value through an index...
		KifElement* left=idx;
		if (idx->type==kifIndex) {
			KifIndex* kind=(KifIndex*)idx;		
			left=kind->key->Execute(kifNULL,this);
			if (kind->interval==true) {
				kifcode->Returnerror(kifErrorStrings[155]);
				return true;
			}
		}
		
		KifElement* func=declarations[idindex];
		//If such a function has been defined, we use it...
		KifCallFunctionGeneral kfunc(NULL,this,idindex,(KifFunction*)func);
		kfunc.kifcode=kifcode;
		//We add our parameters
		kfunc.parameters.push_back(left);
		kfunc.parameters.push_back(ke);		
		return kfunc.Execute(kifNULL,this);		
	}
	
	//We rebuild an object from a map...
	if (ke->type==kifMap) {
		//each key of the map should be a variable in our frame
		hmap<short,KifElement*> keys;
		hmap<string,KifElement*>::iterator it;
		short id;
		KifMap* kmap=(KifMap*)ke;
		for (it=kmap->values.begin();it!=kmap->values.end();it++) {
			if (kifStringId->find(it->first)==kifStringId->end()) {
				kifcode->Returnerror(kifErrorStrings[155]);
				return true;
			}
			id=(*kifStringId)[it->first];
			if (declarations.find(id)==declarations.end()) {
				kifcode->Returnerror(kifErrorStrings[155]);
				return true;
			}
			keys[id]=it->second;
		}
		
		hmap<short,KifElement*>::iterator itk;
		for (itk=keys.begin();itk!=keys.end();itk++)
			declarations[itk->first]->Setvalue(itk->second);
		return true;
	}


	if (KifDerivation(frame,ke->Frame(),false)==false) {
		//Maybe we have a translation from one frame into another
		ke=((KifDomain*)ke)->Framedefined(frame->Name(),this,(KifDomain*)ke);
		
		if (ke==kifNULL || frame!=ke->Frame()) {
			kifcode->Returnerror(kifErrorStrings[155]);
			return true;
		}
	}

	Clear();
	ke->SetInstances(this,NULL);
	return true;
}

bool KifCall::Setvalue(KifElement* val,KifElement* idx,KifElement* dom) {
#ifdef PROFILING
	profilingcall("Call::Setvalue");
#endif
	ThreadLock _lock(type);
	if (val==kifNULL) {
		body=NULL;
		domain=NULL;
		return true;
	}
	if (val->type!=kifFunction) {
		kifcode->Returnerror(kifErrorStrings[156]);
		return true;
	}
	body=(KifFunction*)val;
	domain=(KifDomain*)dom;
	return true;
}

//===================================================================
Exported string KifFunction::String() {
	return (*kifIdString)[name];
}

Exported string KifCall::String() {
	if (body!=NULL)
		return body->String();
	return "";
}

string KifInteger::String() {
	ostringstream is;
	is<<value;
	return is.str();
}

string KifFraction::String() {
	ostringstream is;
	is<<numerator<<"/"<<denominator;
	return is.str();
}

string KifFloat::String() {
	//ostringstream is;
	//is<<value;
	sprintf(kifcode->buffer,"%g",value);
	return kifcode->buffer;
}

string KifDate::String() {
	struct tm* temps = localtime(&value); 
	strftime(kifcode->buffer,100,"%Y/%m/%d %H:%M:%S",temps);
	return kifcode->buffer;
}

string KifTime::String() {
	double timeval=Float()/1000000UL;
	sprintf_s(kifcode->buffer,100,"%fs",timeval);
	return kifcode->buffer;
}

//===================================================================

void KifFrame::Run(int from) {
	size_t i;
	kifcode->basegarbage=kifcode->garbage.size();
	kifcode->trigger+=kifcode->basegarbage;
	for (i=0;i<kifcode->garbage.dernier;i++)
		kifcode->garbage[i]->reference=30000;

	bool testdebug=kifcode->debugging;
	KifElement* res;

	//We look for the first instruction to execute
	for (i=from;i<instructions.size();i++) {
		KifType xt=instructions[i]->type;
		KifElement* ke=instructions[i];
		if (ke->Variable() || EXECUTABLE(xt)) {
			if (testdebug)
				testdebug=kifcode->Debugging(this,ke,this,NULL);
			res=ke->Execute(kifNULL,this);
			if (kifcode->error==true)
				break;
		}
	}
}

//===================================================================

Exported void KifCode::RemoveThreadidReference(int idthread) {
	int it;
	
	bool s=false;
	bool i=false;
	bool f=false;
	bool v=false;
	bool l=false;
	bool m=false;
	bool g=false;

	{
		ThreadLock _lockid(kifThreadId);
		if ((used[idthread]&kifStringOwner)==kifStringOwner)
			s=true;
		if ((used[idthread]&kifIntegerOwner)==kifIntegerOwner)
			i=true;
		if ((used[idthread]&kifFloatOwner)==kifFloatOwner)
			f=true;
		if ((used[idthread]&kifVectorOwner)==kifVectorOwner)
			v=true;
		if ((used[idthread]&kifListOwner)==kifListOwner)
			l=true;
		if ((used[idthread]&kifMapOwner)==kifMapOwner)
			m=true;
		if ((used[idthread]&kifGarbageOwner)==kifGarbageOwner)
			g=true;
		used.erase(idthread);
	}

	if (s) {
		ThreadLock _lock(kifString);
		for (it=0;it<stringlist.size();it++)
			if (stringlist[it]->threadowner==idthread)
				stringlist[it]->threadowner=kifNoOwner;
	}

	if (i) {
		ThreadLock _lock(kifInteger);
		for (it=0;it<integerlist.size();it++)
			if (integerlist[it]->threadowner==idthread)
				integerlist[it]->threadowner=kifNoOwner;
	}

	if (f) {
		ThreadLock _lock(kifFloat);
		for (it=0;it<floatlist.size();it++)
			if (floatlist[it]->threadowner==idthread)
				floatlist[it]->threadowner=kifNoOwner;
	}

	if (v) {
		ThreadLock _lock(kifVector);
		for (it=0;it<vectorlist.size();it++)
			if (vectorlist[it]->threadowner==idthread)
				vectorlist[it]->threadowner=kifNoOwner;
	}

	if (l) {
		ThreadLock _lock(kifList);
		for (it=0;it<listlist.size();it++)
			if (listlist[it]->threadowner==idthread)
				listlist[it]->threadowner=kifNoOwner;
	}

	if (m) {
		ThreadLock _lock(kifMap);
		for (it=0;it<maplist.size();it++)
			if (maplist[it]->threadowner==idthread)
				maplist[it]->threadowner=kifNoOwner;
	}

	if (g)	{
		ThreadLock _lock(kifGarbage);
		for (it=basegarbage;it<garbage.size();it++) {
			if (garbage[it]!=NULL && garbage[it]->threadowner==idthread)
				garbage[it]->threadowner=kifNoOwner;
		}
	}	
}



#ifdef WIN32
DWORD WINAPI KifCallExecuteThread::Call(LPVOID arg) {
#else
void* KifCallExecuteThread::Call(void* arg) {
#endif
	KifCallExecuteThread* kfuncthread=(KifCallExecuteThread*)arg;
	kfuncthread->Launch();
	delete kfuncthread;
#ifdef WIN32
	return 0;
#else
	pthread_exit(NULL);
	return 0;
#endif
}

Exported void KifCallExecuteThread::Launch() {	
	//We use Execution, since we already know the arguments
	Execution();

	//We can now clean our variables...
	kifcode->EraseThreadid(tid);
	kifcode->RemoveThreadidReference(threadid);
	
	ThreadLock _lockstack(kifStack);


	kifcode->threadstacks.erase(threadid);

	if (domain!=kifcode->kstart)
		domain->Resetreference();
	Resetreference();
	kifThreadControl.Decrement();
}

//This method is called from within a KifCallExecuteThread Launch or Execute...
Exported KifElement* KifThread::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* value,bool rcouple) {

	//If it is a protected thread, then we set the lock in
	if (klock!=NULL)
		klock->Locking();

	KifFunction::Execute(contextualpattern,dom,value,rcouple);

	if (klock!=NULL)
		klock->Unlocking();
	
	return kifTRUE;
}

Exported int KifCode::Setthreadid(int idcaller) {
	int threadid=threadalloc;
	
	threadalloc++;
	vector<KifDomain*>* newdomain=new vector<KifDomain*>;
	vector<KifDomain*>::iterator it;
	if (idcaller==-1) {
		for (it=stacking.begin();it!=stacking.end();it++)
			newdomain->push_back(*it);	
	}
	else {
		for (it=threadstacks[idcaller].begin();it!=threadstacks[idcaller].end();it++)
			newdomain->push_back(*it);	
	}
	threadstacks[threadid]=*newdomain;
	return threadid;
}

void KifCallFunction::Initialise(KifCallFunction* kt) {
	Setselfinsert(kt->selfinsert);
	line=kt->line;
	adding=kt->adding;
	hmap<short,KifElement*>::iterator itdec;
	for (itdec=kt->declarations.begin();itdec!=kt->declarations.end();itdec++)
		declarations[itdec->first]=itdec->second;
	for (int itparam=0;itparam<kt->parameters.size();itparam++)
		parameters.push_back(kt->parameters[itparam]);
}

Exported KifElement* KifCallReturn::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
	KifCallFunction* callfunc=(KifCallFunction*)kifcode->Top();
	if (callfunc==NULL)
		return kifcode->Returnerror(kifErrorStrings[241]);
	if (parameters.size()!=1) {
		callfunc->Setreturnvalue(kifNULL);
		return kifTRUE;
	}

	KifElement* res=parameters[0]->Execute(kifNULL,dom,NULL,false);
	callfunc->Setreturnvalue(res);
	return res;
}

KifElement* KifCallFunctionThread::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
	//First we initialise our thread with the current element	
	KifDomain* top=kifcode->Top();

	ThreadLock* _lockstack=new ThreadLock(kifStack);
	kifThreadControl.Increment();
	int idthread=-1;
	if (top!=NULL)
		idthread=top->Threadid();

	KifCallExecuteThread* kifcall=new KifCallExecuteThread(NULL,this,body,-1);
	kifcall->threadid=kifcode->Setthreadid(idthread);
	kifcall->kifcode=kifcode;
	kifcall->Setreference();
	kifcall->context=contextualpattern;
	
	kifcall->domain=dom;
	if (dom!=kifcode->kstart)
		dom->Setreference();
	kifcall->value=val;
	kifcall->couple=rcouple;
	delete _lockstack;

	//We initialise our function with the right parameters, before they are erased
	kifcall->Arguments();
	if (kifcode->error==true)
		return kifNULL;	
	
	//Then we launch our function
	_lockstack=new ThreadLock(kifStack);
#ifdef WIN32
	kifcall->thid=CreateThread(NULL,0,&KifCallExecuteThread::Call,(LPVOID)kifcall,0,&kifcall->tid);
	if (kifcall->thid==NULL)
		return kifcode->Returnerror(kifErrorStrings[211]);
#else
	if (pthread_create(&kifcall->tid, NULL, &KifCallExecuteThread::Call,(void*)kifcall)<0)
		return kifcode->Returnerror(kifErrorStrings[211]);
#endif		
	
	kifcode->SetThreadid(kifcall->tid,kifcall->threadid);	
	delete _lockstack;

	return kifTRUE;
}


KifElement* KifIteratorList::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("IteratorVector::Execute");
#endif
	if (reverse==false) {
		if (it==values->end())
			return kifNULL;
		return (*it)->Execute(contextualpattern,dom,val,rcouple);
	}
	if (itr==values->rend())
		return kifNULL;
	return (*itr)->Execute(contextualpattern,dom,val,rcouple);
}

KifElement* KifIteratorVector::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("IteratorVector::Execute");
#endif
	if (reverse==false) {
		if (it==values->end())
			return kifNULL;
		return (*it)->Execute(contextualpattern,dom,val,rcouple);
	}
	if (itr==values->rend())
		return kifNULL;
	return (*itr)->Execute(contextualpattern,dom,val,rcouple);
}

KifElement* KifIteratorMap::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("IteratorMap::Execute");
#endif
	if (reverse==false) {
		if (it==values->end())
			return kifNULL;
		return it->second->Execute(contextualpattern,dom,val,rcouple);
	}
	if (itr==values->Rend())
		return kifNULL;
	return itr->second->Execute(contextualpattern,dom,val,rcouple);
}

KifElement* KifThis::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("This::Execute");
#endif
	if (dom->type!=kifDomain)
		return kifcode->Returnerror(kifErrorStrings[235]);
	return dom;
}


KifElement* KifIndex::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool rcouple) {
#ifdef PROFILING
	profilingcall("Index::Execute");
#endif
	KifCouple couple(NULL,ke,this,dom);
	return couple.Execute(contextualpattern,dom,this,false);
}

KifElement* KifCouple::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool rcouple) {
#ifdef PROFILING
	profilingcall("Couple::Execute");
#endif
	KifElement* kres;
	switch(recipient->type) {
	case kifVector:
		kres=((KifVector*)recipient)->Evalue(contextualpattern,domain,indexes);
		break;
	case kifMap:
		kres=((KifMap*)recipient)->Evalue(contextualpattern,domain,indexes);
		break;
	case kifList:
		kres=((KifList*)recipient)->Evalue(contextualpattern,domain,indexes);
		break;
	default:
		kres=recipient->Execute(contextualpattern,domain,indexes,rcouple);
	}
	if (kifcode!=NULL && kifcode->error==true)
		return kifNULL;
	if (indexes->function==NULL)
		return kres;
	KifIndex* kidx=indexes;
	if (kidx->function->type==kifIndex) {
		//Double indexes...
		kidx=(KifIndex*)indexes->function;
		while (kidx!=NULL) {
			//In this case, what we try to do is first to get the element with this index
			kres=kres->Execute(kifNULL,domain,kidx,false);		
			if (kidx->function!=NULL && kidx->function->type==kifIndex)
				kidx=(KifIndex*)kidx->function;
			else
				break;
		}
	}
	if (kidx->function!=NULL) {
		if (kres->type==kifDomain)
			kres=kidx->function->Execute(contextualpattern,(KifDomain*)kres,kres,rcouple);
		else
			kres=kidx->function->Execute(contextualpattern,domain,kres,rcouple);
	}
	return kres;
}

Exported KifElement* KifDomain::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* idx,bool rcouple) {
	if (idx==NULL || idx==kifNULL || declarations.find(idinterval)==declarations.end())
		return this;

	KifElement* left=idx;
	KifElement* right=NULL;
	if (idx->type==kifIndex) {
		KifIndex* kind=(KifIndex*)idx;		
		left=kind->key->Execute(kifNULL,dom);
		if (kind->interval==true)
			right=kind->right->Execute(kifNULL,dom);
	}

	KifElement* func=declarations[idinterval];
	//If such a function has been defined, we use it...
	KifCallFunctionGeneral kfunc(NULL,this,idinterval,(KifFunction*)func);
	kfunc.kifcode=kifcode;
	//We add our parameters
	kfunc.parameters.push_back(left);
	if (right!=NULL)
		kfunc.parameters.push_back(right);		
	return kfunc.Execute(kifNULL,this);
}


KifElement* KifString::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* idx,bool rcouple) {
#ifdef PROFILING
	profilingcall("String::Execute");
#endif
	if (idx==NULL || idx==kifNULL || contextualpattern==idx)
		return this;

	KifElement* ke;
	KifElement* left=idx;
	KifElement* right=NULL;
	if (idx->type==kifIndex) {
		KifIndex* kind=(KifIndex*)idx;		
		left=kind->key->Execute(kifNULL,dom);
		if (kind->interval==true)
			right=kind->right->Execute(kifNULL,dom);
	}

	ThreadLock _lock(type);
	string sc;		
	int i;

	vector<string>& lw=kifcode->lwidestring;
	lw.clear();
	conversionUTF8VersGras(value,lw,kifcode->utf8);
	int sz=lw.size();
	int ikey;
	if (left->type==kifString) {
		//then we are looking for a substring
		ikey=c_vfind(lw,left->String(),0,kifcode->utf8);
		if (ikey==-1)
			return kifNULL;
	}
	else
		ikey=left->Integer();
	if (ikey<0)
		ikey=sz+ikey;
	
	if (ikey<0 || ikey>=sz)
		return kifNULL;

	if (right==NULL) {				
		if (ikey>=sz)
			return kifNULL;
		ke=kifcode->Providestring(lw[ikey]);
		return ke;
	}
	int iright;
	if (right->type==kifString) {
		iright=c_vfind(lw,right->String(),ikey+1,kifcode->utf8);
		if (iright==-1)
			return kifNULL;
		iright+=1;
	}
	else
		iright=right->Integer();
	if (iright<0 || right==kifNULL)
		iright=sz+iright;
	else 
		if (iright>sz)
			iright=sz;

	if ((iright-ikey)<=0)
		return kifNULL;
	
	string res;
	for (i=ikey;i<iright;i++)
		res+=lw[i];
	return kifcode->Providestring(res);
}




KifElement* KifMap::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* idx,bool rcouple) {
#ifdef PROFILING
	profilingcall("Map::Execute");
#endif

	if (idx==NULL || idx==kifNULL) {
		KifElement* kv;
		//particular case, the contextualpattern is a vector, which means that we expect a set of keys
		//as a result
		if (contextualpattern->type==kifVector) {
			ThreadLock _lock(type);
			KifVector* vect=kifcode->Providevector();
			hmap<string,KifElement*>::iterator it;
			KifElement* x;
			for (it=values.begin();it!=values.end();it++) {
				x=kifcode->Providestringraw(it->first);
				x->Setreference();
				vect->values.push_back(x);
			}			
			return vect;
		}

		if (contextualpattern->type==kifInteger || contextualpattern->type==kifFloat) {
			ThreadLock _lock(type);
			kv=kifcode->Provideinteger(values.size());
			return kv;

		}
		//Then some value must be replaced with their evaluation
		if (evaluate==true) {
			KifMap* kmap=Selectmap(this,contextualpattern);
			hmap<string,KifElement*>::iterator it;
			for (it=values.begin();it!=values.end();it++) {
				string n=it->first;
				KifElement* ke=it->second;
				kv=ke->Execute(kifNULL,(KifDomain*)dom);
				//if (kv->reference==1)
				//	kv=kv->Copy(dom);
				kmap->Push(n,kv);
				//kv->Setreference();
				//kmap->values[n]=kv;
			}
			return kmap;
		}
		return this;
	}

	KifElement* key;
	if (idx->type==kifIndex) {
		KifIndex* kind=(KifIndex*)idx;		
		if (kind->interval==true)
			return kifNULL;
		key=kind->key->Execute(kifNULL,dom);
	}
	else
		key=idx->Execute(contextualpattern,dom);
	ThreadLock _lock(type);
	if (key==kifNULL)
		return kifNULL;

	string skey=key->String();
	KifElement* kval=Values(skey);
	if (kval==NULL)
		return kifNULL;
	return kval;
}

KifElement* KifMap::Evalue(KifElement* contextualpattern,KifDomain* dom,KifElement* idx) {
#ifdef PROFILING
	profilingcall("Map::Execute");
#endif

	KifElement* key;
	if (idx->type==kifIndex) {
		KifIndex* kind=(KifIndex*)idx;		
		if (kind->interval==true)
			return kifNULL;
		key=kind->key->Execute(kifNULL,dom);
	}
	else
		key=idx->Execute(contextualpattern,dom);
	ThreadLock _lock(type);
	if (key==kifNULL)
		return kifNULL;

	string skey=key->String();
	KifElement* kval=Values(skey);
	if (kval==NULL)
		return kifNULL;
	return kval;
}

KifElement* KifList::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* idx,bool rcouple) {

	if (idx==NULL || idx==kifNULL) {

		KifElement* ke;
		//In this case, we copy the elements from the vector to the map, using the position as index
		if (contextualpattern->type==kifMap) {
			ThreadLock _lock(type);
			KifMap* map=kifcode->Providemap();
			size_t i=0;
			
			list<KifElement*>::iterator it;
			for (it=values.begin();it!=values.end();it++) {
				sprintf_s(kifcode->buffer,100,"%d",i);
				ke=*it;
				map->Push(kifcode->buffer,ke);
				i++;
			}			
			return map;
		}

		if (contextualpattern->type==kifInteger || contextualpattern->type==kifFloat) {
			ThreadLock _lock(type);
			KifElement* kv=kifcode->Provideinteger(values.size());
			return kv;
		}
		//Then some values must be replaced with their evaluation
		if (evaluate==true) {
			KifList* kvect=new KifList(kifcode,NULL);
			list<KifElement*>::iterator it;
			for (it=values.begin();it!=values.end();it++) {
				ke=*it;
				KifElement* kv=ke->Execute(kifNULL,(KifDomain*)dom);
				//if (kv->reference==1)
				//	kv=kv->Copy(dom);
				kvect->Push(kv);
			}
			return kvect;
		}

		return this;
	}
	
	KifElement* key;
	KifElement* keyright=NULL;
	if (idx->type==kifIndex) {
		KifIndex* kind=(KifIndex*)idx;		
		key=kind->key->Execute(kifNULL,dom);
		if (kind->interval==true)
			keyright=kind->right->Execute(kifNULL,dom);
	}
	else
		key=idx->Execute(contextualpattern,dom);

	//if (key==kifNULL)
	//	return kifNULL;
	ThreadLock _lock(type);
	int ikey=key->Integer();
	if (ikey<0)
		ikey=values.size()+ikey;
	
	if (ikey<0 || ikey>=values.size())
		return kifNULL;

	list<KifElement*>::iterator it=values.begin();
	int i;
	for (i=0;i<ikey;i++) it++;

	if (keyright==NULL) 
		return *it;

	int iright=keyright->Integer();
	if (iright<0 || keyright==kifNULL)
		iright=values.size()+iright;
	else 
		if (iright>=values.size())
			iright=values.size();
	//In this case, we must create a new list
	KifList* kvect=new KifList(kifcode,NULL);
	for (;i<iright;i++,it++)
		kvect->Push(*it);
	return kvect;
}

KifElement* KifList::Evalue(KifElement* contextualpattern,KifDomain* dom,KifElement* idx) {
	KifElement* key;
	KifElement* keyright=NULL;
	if (idx->type==kifIndex) {
		KifIndex* kind=(KifIndex*)idx;		
		key=kind->key->Execute(kifNULL,dom);
		if (kind->interval==true)
			keyright=kind->right->Execute(kifNULL,dom);
	}
	else
		key=idx->Execute(contextualpattern,dom);

	//if (key==kifNULL)
	//	return kifNULL;
	ThreadLock _lock(type);
	int ikey=key->Integer();
	if (ikey<0)
		ikey=values.size()+ikey;
	
	if (ikey<0 || ikey>=values.size())
		return kifNULL;

	list<KifElement*>::iterator it=values.begin();
	int i;
	for (i=0;i<ikey;i++) it++;

	if (keyright==NULL) 
		return *it;

	int iright=keyright->Integer();
	if (iright<0 || keyright==kifNULL)
		iright=values.size()+iright;
	else 
		if (iright>=values.size())
			iright=values.size();
	//In this case, we must create a new list
	KifList* kvect=new KifList(kifcode,NULL);
	for (;i<iright;i++,it++)
		kvect->Push(*it);
	return kvect;
}

KifElement* KifVector::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* idx,bool rcouple) {
#ifdef PROFILING
	profilingcall("Vector::Execute");
#endif
	if (idx==NULL || idx==kifNULL) {

		KifElement* ke;
		//In this case, we copy the elements from the vector to the map, using the position as index
		if (contextualpattern->type==kifMap) {
			ThreadLock _lock(type);
			KifMap* map=kifcode->Providemap();
			size_t i=0;
			
			for (int it=0;it<values.size();it++) {
				sprintf_s(kifcode->buffer,100,"%d",i);
				ke=values[it];
				map->Push(kifcode->buffer,ke);
				i++;
			}			
			return map;
		}

		if (contextualpattern->type==kifInteger || contextualpattern->type==kifFloat) {
			ThreadLock _lock(type);
			KifElement* kv=kifcode->Provideinteger(values.size());
			return kv;
		}
		//Then some values must be replaced with their evaluation
		if (evaluate==true) {
			KifVector* kvect=Selectvector(this,contextualpattern);
			for (int it=0;it<values.size();it++) {
				ke=values[it];
				KifElement* kv=ke->Execute(kifNULL,(KifDomain*)dom);
				//if (kv->reference==1)
				//	kv=kv->Copy(dom);
				kvect->Push(kv);
			}
			return kvect;
		}

		return this;
	}
	
	KifElement* key;
	KifElement* keyright=NULL;
	if (idx->type==kifIndex) {
		KifIndex* kind=(KifIndex*)idx;		
		key=kind->key->Execute(kifNULL,dom);
		if (kind->interval==true)
			keyright=kind->right->Execute(kifNULL,dom);
	}
	else
		key=idx->Execute(contextualpattern,dom);

	//if (key==kifNULL)
	//	return kifNULL;
	ThreadLock _lock(type);
	int ikey=key->Integer();
	if (ikey<0)
		ikey=values.size()+ikey;
	
	if (ikey<0 || ikey>=values.size())
		return kifNULL;

	if (keyright==NULL) 
		return values[ikey];

	int iright=keyright->Integer();
	if (iright<0 || keyright==kifNULL)
		iright=values.size()+iright;
	else 
		if (iright>=values.size())
			iright=values.size();
	//In this case, we must create a new vector
	KifVector* kvect=Selectvector(this,contextualpattern);
	for (int i=ikey;i<iright;i++)
		kvect->Push(values[i]);
	return kvect;
}

KifElement* KifVector::Evalue(KifElement* contextualpattern,KifDomain* dom,KifElement* idx) {
#ifdef PROFILING
	profilingcall("Vector::Execute");
#endif
	KifElement* key;
	KifElement* keyright=NULL;
	if (idx->type==kifIndex) {
		KifIndex* kind=(KifIndex*)idx;		
		switch(kind->key->type) {
		case kifInteger:
		case kifFloat:
		case kifBoolean:
			key=kind->key;
			break;
		case kifInstance:
			key=((KifInstance*)kind->key)->Evalue(kifNULL,dom);
			break;
		case kifInstruction:
			switch(((KifInstruction*)kind->key)->instructiontype) {
			case kifFULLINTEGER:
				key=((KifInstruction*)kind->key)->XInteger(dom);
				break;
			case kifFULLFLOAT:
				key=((KifInstruction*)kind->key)->XFloat(dom);
				break;
			case kifFULLSTRING:
				key=((KifInstruction*)kind->key)->XString(dom);
				break;
			default:
				key=((KifInstruction*)kind->key)->Evalue(kifNULL,dom);
			}
			break;
		default:
			key=kind->key->Execute(kifNULL,dom);
		}

		//key=kind->key->Execute(kifNULL,dom);
		if (kind->interval==true) {
			switch(kind->right->type) {
			case kifInteger:
			case kifFloat:
			case kifBoolean:
				keyright=kind->right;
				break;
			case kifInstance:
				keyright=((KifInstance*)kind->right)->Evalue(kifNULL,dom);
				break;
			case kifInstruction:
				switch(((KifInstruction*)kind->right)->instructiontype) {
				case kifFULLINTEGER:
					keyright=((KifInstruction*)kind->right)->XInteger(dom);
					break;
				case kifFULLFLOAT:
					keyright=((KifInstruction*)kind->right)->XFloat(dom);
					break;
				case kifFULLSTRING:
					keyright=((KifInstruction*)kind->right)->XString(dom);
					break;
				default:
					keyright=((KifInstruction*)kind->right)->Evalue(kifNULL,dom);
				}
				break;
			default:
				keyright=kind->right->Execute(kifNULL,dom);
			}
		}
	}
	else
		key=idx->Execute(kifNULL,dom);

	//if (key==kifNULL)
	//	return kifNULL;
	ThreadLock _lock(type);
	int ikey=key->Integer();
	if (ikey<0)
		ikey=values.size()+ikey;
	
	if (ikey<0 || ikey>=values.size())
		return kifNULL;

	if (keyright==NULL) 
		return values[ikey];

	int iright=keyright->Integer();
	if (iright<0 || keyright==kifNULL)
		iright=values.size()+iright;
	else 
		if (iright>=values.size())
			iright=values.size();
	//In this case, we must create a new vector
	KifVector* kvect=Selectvector(this,contextualpattern);
	for (int i=ikey;i<iright;i++)
		kvect->Push(values[i]);
	return kvect;
}


KifElement* KifVariable::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("Variable::Execute");
#endif
	ThreadLock _lock(type);
	return value;
}


KifElement* KifVariableDeclaration::Copy(KifDomain* dom,KifElement* vartype) {
#ifdef PROFILING
	profilingcall("VariableDeclaration::Copy");
#endif
	KifElement* ke=value->Copy(NULL,vartype);
	//We look for the initial function
	ke->applyinitial(dom,initialisation);

	KifVariable* kvar=NULL;
	if (ke->Basic()) {
		if (Returnfunction()==NULL)
			kvar=new KifVariable(kifcode,NULL,ke,name);				
		else
			kvar=new KifVariableFunction(kifcode,NULL,ke,Returnfunction(),name);				
		if (vartype!=NULL)
			kvar->Setprivate(vartype->Private());
		ke->reference++;
		ke=kvar;
	}

	dom->Set(name,ke,NULL);

	if (value->type!=kifFrame) {
		if (initialisation!=kifNULL) {
			//This case is the following: we are creating a variable in a method which was launched from
			//within a frame, and this variable needs to access the frame's variables...
			if CALLFUNCTION(dom) {
				KifDomain* domframe=kifcode->Beforetop();
				if (domframe!=NULL && domframe->type==kifDomain)
					dom=domframe;
			}
			initialisation->Execute(value,dom,ke,false);
		}
	}
	return ke;
}

KifElement* KifFrameDeclaration::Copy(KifDomain* dom,KifElement* vartype) {
#ifdef PROFILING
	profilingcall("VariableDeclaration::Copy");
#endif
	KifElement* ke=value->Copy(NULL,vartype);
	//If we have frames to initialise, we might postpone them...	
	//We look for the initial function
	if (Postpone()==false) {
		//At this level, we are at the top frame initialisation...
		ke->applyinitial(dom,initialisation);	
		//If the initialisation has been delayed, then we trigger it
		//Frame initialisation is done from the mother down to the children...
		if (ke->Delayed())
			ke->ApplyDelayedInitial();
	}
	else
		ke->Setpostpone(true); //otherwise, we will call the _initial function later...

	KifVariable* kvar=NULL;
	KifElement* ret=ke;
	bool addframreference=false;
	if (ke->Basic()) {
		//TOP variables belong to only one single frame, which cannot be duplicated
		if (dom==kifcode->kstart) {
			if (Returnfunction()==NULL)
				kvar=new KifVariable(kifcode,NULL,ke,name);				
			else
				kvar=new KifVariableFunction(kifcode,NULL,ke,Returnfunction(),name);				
		}
		else {
			if (Returnfunction()==NULL)
				kvar=new KifVariableFrame(kifcode,NULL,ke,name);				
			else {
				kvar=new KifVariableFrameFunction(kifcode,NULL,ke,Returnfunction(),name);
				addframreference=true;
			}
		}
		ke->reference++;
		if (vartype!=NULL)
			kvar->Setprivate(vartype->Private());
		ret=kvar;
	}

	dom->Set(name,ret,NULL);

	if (ke->initialapplyied()==false) {
		if (initialisation!=kifNULL) {
			if (addframreference==true)
				kvar->Setframe(dom);
			//This case is the following: we are creating a variable in a method which was launched from
			//within a frame, and this variable needs to access the frame's variables...
			if CALLFUNCTION(dom) {
				ke=kifcode->Beforetop();
				if (ke!=NULL && ke->type==kifDomain)
					dom=(KifDomain*)ke;
			}
			initialisation->Execute(value,dom,ret,false);
			if (addframreference==true)
				kvar->Setframe(NULL);
		}
	}
	if (kvar!=NULL)
		kvar->Setfunction(Returnfunction());
	return ret;
}



KifElement* KifVariableDeclaration::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("VariableDeclaration::Execute");
#endif
	dom->Disableadding();

	if (type==kifVariableDeclaration) {
		if (value->type!=kifFrame) {
			if (initialisation!=kifNULL) {
				//if we are within a frame, then dom should point to that frame
				KifElement* domframe=kifcode->Beforetop();
				if (domframe!=NULL && domframe->type==kifDomain && dom==kifcode->Top())
					initialisation->Execute(value,(KifDomain*)domframe,value,false);
				else
					initialisation->Execute(value,dom,value,false);
			}
			Setreference();
			return value;
		}
	}
	KifElement* kdom=Copy(dom,this);
	return kdom;
}




KifElement* KifFunction::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("Function::Execute");
#endif

	//If the function is applied from a vector, a map, a list or an iterator, dom then contains the function parameter
	if (val==this && dom->type==kifCallFunctionPredefined) {
		KifCallFunctionGeneral kfunc(NULL,NULL,name,this);
		kfunc.kifcode=dom->kifcode;
		//We add our parameters
		for (int i=1;i<((KifCallFunctionPredefined*)dom)->parameters.size();i++)
			kfunc.parameters.push_back(((KifCallFunctionPredefined*)dom)->parameters[i]);
		return kfunc.Execute(kifNULL,dom);
	}

	KifCallFunction* callfunc=(KifCallFunction*)kifcode->Top();

	if (kifcode->error==true)
		return kifNULL;

	KifElement* returnval=kifNULL;
	
	hmap<short,KifElement*>* stacks=NULL;
	bool testdebug=kifcode->debugging;
	bool returndebug=testdebug;
	if (kifcode->infunction==false)
		kifcode->debugging=false;

	KifElement* ke;
	if (testdebug)
		testdebug=kifcode->Debugging(this,this,dom,callfunc);

	for (int i=0;i<instructions.size();i++) {
		if (kifcode->error==true)
			return kifNULL;
		ke=instructions[i];		
		kifcode->currentline=ke->Line();
		if EXECUTABLE(ke->type) {
			if (testdebug)
				testdebug=kifcode->Debugging(this,ke,dom,callfunc);
			ke->Execute(contextualpattern,dom,val,false);
			if (callfunc!=NULL && callfunc->Isreturned()) {
				returnval=callfunc->returnvalue;
				returnval->popped=true;
				break;				
			}
		}
		else {
			if (ke->Variable()) {
				//If this variable has already been declared
				if (stacks==NULL)
					stacks=new hmap<short,KifElement*>;
				(*stacks)[ke->Name()]=callfunc->Declaration(ke->Name());
				if (testdebug)
					testdebug=kifcode->Debugging(this,ke,dom,callfunc);
				ke->Execute(contextualpattern,callfunc,val,false);
			}
		}
	}	

	if (stacks!=NULL) {
		callfunc->Resetdeclaration(*stacks);
		delete stacks;
	}
	kifcode->debugging=returndebug;
	return returnval;
}

KifElement* KifPolynomial::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("Function::Execute");
#endif
	size_t i;
	string keyval;
	KifCallFunction* callfunc=(KifCallFunction*)kifcode->Top();
	if (kifcode->error==true)
		return kifNULL;

	hmap<short,KifElement*>::iterator it;
	for (it=callfunc->declarations.begin();it!=callfunc->declarations.end();it++) {
		keyval+="_";
		keyval+=it->second->String();
	}

	KifElement* kval=ReturnResult(keyval);
	if (kval!=NULL)
		return kval;

	KifElement* returnval=kifNULL;
	
	hmap<short,KifElement*>* stacks=NULL;
	bool testdebug=kifcode->debugging;
	bool returndebug=testdebug;
	if (kifcode->infunction==false)
		kifcode->debugging=false;

	KifElement* ke;
	if (testdebug)
		testdebug=kifcode->Debugging(this,this,dom,callfunc);

	for (i=0;i<instructions.size();i++) {
		if (kifcode->error==true)
			return kifNULL;
		ke=instructions[i];		
		kifcode->currentline=ke->Line();
		if EXECUTABLE(ke->type) {
			if (testdebug)
				testdebug=kifcode->Debugging(this,ke,dom,callfunc);
			ke->Execute(contextualpattern,dom,val,false);
			if (callfunc!=NULL && callfunc->Isreturned()) {
				returnval=callfunc->returnvalue;
				break;				
			}
		}
		else {
			if (ke->Variable()) {
				short thename=ke->Name();
				//If this variable has already been declared
				if (stacks==NULL)
					stacks=new hmap<short,KifElement*>;
				(*stacks)[thename]=callfunc->Declaration(thename);
				if (testdebug)
					testdebug=kifcode->Debugging(this,ke,dom,callfunc);
				ke->Execute(contextualpattern,callfunc,val,false);
			}
		}
	}
	

	if (stacks!=NULL) {
		callfunc->Resetdeclaration(*stacks);
		delete stacks;
	}
	kifcode->debugging=returndebug;
	StoreResult(keyval,returnval);
	return returnval;
}

KifElement* KifError::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("Error::Execute");
#endif
	kifcode->currentline=Line();
	KifCallFunction* callfunc=(KifCallFunction*)kifcode->Top();
	if (callfunc!=NULL)
		callfunc->Setreturnvalue(this);
	return this;
}

KifElement* KifCall::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("Call::Execute");
#endif
	kifcode->currentline=Line();
	//If we are called from outside
	if (body==NULL)
		return kifNULL;
	KifCallFunctionGeneral kfunc(NULL,this,id_call,body);
	kfunc.kifcode=kifcode;
	//We add our parameters
	for (int i=1;i<((KifCallFunctionPredefined*)dom)->parameters.size();i++)
		kfunc.parameters.push_back(((KifCallFunctionPredefined*)dom)->parameters[i]);
	return kfunc.Execute(kifNULL,domain);					
}

KifElement* KifCallFunctionCall::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
	kifcode->currentline=Line();
	KifCall* call=(KifCall*)kcall->Evalue(kifNULL,dom);
	if (call->body==NULL) 
		return kifcode->Returnerror(kifErrorStrings[232]);
	body=call->body;
	dynamicselection=false;
	if (body->next!=NULL)
		dynamicselection=true;
	return KifCallFunctionGeneral::Execute(contextualpattern,dom,val,rcouple);
}

KifElement* KifCallFunctionExternal::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("CallFunctionExternal::Execute");
#endif
	if (kifcode->error==true)
		return kifNULL;

	if (Inthread()==false) {
		int idthread=kifcode->GetThreadid();
		if (idthread!=-1) {
			//In this case, we need to create a specific input for this function
			//We need a local storage function when executing into a thread
			KifCallExecuteThreadExternal kthread(this,(KifFunction*)body,idthread);
			kthread.kifcode=kifcode;
			return kthread.KifCallFunctionExternal::Execute(contextualpattern,dom,val,rcouple);
		}
	}

	KifElement* oldcontextualpattern=environment;
	environment=contextualpattern;

	kifcode->currentline=Line();
	//This the case, when we use an external description in a dynamic library
	Initialisation();		
	KifElement* ke=body->Execute(contextualpattern,dom,val,this);
	if (function!=NULL)
		ke=applyfunction(ke);
	if (Isreturned()) {
		KifCallFunction* callfunc=(KifCallFunction*)kifcode->Top();
		callfunc->Setreturnvalue(returnvalue);
	}
	environment=oldcontextualpattern;
	return ke;
}

KifElement* KifCallFunctionPredefined::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("CallFunctionPredefined::Execute");
#endif

	if (Inthread()==false) {
		int idthread=kifcode->GetThreadid();
		if (idthread!=-1) {
			//In this case, we need to create a specific input for this function
			//We need a local storage function when executing into a thread
			KifCallExecuteThreadPredefined kthread(this,(KifFunction*)body,idthread);
			kthread.kifcode=kifcode;
			return kthread.KifCallFunctionPredefined::Execute(contextualpattern,dom,val,rcouple);
		}
	}

	KifElement* ke;		
	KifElement* oldcontextualpattern=environment;
	environment=contextualpattern;

	kifcode->currentline=Line();
	Initialisation();		
	if (selfinsert==true) {
		//KifSelf kbloc(NULL,NULL,val->Returnvalue());
		kbloc->value=val->Returnvalue();
		parameters[0]=kbloc;
		ke=body->Execute(contextualpattern,dom,val,this);
	}
	else
		ke=body->Execute(contextualpattern,dom,val,this);
	if (function!=NULL)
		ke=applyfunction(ke);

	environment=oldcontextualpattern;
	return ke;
}


Exported KifElement* KifCallExecuteThread::Arguments() {
	if (kifcode->error==true)
		return kifNULL;

	KifElement* karg;	

	kifcode->currentline=Line();
	currentbody=body;

	if (currentbody==NULL) {
		//Then we are into a vector or a map..., we need to find out which 
		//function to use
		karg=domain->Declaration(name);
		if (karg==NULL || karg->isFunction()==false || KifCheckParameters((KifFunction*)karg,this,false,&currentbody)!=0) {
			string message=kifErrorStrings[231];
			message+="'";
			message+=(*kifIdString)[name];			
			message+= "' in object of type '";			
			if (domain->Type()=="")
				message+=value->Type();
			else
				message+=domain->Type();
			message+="'";
			return kifcode->Returnerror(message);
		}		
	}
	else  {
		if (dynamicselection==true) {
			if (KifCheckParameters(body,this,false,&currentbody)!=0) {
				string message=kifErrorStrings[231];
				message+="'";
				message+=(*kifIdString)[name];			
				message+="'";
				return kifcode->Returnerror(message);
			}		
		}
		else {
			//We set the parameters
			if (currentbody->Unlimited()==false && currentbody->arguments.size()!=parameters.size()) {
				string message=kifErrorStrings[158];
				message+=(*kifIdString)[name];
				return kifcode->Returnerror(message);
			}
		}
	}

	
	size_t i;
	bool err=false;
	KifElement* kparam;
	KifElement* newarg;
	//The parameters are expressions in most encompassing frame, not the local one...
	KifDomain* anciendom=kifcode->Beforetop();
	short na;

	for (i=0;i<currentbody->arguments.size();i++) {
		//We expect some arguments in the function declaration
		KifElement* arg=currentbody->arguments[i];
		//the name of this argument
		//We then compute our parameter
		na=arg->Name();		
		karg=arg->Linkedvalue();
		kparam=parameters[i]->Execute(karg,anciendom);
		//self is always transparent
		if (karg->type==kifSelf || kparam==kifNULL)
			Set(na,kparam,&stacksparam);
		else {//Simple is: Float, integer, string or boolean
			if (karg->Simple() ||
				(karg->type==kifMap && (kparam->type==kifString || kparam->type==kifDomain)) ||
				(kparam->type==kifString && (karg->type==kifVector || karg->type==kifList))) {
				Set(na,kifNULL,&stacksparam);
				newarg=arg->Copy(this,arg);
				//Particular case. Parameters cannot be associated with functions
				newarg->Setfunction(NULL);
				newarg->Setvalue(kparam);				
			}
			else {
				//In this case, the bridges from one structure to another are rather limited...
				if (karg->type==kifFrame && kparam->type==kifDomain) {
					//if a frame is a subframe of another frame
					if (KifDerivation(karg,kparam->Frame(),true)==false) {
						//If we have a cast from one frame into another, then we use it
						if (((KifDomain*)kparam)->Declared(karg->Name())) {
							kparam=((KifDomain*)kparam)->Framedefined(karg->Name(),karg,(KifDomain*)kparam);
							//We still check that we have a proper translation
							if (kparam==NULL || karg!=kparam->Frame()) {
								err=true;
								break;
							}
						}
						else {
							err=true;
							break;
						}
					}
				}
				else {
					//otherwise, it is always an error...
					if (karg->type!=kparam->type) {
						err=true;
						break;
					}
				}
				
				Set(na,kparam,&stacksparam);
			}
		}		
	}

	//We might have an unlimited number of arguments...
	if (currentbody->Unlimited()==true) {
		string s="_";
		s+=(*kifIdString)[name];
		na=KifNewId(s);
		KifVector* kvect=kifcode->Providevector();
		Set(na,kvect,&stacksparam);
		for (;i<parameters.size();i++) {
			kparam=parameters[i]->Execute(karg,anciendom);
			kvect->Push(kparam);
		}
	}

	if (err) {
		string message=kifErrorStrings[159];
		message+=(*kifIdString)[name];
		Resetdeclaration(stacksparam);	
		return kifcode->Returnerror(message);
	}
	return currentbody;
}

Exported KifElement* KifCallExecuteThread::Execution() {
	if (kifcode->error==true)
		return kifNULL;

	Initialisation();
	KifElement* karg;	
	KifElement* oldcontextualpattern=environment;
	environment=context;

	kifcode->currentline=Line();
	currentbody->kifcode->Push(domain);
	currentbody->kifcode->Push(this);
	karg=currentbody->Execute(context,domain,value,false);
	if (function!=NULL)
		karg=applyfunction(karg);
	currentbody->kifcode->Pop();
	currentbody->kifcode->Pop();

	environment=oldcontextualpattern;
	Resetdeclaration(stacksparam);	
	Initialisation();
	karg->Setpopped();
	kifcode->Garbage();
	return karg;
}

KifElement* KifCallFunctionGeneral::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {

	if (kifcode->error==true)
		return kifNULL;

	if (Inthread()==false) {
		int idthread=kifcode->GetThreadid();
		if (idthread!=-1) {
			//In this case, we need to create a specific input for this function
			//We need a local storage function when executing into a thread
			KifCallExecuteThread kthread(NULL,this,body,idthread);
			kthread.kifcode=kifcode;
			return kthread.KifCallFunctionGeneral::Execute(contextualpattern,dom,val,rcouple);
		}
	}

	KifElement* karg;	
#ifdef _DEBUG	
	string functionname=(*kifIdString)[name];			
#endif
	KifElement* oldcontextualpattern=environment;
	environment=contextualpattern;

	kifcode->currentline=Line();
	KifFunction* bd=body;
	Initialisation();

	if (bd==NULL) {
		//Then we are into a vector or a map..., we need to find out which 
		//function to use
		karg=dom->Declaration(name);
		if (karg==NULL || karg->isFunction()==false || KifCheckParameters((KifFunction*)karg,this,false,&bd)!=0) {
			string message=kifErrorStrings[231];
			message+="'";
			message+=(*kifIdString)[name];			
			message+= "' in object of type '";			
			if (dom->Type()=="")
				message+=val->Type();
			else
				message+=dom->Type();
			message+="'";
			return kifcode->Returnerror(message);
		}		
	}
	else  {
		if (dynamicselection==true) {
			if (KifCheckParameters(body,this,false,&bd)!=0) {
				string message=kifErrorStrings[231];
				message+="'";
				message+=(*kifIdString)[name];			
				message+="'";
				return kifcode->Returnerror(message);
			}		
		}
		else {
			//We set the parameters
			if (bd->Unlimited()==false && bd->arguments.size()!=parameters.size()) {
				string message=kifErrorStrings[158];
				message+=(*kifIdString)[name];
				return kifcode->Returnerror(message);
			}
		}
	}

	hmap<short,KifElement*> stacksparam;
	size_t i;
	bool err=false;
	KifElement* kparam;
	KifElement* newarg;
	//The parameters are expressions in most encompassing frame, not the local one...
	KifDomain* anciendom=kifcode->Beforetop();
	short na;

	for (i=0;i<bd->arguments.size();i++) {
		//We expect some arguments in the function declaration
		KifElement* arg=bd->arguments[i];
		//the name of this argument
		//We then compute our parameter
		na=arg->Name();		
		karg=arg->Linkedvalue();
		kparam=parameters[i]->Execute(karg,anciendom);
		//self is always transparent
		if (karg->type==kifSelf || kparam==kifNULL)
			Set(na,kparam,&stacksparam);
		else {//Simple is: Float, integer, string or boolean
			if (karg->Simple() ||
				(karg->type==kifMap && (kparam->type==kifString || kparam->type==kifDomain)) ||
				(kparam->type==kifString && (karg->type==kifVector || karg->type==kifList))) {
				Set(na,kifNULL,&stacksparam);
				newarg=arg->Copy(this,arg);
				//Particular case. Parameters cannot be associated with functions
				newarg->Setfunction(NULL);
				newarg->Setvalue(kparam);				
			}
			else {
				//In this case, the bridges from one structure to another are rather limited...
				if (karg->type==kifFrame && kparam->type==kifDomain) {
					//if a frame is a subframe of another frame
					if (KifDerivation(karg,kparam->Frame(),true)==false) {
						//If we have a cast from one frame into another, then we use it
						if (((KifDomain*)kparam)->Declared(karg->Name())) {
							kparam=((KifDomain*)kparam)->Framedefined(karg->Name(),karg,(KifDomain*)kparam);
							//We still check that we have a proper translation
							if (kparam==NULL || karg!=kparam->Frame()) {
								err=true;
								break;
							}
						}
						else {
							err=true;
							break;
						}
					}
				}
				else {
					//otherwise, it is always an error...
					if (karg->type!=kparam->type) {
						err=true;
						break;
					}
				}
				
				Set(na,kparam,&stacksparam);
			}
		}		
	}

	//We might have an unlimited number of arguments...
	if (bd->Unlimited()==true) {
		string s="_";
		s+=(*kifIdString)[name];
		na=KifNewId(s);
		KifVector* kvect=kifcode->Providevector();
		Set(na,kvect,&stacksparam);
		for (;i<parameters.size();i++) {
			kparam=parameters[i]->Execute(karg,anciendom);
			kvect->Push(kparam);
		}
	}

	if (err==false) {
		bd->kifcode->Push(dom);
		bd->kifcode->Push(this);
		karg=bd->Execute(contextualpattern,dom,val,false);
		if (function!=NULL)
			karg=applyfunction(karg);
		bd->kifcode->Pop();
		bd->kifcode->Pop();
	}
	else {
		string message=kifErrorStrings[159];
		message+=(*kifIdString)[name];
		karg=kifcode->Returnerror(message);
	}

	environment=oldcontextualpattern;
	Resetdeclaration(stacksparam);	
	Initialisation();
	karg->Setpopped();
	kifcode->Garbage();
	return karg;
}

KifElement* KifInstance::Evalue(KifElement* contextualpattern,KifDomain* dom) {
#ifdef PROFILING
	profilingcall("KifInstance::Evalue");
#endif

	if (newinstance==kinKnown)
		return current_value->Returnvalue();
	
	KifElement* v=NULL;
	bool keep=false;
	if (current_value==NULL) {
		//An External Global variable (from XIP)
		KifDomain* func;

		switch(newinstance) {
		case kinFunction:
			func=kifcode->Top();
			v=func->Declared(name);
			break;
		case kinFrame:
			v=dom->Declared(name);
			break;
		case kinKnownFrame:
			v=dom->Declared(name);
			current_value=v;
			break;
		case kinGlobal:
			v=kifcode->kstart->Declared(name);
			current_value=v;
			keep=true;
			break;
		default:
			if (declaration->type==kifVariableDeclaration) {
				if (index!=NULL) {				
					if (kifThreadControl.kifnbthreads==0)
						couple=bcouple;
					else
						couple=new KifCouple(kifcode,kifNULL,index,NULL);
					couple->recipient=declaration->value->Returnvalue();
					couple->domain=dom;
					return couple->Execute(contextualpattern,dom,index,false);
				}
				return declaration->value->Returnvalue();
			}
			KifDomain* stackdom=kifcode->Beforetop();	

			if (dom!=stackdom)
				v=dom->Declared(name);

			if (v==NULL) {
				func=kifcode->Top();
				if (func!=NULL)
					v=func->Declared(name);
				if (v==NULL) {							
					if (stackdom!=NULL)
						v=stackdom->Declared(name);
					if (v==NULL && dom!=kifcode->kstart) {
						v=kifcode->kstart->Declared(name);
						keep=true;
						current_value=v;
					}
					else
						if (stackdom==kifcode->kstart) {
							current_value=v;
							keep=true;
						}
						else
							newinstance=kinFrame;
				}
				else
					newinstance=kinFunction;
			}
			else
				if (dom==kifcode->kstart) {
					keep=true;
					current_value=v;
				}
				else 
					newinstance=kinFrame;
		}
		if (v==NULL) {
			string mess=kifErrorStrings[183]+(*kifIdString)[name];
			return kifcode->Returnerror(mess);
		}
		if (v->Localvariable()) {
			current_value=NULL;
			keep=false;
		}
	}
	else	
		v=current_value;

	
	v=v->Returnvalue();

	if (value->type==kifInstance || value->type==kifInstanceFunction) {
		if (v->isDomain()==false) {
			string mess=kifErrorStrings[183]+(*kifIdString)[name];
			return kifcode->Returnerror(mess);
		}
		if (keep==true && value->type==kifInstance)
			((KifInstance*)value)->newinstance=kinKnownFrame;
		return value->Execute(contextualpattern,(KifDomain*)v);
	}

	if (index!=NULL) {
		if (kifThreadControl.kifnbthreads==0)
			couple=bcouple;
		else
			couple=new KifCouple(kifcode,kifNULL,index,NULL);
		couple->recipient=v->Returnvalue();
		couple->domain=dom;
		return couple->Execute(contextualpattern,dom,index,false);
	}

	if (keep==true || newinstance==kinKnownFrame)
		newinstance=kinKnown;

	return v;
}

KifElement* KifInstance::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("KifInstance::Evalue");
#endif

	if (newinstance==kinKnown) {
		if (rcouple==false)
			return current_value->Returnvalue();
		else
			return current_value;
	}


	KifElement* v=NULL;
	bool keep=false;	
	if (current_value==NULL) {
		KifDomain* func;
		switch(newinstance) {
		case kinFunction:
			func=kifcode->Top();
			v=func->Declared(name);
			break;
		case kinFrame:
			v=dom->Declared(name);
			break;
		case kinKnownFrame:
			v=dom->Declared(name);
			current_value=v;
			break;
		case kinGlobal:
			v=kifcode->kstart->Declared(name);
			current_value=v;
			keep=true;
			break;
		default:
			//An External Global variable (from XIP)
			if (declaration->type==kifVariableDeclaration) {
				if (index!=NULL) {		
					if (kifThreadControl.kifnbthreads==0)
						couple=bcouple;
					else
						couple=new KifCouple(kifcode,kifNULL,index,NULL);

					couple->recipient=declaration->value->Returnvalue();
					couple->domain=dom;
					if (rcouple)
						return couple;
					else
						return couple->Execute(contextualpattern,dom,index,false);
				}
				if (rcouple==false)
					return declaration->value->Returnvalue();
				return declaration;
			}
			KifDomain* stackdom=kifcode->Beforetop();	

			if (dom!=stackdom)
				v=dom->Declared(name);

			if (v==NULL) {
				func=kifcode->Top();
				if (func!=NULL)
					v=func->Declared(name);
				if (v==NULL) {
					if (stackdom!=NULL)
						v=stackdom->Declared(name);
					if (v==NULL && dom!=kifcode->kstart) {
						v=kifcode->kstart->Declared(name);
						keep=true;
						current_value=v;
					}
					else
						if (stackdom==kifcode->kstart) {
							current_value=v;
							keep=true;
						}
						else
							newinstance=kinFrame;
				}
				else 
					newinstance=kinFunction;
			}
			else
				if (dom==kifcode->kstart) {
					current_value=v;
					keep=true;
				}
				else
					newinstance=kinFrame;
		}

		if (v==NULL) {
			string mess=kifErrorStrings[183]+(*kifIdString)[name];
			return kifcode->Returnerror(mess);
		}
		if (v->Localvariable()) {
			current_value=NULL;
			keep=false;
		}
	}
	else	
		v=current_value;

	
	if (value->type==kifInstance || value->type==kifInstanceFunction) {
		v=v->Returnvalue();
		if (v->isDomain()==false) {
			string mess=kifErrorStrings[183]+(*kifIdString)[name];
			return kifcode->Returnerror(mess);
		}
		if (keep==true && value->type==kifInstance)
			((KifInstance*)value)->newinstance=kinKnownFrame;
		return value->Execute(contextualpattern,(KifDomain*)v,val,rcouple);
	}


	if (index!=NULL) {		
		if (kifThreadControl.kifnbthreads==0)
			couple=bcouple;
		else
			couple=new KifCouple(kifcode,kifNULL,index,NULL);
		couple->recipient=v->Returnvalue();
		couple->domain=dom;
		if (rcouple)
			return couple;
		else
			return couple->Execute(contextualpattern,dom,index,false);
	}

	if (keep==true || newinstance==kinKnownFrame)
		newinstance=kinKnown;

	if (rcouple==false)
		return v->Returnvalue();

	return v;
}


KifElement* KifInstance::Thevariable(KifDomain* dom) {
	if (newinstance==kinKnown)
		return current_value;


	KifElement* v=NULL;
	bool keep=false;	
	if (current_value==NULL) {
		KifDomain* func;
		switch(newinstance) {
		case kinFunction:
			func=kifcode->Top();
			v=func->Declared(name);
			break;
		case kinFrame:
			v=dom->Declared(name);
			break;
		case kinKnownFrame:
			v=dom->Declared(name);
			current_value=v;
			break;
		case kinGlobal:
			v=kifcode->kstart->Declared(name);
			current_value=v;
			keep=true;
			break;
		default:
			//An External Global variable (from XIP)
			if (declaration->type==kifVariableDeclaration) {
				if (index!=NULL) {
					if (kifThreadControl.kifnbthreads==0)
						couple=bcouple;
					else
						couple=new KifCouple(kifcode,kifNULL,index,NULL);
					couple->recipient=declaration->value->Returnvalue();
					couple->domain=dom;
					return couple;
				}
				return declaration;
			}
			KifDomain* stackdom=kifcode->Beforetop();	

			if (dom!=stackdom)
				v=dom->Declared(name);

			if (v==NULL) {
				func=kifcode->Top();
				if (func!=NULL)
					v=func->Declared(name);
				if (v==NULL) {							
					if (stackdom!=NULL)
						v=stackdom->Declared(name);
					if (v==NULL && dom!=kifcode->kstart) {
						v=kifcode->kstart->Declared(name);
						keep=true;
						current_value=v;
					}
					else
						if (stackdom==kifcode->kstart) {
							current_value=v;
							keep=true;
						}
						else
							newinstance=kinFrame;
				}
				else 
					newinstance=kinFunction;
			}
			else
				if (dom==kifcode->kstart) {
					keep=true;
					current_value=v;
				}
				else
					newinstance=kinFrame;
		}

		if (v==NULL) {
			string mess=kifErrorStrings[183]+(*kifIdString)[name];
			return kifcode->Returnerror(mess);
		}
		if (v->Localvariable()) {
			current_value=NULL;
			keep=false;
		}
	}
	else	
		v=current_value;


	if (value->type==kifInstance) {
		v=v->Returnvalue();
		if (v->isDomain()==false) {
			string mess=kifErrorStrings[183]+(*kifIdString)[name];
			return kifcode->Returnerror(mess);
		}
		if (keep==true)
			((KifInstance*)value)->newinstance=kinKnownFrame;
		return value->Execute(kifNULL,(KifDomain*)v,kifNULL,true);
	}


	if (index!=NULL) {
		if (kifThreadControl.kifnbthreads==0)
			couple=bcouple;
		else
			couple=new KifCouple(kifcode,kifNULL,index,NULL);
		couple->recipient=v->Returnvalue();
		couple->domain=dom;
		return couple;
	}

	if (keep==true || newinstance==kinKnownFrame)
		newinstance=kinKnown;

	return v;
}


Exported KifElement* KifPredefined::Execute(KifElement* a,KifDomain* b,KifElement* c,KifCallFunction* d) {
	return (*function)(a,b,d);
}

KifElement* KifInstanceFunction::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* val,bool rcouple) {
#ifdef PROFILING
	profilingcall("InstanceFunction::Execute");
#endif
	kifcode->currentline=Line();

	KifElement* v=NULL;
	KifDomain* stackdom;
	
	if (current_value==NULL) {
		KifDomain* func;
		switch(newinstance) {
		case kinFunction:
			func=kifcode->Top();
			v=func->Declared(name);
			break;
		case kinFrame:
			v=dom->Declared(name);
			break;
		case kinGlobal:
			v=kifcode->kstart->Declared(name);
			current_value=v;
			break;
		default:
			stackdom=kifcode->Beforetop();	

			if (dom!=stackdom)
				v=dom->Declared(name);

			if (v==NULL) {
				func=kifcode->Top();
				if (func!=NULL)
					v=func->Declared(name);
				if (v==NULL) {							
					if (stackdom!=NULL)
						v=stackdom->Declared(name);
					if (v==NULL && dom!=kifcode->kstart) {
						v=kifcode->kstart->Declared(name);
						current_value=v;
					}
					else {
						if (stackdom==kifcode->kstart)
							current_value=v;
						else
							newinstance=kinFrame;
					}
				}
				else 
					newinstance=kinFunction;
			}
			else
				if (dom==kifcode->kstart)
					current_value=v;
				else
					newinstance=kinFrame;
		}

		if (v==NULL) {
			string mess=kifErrorStrings[183]+(*kifIdString)[name];
			return kifcode->Returnerror(mess);
		}
		if (v->Localvariable())
			current_value=NULL;
	}
	else	
		v=current_value;

	
	v=v->Returnvalue();
	if (function->selfinsert==true) {
		//In this case, we use the value as the value itself
		if (v->Linkedvalue()!=kifNULL)
			v=v->Linkedvalue();
		v=function->Execute(contextualpattern,dom,v,false);
		return v;
	}

	//We detect the sub frame declarations
	if (v->isDomain()==false) {
		string mess=kifErrorStrings[183]+(*kifIdString)[function->Name()];
		return kifcode->Returnerror(mess);
	}
	return function->Execute(contextualpattern,(KifDomain*)v,val,false);
}

//-----------------------------------------------------------------------------------------------------------------
//Instruction methods
KifInstruction::KifInstruction(KifCode* klc,KifElement* kp,KifOperator kop) : KifObjectInstruction(klc,NULL,kifInstruction) {	
	action=kop;
	negation=false;
	parent=kp;
	root=NULL;
	if (kp!=NULL)
		kp->Add(this);
}



KifElement* KifInstructionPARAMETER::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool rcouple) {//A parameter
	kifcode->currentline=Line();
	if (kifcode->error==true)
		return kifNULL;
	
	if (dom!=NULL) {
		switch(instructiontype) {
		case kifFULLINTEGER:
			return XInteger(dom);
		case kifFULLFLOAT:
			return XFloat(dom);
		case kifFULLSTRING:
			return XString(dom);
		}
	}
	return instructions[0]->Execute(contextualpattern,dom,ke,rcouple);
}

//-----------------------------------------------------------------------------------------------------------------
KifElement* KifInstruction::INITIALISATION(KifDomain* dom,KifElement* var) {
#ifdef PROFILING
	profilingcall("Instruction::INITIALISATION");
#endif
	//first, we get the target element where to store our result
	KifElement* val=var->Returnvalue();
	KifElement* result;
	if (instructions[0]->type==kifSelf) {
		//One single horrible case... var is a KifCall
		//then we might expect the initialisation to be done with a function
		if (val->type!=kifCall)			
			return kifcode->Returnerror(kifErrorStrings[160]);
	}

	bool evalue=true;
	KifType directvalue=kifAny;
	if (var->Function()==false) {
		switch(val->type) {
		case kifVector:
			((KifVector*)val)->evaluate=true;
			evalue=false;
			break;
		case kifList:
			((KifList*)val)->evaluate=true;
			evalue=false;
			break;
		case kifMap:
			((KifMap*)val)->evaluate=true;
			evalue=false;
			break;
		default:		
			directvalue=val->type;
		}
	}
	
	//In the case of a function attached to a variable, we do not want to loose the initial value for maps and vectors
	switch(instructions[0]->type) {
	case kifInteger:
	case kifFloat:
	case kifBoolean:
		result=instructions[0];
		break;
	case kifInstance:
		result=((KifInstance*)instructions[0])->Evalue(val,dom);
		break;
	case kifInstruction:
		switch(((KifInstruction*)instructions[0])->instructiontype) {
		case kifFULLINTEGER:
			result=((KifInstruction*)instructions[0])->XInteger(dom);
			break;
		case kifFULLFLOAT:
			result=((KifInstruction*)instructions[0])->XFloat(dom);
			break;
		case kifFULLSTRING:
			result=((KifInstruction*)instructions[0])->XString(dom);
			break;
		default:
			result=((KifInstruction*)instructions[0])->Evalue(val,dom);
		}
		break;
	default:
		result=instructions[0]->Execute(val,dom);
	}

	if (evalue==false) {
		switch(val->type) {
		case kifVector:
			((KifVector*)val)->evaluate=false;
			break;
		case kifList:
			((KifList*)val)->evaluate=false;
			break;
		case kifMap:
			((KifMap*)val)->evaluate=false;
		}
	}

	switch(directvalue) {
	case kifInteger:
		((KifInteger*)val)->value=result->Integer();
		break;
	case kifFloat:
		((KifFloat*)val)->value=result->Float();
		break;
	case kifBoolean:
		((KifBoolean*)val)->value=result->Boolean();
		break;
	case kifString:
		((KifString*)val)->value=result->String();
		break;
	default:
		var->Setvalue(result,NULL,dom);
	}
	return var;
}

KifElement* KifInstruction::AFFECTATION(KifDomain* dom) {
#ifdef PROFILING
	profilingcall("Instruction::AFFECTATION");
#endif
	KifElement* result;

	KifElement* var=((KifInstance*)instructions[0])->Thevariable(dom);

	KifElement* val=var->Returnvalue();
	//In the case of a function attached to a variable, we do not want to loose the initial value for maps and vectors
	//Toassign is a way to avoid creating a new map or new vector, when in fact the placeholder is modifying itself...
	bool evalue=true;
	KifType directvalue=kifAny;
	if (var->Function()==false) {
		switch(val->type) {
		case kifVector:
			((KifVector*)val)->evaluate=true;
			evalue=false;
			break;
		case kifList:
			((KifList*)val)->evaluate=true;
			evalue=false;
			break;
		case kifMap:
			((KifMap*)val)->evaluate=true;
			evalue=false;
			break;
		default:		
			directvalue=val->type;
		}
	}

	switch(instructions[1]->type) {
	case kifInteger:
	case kifFloat:
	case kifBoolean:
		result=instructions[1];
		break;
	case kifInstance:
		result=((KifInstance*)instructions[1])->Evalue(val,dom);
		break;
	case kifInstruction:
		switch(((KifInstruction*)instructions[1])->instructiontype) {
		case kifFULLINTEGER:
			result=((KifInstruction*)instructions[1])->XInteger(dom);
			break;
		case kifFULLFLOAT:
			result=((KifInstruction*)instructions[1])->XFloat(dom);
			break;
		case kifFULLSTRING:
			result=((KifInstruction*)instructions[1])->XString(dom);
			break;
		default:
			result=((KifInstruction*)instructions[1])->Evalue(val,dom);
		}
		break;
	default:
		result=instructions[1]->Execute(val,dom);
	}

	if (evalue==false) {
		switch(val->type) {
		case kifVector:
			((KifVector*)val)->evaluate=false;
			break;
		case kifList:
			((KifList*)val)->evaluate=false;
			break;
		case kifMap:
			((KifMap*)val)->evaluate=false;
		}
	}

	switch(directvalue) {
	case kifInteger:
		((KifInteger*)val)->value=result->Integer();
		break;
	case kifFloat:
		((KifFloat*)val)->value=result->Float();
		break;
	case kifBoolean:
		((KifBoolean*)val)->value=result->Boolean();
		break;
	case kifString:
		((KifString*)val)->value=result->String();
		break;
	default:
		if (var->Setvalue(result,NULL,dom)==false) {
			//This is a specific KifSelf element, created in KifParseCall
			//The value is the FRAME definition (and not a frame instance)
			//Setvalue with this element triggers the creation of a new instance
			//which we must initialise. parameter stows the parameters of the _initial function
			//pointer.
			val=var->Returnvalue();
			KifSelf* self=(KifSelf*)instructions[1];
			//we call
			val->applyinitial(dom,self->parameter);
			if (val->Delayed())
				val->ApplyDelayedInitial();
				//then we also disable the delayed on the top frame variable...
			dom->Resetdelayed();
		}
	}
	return var;
}

inline KifElement* KifInstruction::PLUSPLUS(KifDomain* dom) {
	KifElement* var;
	switch(instructions[0]->type) {
	case kifInstance:
		var=((KifInstance*)instructions[0])->Thevariable(dom);
		break;
	default:
		var=instructions[0]->Execute(kifNULL,dom,NULL,true);
	}

	if (var->Function()) {
		KifElement* val=var->Returnvalue();
		val->plusplus();
		var->callfunction(val,val,dom);
		var=val;
	}
	else {
		var=var->Returnvalue();
		var->plusplus();
	}
	return var;
}

inline KifElement* KifInstruction::MINUSMINUS(KifDomain* dom) {
	KifElement* var;
	switch(instructions[0]->type) {
	case kifInstance:
		var=((KifInstance*)instructions[0])->Thevariable(dom);
		break;
	default:
		var=instructions[0]->Execute(kifNULL,dom,NULL,true);
	}

	
	if (var->Function()) {
		KifElement* val=var->Returnvalue();
		val->minusminus();
		var->callfunction(val,val,dom);
		var=val;
	}
	else {
		var=var->Returnvalue();
		var->minusminus();
	}
	return var;
}

inline KifElement* KifInstruction::BLOCBOOLEAN(KifElement* contextualpattern,KifDomain* dom) {
#ifdef PROFILING
	profilingcall("Instruction::BLOCBOOLEAN");
#endif//A bloc in parentheses
	switch(instructions[0]->type) {
	case kifInteger:
	case kifFloat:
	case kifBoolean:
		return instructions[0];
	case kifInstance:
		return ((KifInstance*)instructions[0])->Evalue(contextualpattern,dom);
	}
	return instructions[0]->Execute(contextualpattern,dom);	
}

int compte=0;

inline KifElement* KifInstruction::KIFIN(KifElement* contextualpattern,KifDomain* dom) {
#ifdef PROFILING
	profilingcall("Instruction::KIFIN");	
#endif
	KifElement* ke=instructions[0]->Execute(kifNULL,dom,kifNULL);
	ke->Setpopped();
	KifElement* result=instructions[1]->Execute(kifNULL,dom,kifNULL);
	if (instructions.size()==3) {
		KifFunction* func=instructions[2]->Functioncall(dom);
		if (func==NULL) {
			string message="Empty call function";
			return kifcode->Returnerror(message);
		}
		return contextualpattern->in(ke,result,func,contextualpattern,false);
	}
	return contextualpattern->in(ke,result,NULL,contextualpattern,false);
}


inline KifElement* KifInstruction::COMPARE(KifDomain* dom) {
	KifElement* ke;
	switch(instructions[0]->type) {
	case kifInteger:
	case kifFloat:
	case kifBoolean:
	case kifString:
		ke=instructions[0];
		break;
	case kifInstance:
		ke=((KifInstance*)instructions[0])->Evalue(kifNULL,dom);
		ke->Setpopped();
		break;
	default:
		ke=instructions[0]->Execute(kifNULL,dom);
		ke->Setpopped();
	}

	KifElement* result;
	switch(instructions[1]->type) {
	case kifInteger:
	case kifFloat:
	case kifBoolean:
	case kifString:
		result=instructions[1];
		break;
	case kifInstance:
		result=((KifInstance*)instructions[1])->Evalue(ke,dom);
		break;
	default:
		result=instructions[1]->Execute(ke,dom);
	}

	switch(action) {
	case kifEQUAL:
		return ke->same(result);
	case kifSUPERIOR:
		return ke->more(result);			
	case kifINFERIOR:
		return ke->less(result);			
	case kifSUPEQU:
		return ke->moreequal(result);			
	case kifINFEQU:
		return ke->lessequal(result);			
	case kifDIFFERENT:
		return ke->different(result);
	}	
	return kifFALSE;
}



KifElement* KifInstruction::OR(KifDomain* dom) {
#ifdef PROFILING
	profilingcall("Instruction::OR");
#endif
	KifElement* result;
	for (int i=0;i<instructions.size();i+=1) {
		result=instructions[i]->Execute(kifTRUE,dom);
		if (result->Boolean()==true)
			return kifTRUE;
	}
	return kifFALSE;
}

KifElement* KifInstruction::AND(KifDomain* dom) {
#ifdef PROFILING
	profilingcall("Instruction::AND");
#endif
	KifElement* result;
	for (int i=0;i<instructions.size();i+=1) {
		result=instructions[i]->Execute(kifTRUE,dom);
		if (result->Boolean()==false)
			return kifFALSE;
	}
	return kifTRUE;
}

KifElement* KifInstruction::KIFEQU(KifDomain* dom) {
	KifElement* val=instructions[0]->Execute(kifNULL,dom);
	val->Setpopped();
	KifElement* result;
	KifInstruction* ins=(KifInstruction*)instructions[1];
	switch(ins->instructiontype) {
	case kifFULLINTEGER:
		result=ins->XInteger(dom);
		break;
	case kifFULLFLOAT:
		result=ins->XFloat(dom);
		break;
	case kifFULLSTRING:
		result=ins->XString(dom);
		break;
	default:
		result=ins->Evalue(val,dom);
	}
	switch (action) {
	case kifINTERSECTIONEQU:
		val->andset(val,result,true);
		break;
	case kifUNIONEQU:
		val->orset(val,result,true);
		break;
	case kifXOREQU:
		val->xorset(val,result,true);
		break;
	case kifPLUSEQU:
		val->plus(val,result,true);
		break;
	case kifMINUSEQU:
		val->minus(val,result,true);
		break;
	case kifMULTIPLYEQU:
		val->multiply(val,result,true);
		break;
	case kifDIVIDEEQU:
		val->divide(val,result,true);
		break;
	case kifMODEQU:
		val->mod(val,result,true);
		break;
	case kifPOWEREQU:
		val->power(val,result,true);
		break;
	case kifSHIFTRIGHTEQU:
		val->shiftright(val,result,true);
		break;
	case kifSHIFTLEFTEQU:
		val->shiftleft(val,result,true);
		break;
	}
	return val;
}


KifElement* KifInstruction::APPLYOPERATIONEQU(KifDomain* dom) {
	KifElement* var=instructions[0]->Execute(kifNULL,dom,NULL,true);
	KifElement* val=var->Returnvalue();

	KifElement* result=kifNULL;
	KifElement* ins;

	for (int i=1;i<instructions.size();i++) {
		ins=instructions[i];
		switch(ins->type) {
		case kifInteger:
		case kifFloat:
		case kifBoolean:
			result=ins;
			break;
		case kifInstance:
			result=((KifInstance*)ins)->Evalue(val,dom);
			break;
		case kifInstruction:
			if (ins->Action()>=kifPLUS && ins->Action()<=kifINTERSECTION) {
				result=((KifInstruction*)ins)->APPLYOPERATION(val,dom);
				break;
			}
		default:
			result=ins->Execute(val,dom,result,false);
		}
	}

	switch (action) {
	case kifINTERSECTIONEQU:
		val->andset(val,result,true);
		break;
	case kifUNIONEQU:
		val->orset(val,result,true);
		break;
	case kifXOREQU:
		val->xorset(val,result,true);
		break;
	case kifPLUSEQU:
		val->plus(val,result,true);
		break;
	case kifMINUSEQU:
		val->minus(val,result,true);
		break;
	case kifMULTIPLYEQU:
		val->multiply(val,result,true);
		break;
	case kifDIVIDEEQU:
		val->divide(val,result,true);
		break;
	case kifMODEQU:
		val->mod(val,result,true);
		break;
	case kifPOWEREQU:
		val->power(val,result,true);
		break;
	case kifSHIFTRIGHTEQU:
		val->shiftright(val,result,true);
		break;
	case kifSHIFTLEFTEQU:
		val->shiftleft(val,result,true);
		break;
	}

	if (var->Function())
		var->callfunction(val,val,dom);
	return val;
}

KifElement* KifInstruction::APPLYOPERATION(KifElement* contextualpattern,KifDomain* dom) {
	bool autoself=false;
	KifElement* result;
	KifElement* val;
	KifElement* ins=instructions[0];
	
	switch(ins->type) {
	case kifInteger:
	case kifFloat:
	case kifBoolean:
		val=ins;
		break;
	case kifInstance:
		val=((KifInstance*)ins)->Evalue(contextualpattern,dom);
		break;
	case kifInstruction:
		if (ins->Action()>=kifPLUS && ins->Action()<=kifINTERSECTION) {
			val=((KifInstruction*)ins)->APPLYOPERATION(contextualpattern,dom);
			break;
		}
	default:
		val=ins->Execute(contextualpattern,dom);
	}

	if (val->reference==0 && ins->Action()!=kifBLOC) {
		autoself=true;		
		contextualpattern=val;
	}

	//In the case of a bloc, we use val as the new context
	if (contextualpattern==kifNULL)
		contextualpattern=val;

	for (int i=1;i<instructions.size();i++) {
		ins=instructions[i];
		switch(ins->type) {
		case kifInteger:
		case kifFloat:		
		case kifBoolean:
			result=ins;
			break;
		case kifInstance:
			result=((KifInstance*)ins)->Evalue(contextualpattern,dom);
			break;
		case kifInstruction:
			if (ins->Action()>=kifPLUS && ins->Action()<=kifINTERSECTION) {
				result=((KifInstruction*)ins)->APPLYOPERATION(contextualpattern,dom);
				break;
			}
		default:
			result=ins->Execute(contextualpattern,dom);
		}

		switch (action) {
		case kifINTERSECTION:
			val=contextualpattern->andset(val,result,autoself);
			break;
		case kifUNION:
			val=contextualpattern->orset(val,result,autoself);
			break;
		case kifXOR:
			val=contextualpattern->xorset(val,result,autoself);
			break;
		case kifPLUS:
			val=contextualpattern->plus(val,result,autoself);
			break;
		case kifMINUS:
			val=contextualpattern->minus(val,result,autoself);
			break;
		case kifMULTIPLY:
			val=contextualpattern->multiply(val,result,autoself);
			break;
		case kifDIVIDE:
			val=contextualpattern->divide(val,result,autoself);
			break;
		case kifMOD:
			val=contextualpattern->mod(val,result,autoself);
			break;
		case kifPOWER:
			val=contextualpattern->power(val,result,autoself);
			break;
		case kifSHIFTRIGHT:
			val=contextualpattern->shiftright(val,result,autoself);
			break;
		case kifSHIFTLEFT:
			val=contextualpattern->shiftleft(val,result,autoself);
			break;
		}
		autoself=true;		
		contextualpattern=val;
	}
	return val;
}

long KifChild::ExecuteInteger() {
	long valres;
	long val;
	KifNumber* kn=values[0];
	KifValue* kval=kn->value;

	
	if (kn->type==ckifInteger)
		val=((KifIntegerValue*)kval)->value;
	else {
		if (op==kifBLOC && instructiontype!=kifFULLINTEGER) {
			if (instructiontype==kifFULLSTRING) {
				string v;
				values[0]->child->ExecuteString(v);
				val=atoi(STR(v));
			}
			else
				val=kn->child->ExecuteFloat();
		}
		else
			val=kn->child->ExecuteInteger();
	}

	for (int i=1;i<values.size();i++) {
	    kn=values[i];
		kval=kn->value;

		if (kn->type==ckifInteger)
			valres=((KifIntegerValue*)kval)->value;
		else {
			if (op==kifBLOC && instructiontype!=kifFULLINTEGER) {
				if (instructiontype==kifFULLSTRING) {
					string v;
					values[0]->child->ExecuteString(v);
					valres=atoi(STR(v));
				}
				else
					valres=kn->child->ExecuteFloat();
			}
			else
				valres=kn->child->ExecuteInteger();
		}

		switch (op) {
		case kifINTERSECTION:
			val&=valres;
			break;
		case kifUNION:
			val|=valres;
			break;
		case kifXOR:
			val^=valres;
			break;
		case kifPLUS:
			val+=valres;
			break;
		case kifMINUS:
			val-=valres;
			break;
		case kifMULTIPLY:
			val*=valres;
			break;
		case kifDIVIDE:
			if (valres!=0)
				val/=valres;
			else
				return 0;
			break;
		case kifMOD:
			val%=valres;
			break;
		case kifPOWER:
			val=pow((double)val,(double)valres);
			break;
		case kifSHIFTRIGHT:
			val>>=valres;
			break;
		case kifSHIFTLEFT:
			val<<=valres;
			break;
		}
	}
	return val;
}

double KifChild::ExecuteFloat() {
	double valres;
	double val;
	KifNumber* kn=values[0];
	KifValue* kval=kn->value;

	
	if (kn->type==ckifFloat)
		val=((KifFloatValue*)kval)->value;
	else {
		if (op==kifBLOC && instructiontype!=kifFULLFLOAT) {
			if (instructiontype==kifFULLSTRING) {
				string v;
				values[0]->child->ExecuteString(v);
				val=atof(STR(v));
			}
			else
				val=kn->child->ExecuteInteger();	
		}
		else
			val=kn->child->ExecuteFloat();			
	}

	for (int i=1;i<values.size();i++) {
		kn=values[i];
		KifValue* kval=kn->value;

		if (kn->type==ckifFloat)
			valres=((KifFloatValue*)kval)->value;
		else {			
			if (op==kifBLOC && instructiontype!=kifFULLFLOAT) {
				if (instructiontype==kifFULLSTRING) {
					string v;
					values[0]->child->ExecuteString(v);
					valres=atof(STR(v));
				}
				else
					valres=kn->child->ExecuteInteger();	
			}
			else
				valres=kn->child->ExecuteFloat();			
		}

		switch (op) {
		case kifINTERSECTION:
			val=(long)val&(long)valres;
			break;
		case kifUNION:
			val=(long)val|(long)valres;
			break;
		case kifXOR:
			val=(long)val^(long)valres;
			break;
		case kifPLUS:
			val+=valres;
			break;
		case kifMINUS:
			val-=valres;
			break;
		case kifMULTIPLY:
			val*=valres;
			break;
		case kifDIVIDE:
			if (valres!=0)
				val/=valres;
			else
				return 0;
			break;
		case kifMOD:
			val=(long)val%(long)valres;
			break;
		case kifPOWER:
			val=pow(val,valres);
			break;
		case kifSHIFTRIGHT:
			val=(long)val>>(long)valres;
			break;
		case kifSHIFTLEFT:
			val=(long)val<<(long)valres;
			break;
		}
	}
	return val;
}

void KifChild::ExecuteString(string& v) {
	KifNumber* kn;



	for (int i=0;i<values.size();i++) {
		kn=values[i];
		KifValue* kval=kn->value;

		if (kn->type==ckifString)
			v+=((KifStringValue*)kval)->value;
		else {
			if (op==kifBLOC && instructiontype!=kifFULLSTRING) {
				if (instructiontype==kifFULLINTEGER)
					v+=IntegerString(values[0]->child->ExecuteInteger());
				else
					v+=FloatString(values[0]->child->ExecuteFloat());
			}
			else
				kn->child->ExecuteString(v);			
		}
	}
}

inline void KifComputeValue::Execute(KifDomain* dom) {		
	
	switch(instructiontype) {
	case kifFULLSTRING:
		((KifStringValue*)value)->value=base->Execute(dom->kifcode->kifTypeSTRING,dom)->String();
		break;
	case kifFULLINTEGER:
		((KifIntegerValue*)value)->value=base->Execute(dom->kifcode->kifTypeINTEGER,dom)->Integer();
		break;
	default:
		((KifFloatValue*)value)->value=base->Execute(dom->kifcode->kifTypeFLOAT,dom)->Float();
	}
}

KifElement* KifRoot::ExecuteInteger(KifDomain* dom) {
	//First we initialise our variables
	ThreadLock _lock(kifRootInteger);
	hmap<short,KifComputeValue*>::iterator it;
	for (it=declarations.begin();it!=declarations.end();it++)
		it->second->Execute(dom);	
	((KifInteger*)returnvalue)->value=child->ExecuteInteger();
	if (kifThreadControl.kifnbthreads==0)
		return returnvalue;
	else
		return returnvalue->kifcode->Provideinteger(((KifInteger*)returnvalue)->value);
}

KifElement* KifRoot::ExecuteFloat(KifDomain* dom) {
	//First we initialise our variables
	ThreadLock _lock(kifRootFloat);
	hmap<short,KifComputeValue*>::iterator it;
	for (it=declarations.begin();it!=declarations.end();it++)
		it->second->Execute(dom);
	((KifFloat*)returnvalue)->value=child->ExecuteFloat();
	if (kifThreadControl.kifnbthreads==0)
		return returnvalue;
	else
		return returnvalue->kifcode->Providefloat(((KifFloat*)returnvalue)->value);
}

KifElement* KifRoot::ExecuteString(KifDomain* dom,string& val) {
	ThreadLock _lock(kifRootString);
	hmap<short,KifComputeValue*>::iterator it;
	for (it=declarations.begin();it!=declarations.end();it++)
		it->second->Execute(dom);
	child->ExecuteString(val);
	((KifString*)returnvalue)->value=val;
	if (kifThreadControl.kifnbthreads==0)
		return returnvalue;
	else
		return returnvalue->kifcode->Providestring(((KifString*)returnvalue)->value);
}


inline KifElement* KifInstruction::XInteger(KifDomain* dom) {
	return root->ExecuteInteger(dom);
}

inline KifElement* KifInstruction::XFloat(KifDomain* dom) {
	return root->ExecuteFloat(dom);
}

inline KifElement* KifInstruction::XString(KifDomain* dom) {
	string val;
	return root->ExecuteString(dom,val);
}

KifElement* KifInstruction::Evalue(KifElement* contextualpattern,KifDomain* dom) {
#ifdef PROFILING
	profilingcall("Instruction::Execute");
#endif	
	if (kifcode->error==true)
		return kifNULL;

	KifElement* res;

	switch(instructiontype) {
	case kifEQU:
		res=KIFEQU(dom);
		break;
	case kifFULLINTEGER:
		res=XInteger(dom);
		break;
	case kifFULLFLOAT:
		res=XFloat(dom);
		break;
	case kifFULLSTRING:
		res=XString(dom);
		break;
	default:
		switch (action) {
		case kifAFFECTATION:
			res=AFFECTATION(dom);
			break;
		case kifPLUSEQU:
		case kifMINUSEQU:
		case kifMULTIPLYEQU:
		case kifDIVIDEEQU:
		case kifMODEQU:
		case kifPOWEREQU:
		case kifSHIFTLEFTEQU:
		case kifSHIFTRIGHTEQU:
		case kifUNIONEQU:
		case kifXOREQU:
		case kifINTERSECTIONEQU:
			res=APPLYOPERATIONEQU(dom);
			break;
		case kifPLUS:
		case kifMINUS:
		case kifMULTIPLY:
		case kifDIVIDE:
		case kifMOD:
		case kifPOWER:
		case kifSHIFTLEFT:
		case kifSHIFTRIGHT:
		case kifUNION:
		case kifXOR:
		case kifINTERSECTION:
			res=APPLYOPERATION(contextualpattern,dom);
			break;
		case kifEQUAL:
		case kifDIFFERENT:
		case kifSUPERIOR:
		case kifINFERIOR:
		case kifSUPEQU:
		case kifINFEQU:
			res=COMPARE(dom);
			break;
		case kifPLUSPLUS:
			res=PLUSPLUS(dom);
			break;
		case kifMINUSMINUS:
			res=MINUSMINUS(dom);
			break;
		case kifBLOC:
			res=instructions[0]->Execute(kifNULL,dom);
			break;
		case kifBLOCBOOLEAN:
			res=BLOCBOOLEAN(contextualpattern,dom);
			break;
		case kifOR:
			res=OR(dom);
			break;
		case kifAND:
			res=AND(dom);
			break;
		case kifIN:
			res=KIFIN(contextualpattern,dom);
			break;
		}
	}
	if (negation==true) {
		if (res->Boolean()==true)
			return kifFALSE;
		return kifTRUE;
	}
	return res;
}


KifElement* KifInstruction::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool rcouple) {
#ifdef PROFILING
	profilingcall("Instruction::Execute");
#endif	
	kifcode->currentline=Line();
	if (kifcode->error==true)
		return kifNULL;
	
	KifElement* res=kifNULL;
	
	switch(instructiontype) {
	case kifEQU:
		res=KIFEQU(dom);
		break;
	case kifFULLINTEGER:
		res=XInteger(dom);
		break;
	case kifFULLFLOAT:
		res=XFloat(dom);
		break;
	case kifFULLSTRING:
		res=XString(dom);
		break;
	default:
		switch (action) {
		case kifPLUSEQU:
		case kifMINUSEQU:
		case kifMULTIPLYEQU:
		case kifDIVIDEEQU:
		case kifMODEQU:
		case kifPOWEREQU:
		case kifSHIFTLEFTEQU:
		case kifSHIFTRIGHTEQU:
		case kifUNIONEQU:
		case kifXOREQU:
		case kifINTERSECTIONEQU:
			res=APPLYOPERATIONEQU(dom);
			break;
		case kifAFFECTATION:
			res=AFFECTATION(dom);
			break;
		case kifINITIALISATION:
			res=INITIALISATION(dom,ke);
			break;
		case kifEQUAL:
		case kifDIFFERENT:
		case kifINFERIOR:
		case kifSUPERIOR:
		case kifSUPEQU:
		case kifINFEQU:
			res=COMPARE(dom);
			break;
		case kifPLUS:
		case kifMINUS:
		case kifMULTIPLY:
		case kifDIVIDE:
		case kifMOD:
		case kifPOWER:
		case kifSHIFTLEFT:
		case kifSHIFTRIGHT:
		case kifUNION:
		case kifXOR:
		case kifINTERSECTION:
			res=APPLYOPERATION(contextualpattern,dom);
			break;
		case kifPLUSPLUS:
			res=PLUSPLUS(dom);
			break;
		case kifMINUSMINUS:
			res=MINUSMINUS(dom);
			break;
		case kifBLOC:
			res=instructions[0]->Execute(kifNULL,dom,ke);
			break;
		case kifBLOCBOOLEAN:
			res=BLOCBOOLEAN(contextualpattern,dom);
			break;
		case kifOR:
			res=OR(dom);
			break;
		case kifAND:
			res=AND(dom);
			break;
		case kifIN:
			res=KIFIN(contextualpattern,dom);
			break;
		}
	}

	if (negation==true) {
		if (res->Boolean()==true)
			return kifFALSE;
		return kifTRUE;
	}

	return res;
}


//===================================================================
KifElement* KifInstructionSWITCH::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool rcouple) {
#ifdef PROFILING
	profilingcall("Instruction::SWITCH");
#endif
	kifcode->currentline=Line();
	if (kifcode->error==true)
		return kifNULL;

	//First our variable
	KifElement* result;
	KifElement* var=instructions[0]->Execute(kifTRUE,dom);
	//Then the instructions, the odd element is the value to compare with, the even element
	//the instruction to execute.
	for (int i=1;i<instructions.size();i+=2) {
		result=instructions[i]->Execute(contextualpattern,dom);
		if (result==kifDEFAULT || var->same(result)->Boolean()==true)
			return instructions[i+1]->Execute(contextualpattern,dom);
	}
	return kifNULL;
}

KifElement* KifInstructionIF::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool neg) {
#ifdef PROFILING
	profilingcall("Instruction::KIFIF");
#endif
	if (kifcode->error==true)
		return kifNULL;
	kifcode->currentline=Line();

	KifElement* result;
	KifOperator action=instructions[0]->Action();
	neg=false;

	if (action>=kifEQUAL && action<=kifDIFFERENT) {
		neg=((KifInstruction*)instructions[0])->negation;
		result=((KifInstruction*)instructions[0])->COMPARE(dom);
	}
	else
		if (action==kifIN) {
			neg=((KifInstruction*)instructions[0])->negation;
			result=((KifInstruction*)instructions[0])->KIFIN(kifTRUE,dom);
		}
		else
			result=instructions[0]->Execute(kifTRUE,dom);
	
	if (kifcode->error)
		return kifNULL;
	
	if (result->Boolean()==true || result->Integer()!=0)
		neg=1-neg;

	if (neg==true)
		return instructions[1]->Execute(contextualpattern,dom,ke,false);
	else
		if (instructions.size()==3)
			return instructions[2]->Execute(contextualpattern,dom,ke,false);
	return kifNULL;
}


KifElement* KifInstructionWHILE::Execute(KifElement* var,KifDomain* dom,KifElement* result,bool neg) {
#ifdef PROFILING
	profilingcall("Instruction::WHILE");
#endif
	if (kifcode->error==true)
		return kifNULL;
	kifcode->currentline=Line();

	result=kifTRUE;
	KifCallFunction* callfunc=(KifCallFunction*)kifcode->Top();
	KifBooleanLoop* localloop;
	char compare=0;
	neg=false;
	KifFile* kfile;
	switch (instructions[0]->Action()) {
	case kifEQUAL:
	case kifSUPERIOR:
	case kifINFERIOR:
	case kifSUPEQU:
	case kifINFEQU:
	case kifDIFFERENT:
		neg=((KifInstruction*)instructions[0])->negation;
		compare=2;
		break;
	case kifBLOCLOOPIN:
		result=((KifInstance*)Instruction(0)->Instruction(0))->Thevariable(dom);
		var=Instruction(0)->Instruction(1)->Execute(kifNULL,dom,kifNULL,false);
		localloop=new KifBooleanLoop(result,var);
		compare=1;
		break;
	case kifFILEIN:
		compare=3;
		var=((KifInstance*)Instruction(0)->Instruction(0))->Thevariable(dom);
		kfile=(KifFile*)((KifInstance*)Instruction(0)->Instruction(1))->Evalue(kifNULL,dom);
	}
	
	switch(compare) {
	case 0:
		result=instructions[0]->Execute(kifTRUE,dom);
		break;
	case 1:
		result=localloop->Nextin();
		break;
	case 2:
		result=((KifInstruction*)instructions[0])->COMPARE(dom);
		break;
	case 3:
		kfile->initwhile(var);
		result=kfile->whilein(var);
	}
	
	if (result->Boolean()==neg) {
		if (compare==1)
			delete localloop;
		return kifNULL;
	}

	bool testdebug=kifcode->debugging;
	bool evalue=false;
	if (instructions[1]->type==kifInstruction)
		evalue=true;

	while (result->Boolean()!=neg) {
		if (testdebug)
			testdebug=kifcode->Debugging(this,instructions[1],dom,callfunc);

		if (evalue)
			result=((KifInstruction*)instructions[1])->Evalue(kifNULL,dom);
		else
			result=instructions[1]->Execute(kifNULL,dom);

		if (kifcode->error==true) {
			if (compare==1)
				delete localloop;
			return kifNULL;
		}

		if (callfunc!=NULL && callfunc->Isreturned()) {
			if (compare==1)
				delete localloop;
			return callfunc->returnvalue;
		}

		if (result==kifBREAK) {
			if (compare==1)
				delete localloop;
			return kifTRUE;
		}

		switch(compare) {
		case 0:
			result=instructions[0]->Execute(kifTRUE,dom);
			break;
		case 1:
			result=localloop->Nextin();
			break;
		case 2:
			result=((KifInstruction*)instructions[0])->COMPARE(dom);
			break;
		case 3:
			result=kfile->whilein(var);
		}
		kifcode->Garbage();
	}
	if (compare==1)
		delete localloop;
	return kifTRUE;
}


KifElement* KifInstructionSEQUENCE::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool testdebug) {
#ifdef PROFILING
	profilingcall("Instruction::SEQUENCE");
#endif
	kifcode->currentline=Line();
	if (kifcode->error==true)
		return kifNULL;

	hmap<short,KifElement*>* stacks=NULL;
	KifElement* res=kifTRUE;
	KifCallFunction* callfunc=(KifCallFunction*)kifcode->Top();
	testdebug=kifcode->debugging;	
	KifDomain* localdom=dom;
	if (callfunc!=NULL)
		localdom=callfunc;
	for (size_t i=0;i<instructions.size();i++) {
		if (testdebug)
			testdebug=kifcode->Debugging(this,instructions[i],dom,callfunc);
		ke=instructions[i];
		if (ke->type==kifInstruction)
			res=((KifInstruction*)ke)->Evalue(kifNULL,dom);
		else
			if (ke->Variable()) {
				if (stacks==NULL)
					stacks=new hmap<short,KifElement*>;
				(*stacks)[ke->Name()]=localdom->Declaration(ke->Name());				
				res=ke->Execute(contextualpattern,localdom,kifNULL,false);
				res->Setlocalvariable();
			}
			else
				res=ke->Execute(kifNULL,dom);
				
		if (callfunc!=NULL && callfunc->Isreturned()) {
			res=callfunc->returnvalue;
			break;
		}

		if (res==kifBREAK || res==kifCONTINUE || kifcode->error)
			break;
	}
    //We then clean the variables that were created locally...
	//We forbid at the compiling level, the fact that a local variable would share the same name
	//as another variable declared above this sequence, this in order to simplify the process
	//of creating and removing these local variables... Futhermore, a SEQUENCE cannot call itself recursively
	//so we do not need to keep a complex track of which was what...

	if (stacks!=NULL) {
		localdom->Resetdeclaration(*stacks);
		delete stacks;
	}
	return res;
}

KifElement* KifInstructionTRY::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* res,bool testdebug) {
#ifdef PROFILING
	profilingcall("Instruction::TRY");
#endif
	kifcode->currentline=Line();
	if (kifcode->error==true)
		return kifNULL;

	KifCallFunction* callfunc=(KifCallFunction*)kifcode->Top();
	int last=instructions.size()-1;
	bool catchbloc=false;
	if (instructions[last]->Action()==kifCATCHBLOC) {
		last--;
		catchbloc=true;
	}
	testdebug=kifcode->debugging;

	for (size_t i=0;i<last;i++) {
		if (testdebug)
			testdebug=kifcode->Debugging(this,instructions[i],dom,callfunc);
		
		res=instructions[i]->Execute(kifNULL,dom);
		if (kifcode->error==true) {
			instructions[last]->Execute(kifNULL,dom);
			res=kifFALSE;
			if (catchbloc)
				res=instructions[last+1]->Execute(kifNULL,dom);
			return res;
		}

		if (callfunc!=NULL && callfunc->Isreturned())
			return callfunc->returnvalue;

		if (res==kifBREAK || res==kifCONTINUE)
			return res;
	}

	return kifTRUE;
}

KifElement* KifInstructionFOR::Execute(KifElement* contextualpattern,KifDomain* dom,KifElement* ke,bool neg) {
#ifdef PROFILING
	profilingcall("Instruction::FOR");
#endif
	if (kifcode->error==true)
		return kifNULL;
	kifcode->currentline=Line();


	//Initialisation
	KifCallFunction* callfunc=(KifCallFunction*)kifcode->Top();
	KifElement* test=kifTRUE;
	
	bool compare=false;
	neg=false;
	if (instructions[1]->Action()>=kifEQUAL && instructions[1]->Action()<=kifDIFFERENT) {
		neg=((KifInstruction*)instructions[1])->negation;
		compare=true;
	}
	
	//Initialisation
	instructions[0]->Execute(kifTRUE,dom);	
	//then test
	if (compare)
		test=((KifInstruction*)instructions[1])->COMPARE(dom);
	else
		test=instructions[1]->Execute(kifTRUE,dom);

	bool testdebug=kifcode->debugging;
	KifElement* increment=instructions[2];
	KifOperator act=increment->Action();
	KifElement* var=NULL;
	if (act==kifPLUSPLUS || act==kifMINUSMINUS)
		var=increment->Instruction(0)->Execute(kifNULL,dom,kifNULL,true);
	//A simple test, which does not require any complex comparison

	KifElement* res=kifNULL;
	while (test->Boolean()!=neg) {
		//then the body		
		if (testdebug)
			testdebug=kifcode->Debugging(this,instructions[3],dom,callfunc);

		res=instructions[3]->Execute(contextualpattern,dom);

		if (kifcode->error==true)
			return kifNULL;
		
		if (callfunc!=NULL && callfunc->Isreturned())
			return callfunc->returnvalue;

		if (res==kifBREAK)
			return kifTRUE;

		switch(act) {
		case kifPLUSPLUS:
			var->Returnvalue()->plusplus();
			break;
		case kifMINUSMINUS:
			var->Returnvalue()->minusminus();
			break;
		default:
			instructions[2]->Execute(contextualpattern,dom);
		}

			//then the test again
		if (compare)
			test=((KifInstruction*)instructions[1])->COMPARE(dom);
		else
			test=instructions[1]->Execute(kifTRUE,dom);
		kifcode->Garbage();
	}

	return kifTRUE;
}

//===================================================================
KifElement* KifCode::KifParseNegation(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseNegation");
#endif
	kf->Setnegation(true);
	return kf;
}


KifElement* KifCode::KifParseBoolean(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseBoolean");
#endif
	KifElement* kbloc;
	if (xn->nodes.size()==1) {
		//It is a unique test
		kbloc=new KifInstruction(this,kf,kifBLOCBOOLEAN);
		kbloc->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
		KifBrowse(xn->nodes[0],kbloc);
		return kbloc;
	}
	//Else, we have two expressions and an operator
	//If our operator is new to our test
	KifElement* ke=kf;
	KifOperator op=kifOperators[xn->nodes[1]->value];
	if (op!=kf->Action()) {
		if (kf->Action()==kifBLOCBOOLEAN)
			ke->Setaction(op);
		else {
			ke=new KifInstruction(this,kf,op);
			ke->Setline(linereference+GetCurrentLine(0,xn));
		}
	}

	kbloc=new KifInstruction(this,ke,kifBLOCBOOLEAN); 
	kbloc->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
	KifBrowse(xn->nodes[0],kbloc);	
	KifBrowse(xn->nodes[2],ke);
	return ke;
}

KifElement* KifCode::KifParseTestSwitch(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseTestSwitch");
#endif
	if (xn->nodes[0]->token=="default")
		kf->Add(kifDEFAULT);
	else
		KifBrowse(xn->nodes[0],kf);
	KifDomain* ktrue=new KifInstructionSEQUENCE(this,kf,idsequence);
	ktrue->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
	Push(ktrue);
	KifBrowse(xn->nodes[1],ktrue);
	Pop();
	return ktrue;
}

KifElement* KifCode::KifParseSwitch(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseSwitch");
#endif
	//We create a IF section
	KifElement* kswitch=new KifInstructionSWITCH(this,kf);
	kswitch->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
	KifBrowse(xn->nodes[0],kswitch);
	for (int i=1;i<xn->nodes.size();i++)
		KifBrowse(xn->nodes[i],kswitch);
	return kswitch;
}

KifElement* KifCode::KifParseTryCatch(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseTryCatch");
#endif
	KifElement* ke=new KifInstructionTRY(this,kf);
	ke->Setline(linereference+GetCurrentLine(0,xn));
	string name;
	KifElement* declaration;
	KifInstance* ki;

	long line=GetCurrentLine(0,xn);
	short id;
	if (xn->nodes.size()!=1 && xn->nodes[1]->token=="word") {
		name=xn->nodes[1]->value;
		id=KifNewId(name);
		declaration=Getbasic(id,kf);

		if (declaration==NULL || declaration->XIP()) {
			string message="Unknown variable or XIP declared variable: '"+name+"'";
			throw new KifRaiseError(message,current->name,line,xn->end);
		}

		if (!declaration->Variable()) {
			if (xn->nodes.size()==1 && (kifAllTypes[id]==true || declaration->type==kifFunction)) {
				KifElement* ke=new KifSelf(this,kf,declaration);
				ke->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
				return ke;
			}
			string message="Unknown variable: '"+name+"'";
			throw new KifRaiseError(message,current->name,line,xn->end);
		}

		KifInstruction* kaff=new KifInstruction(this,ke,kifAFFECTATION);
		kaff->Setline(linereference+GetCurrentLine(0,xn));
		ki=new KifInstance(this,kaff,id,(KifVariableDeclaration*)declaration);
		if (declaration->type==kifFunctionDeclaration)
			((KifInstance*)ki)->newinstance=kinFunction;
		else
			if (declaration->type==kifFrameDeclaration) {
				KifElement* currentdeclaration=FindFrameForSequence(declaration,xn,-1);
				if (currentdeclaration==kstart)
					((KifInstance*)ki)->newinstance=kinGlobal;
				else
					((KifInstance*)ki)->newinstance=kinFrame;
			}
		ki->Setstringvalue(name);
		kaff->Add(kifNULL);
	}

	KifBrowse(xn->nodes[0],ke);

	
	KifElement* kfunc=kifBaseFunctions[idcatch];
	KifCallFunction* kcf=new KifCallFunctionPredefined(this,ke,idcatch,(KifFunction*)kfunc);
	kcf->Setline(linereference+GetCurrentLine(0,xn));

	if (xn->nodes.size()!=1) {
		if (xn->nodes[1]->token=="word") {
			ki=new KifInstance(this,kcf,id,(KifVariableDeclaration*)declaration);
			if (declaration->type==kifFunctionDeclaration)
				((KifInstance*)ki)->newinstance=kinFunction;
			else
				if (declaration->type==kifFrameDeclaration) {
					KifElement* currentdeclaration=FindFrameForSequence(declaration,xn,-1);
					if (currentdeclaration==kstart)
						((KifInstance*)ki)->newinstance=kinGlobal;
					else
						((KifInstance*)ki)->newinstance=kinFrame;
				}

			ki->Setstringvalue(name);
			ki->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
			if (xn->nodes.size()==3) {
				if (xn->nodes[2]->token=="blocs")  {
					KifElement* kbloc=new KifInstructionCATCH(this,ke);
					kbloc->Setline(linereference+GetCurrentLine(0,xn->nodes[2]));
					//Instruction
					KifBrowse(xn->nodes[2],kbloc);
				}
			}
		}
		else {
			if (xn->nodes[1]->token=="blocs")  {
				KifElement* kbloc=new KifInstructionCATCH(this,ke);
				kbloc->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
				//Instruction
				KifBrowse(xn->nodes[1],kbloc);
			}
		}
	}
	kcf->add=0;
	return ke;
}

KifElement* KifCode::KifParseTest(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseTest");
#endif
	KifElement* ke=new KifInstructionIF(this,kf);
	ke->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
	KifBrowse(xn->nodes[0],ke);
	KifElement* kobj=ke;
	while (kobj!=NULL && kobj->InstructionSize()==1)
		kobj=(KifObject*)kobj->Instruction(0);
	if (kobj!=ke->Instruction(0))
		((KifInstruction*)ke)->instructions[0]=kobj;
	KifDomain* ktrue=new KifInstructionSEQUENCE(this,ke,idsequence);
	Push(ktrue);
	ktrue->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	KifBrowse(xn->nodes[1],ktrue);
	Pop();
	
	if (xn->nodes.size()==3) {
		KifDomain* kfalse=new KifInstructionSEQUENCE(this,ke,idsequence);
		kfalse->Setline(linereference+GetCurrentLine(0,xn->nodes[2]));
		Push(kfalse);
		KifBrowse(xn->nodes[2],kfalse);
		Pop();
	}

	return ke;
}



KifElement* KifCode::KifParseWhile(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseWhile");
#endif
	KifElement* ke=new KifInstructionWHILE(this,kf);
	ke->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
	KifBrowse(xn->nodes[0],ke);
	bool getfiletype=false;
	KifElement* kobj;
	if (ke->InstructionSize()==1) {
		kobj=ke->Instruction(0);
		//In the case of a in, there is a little trick to perform
		if (kobj->Action()==kifIN && kobj->InstructionSize()==2 && ((KifInstruction*)kobj)->negation==false) {
			kobj->Setaction(kifBLOCLOOPIN);
			getfiletype=true;
		}
	}
	KifDomain* ktrue=new KifInstructionSEQUENCE(this,ke,idsequence);
	ktrue->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	Push(ktrue);
	KifBrowse(xn->nodes[1],ktrue);
	Pop();
	if (getfiletype) {
		//If it is not a variable then we do revert to a kifIN
		KifType kt=((KifInstance*)kobj->Instruction(1))->value->type;
		if (PureKifInstance(kobj->Instruction(0))==false) {
			if (kt==kifFile) {
				string message="The first parameter in WHILE for a file should be a variable";
				throw new KifRaiseError(message,current->name,GetCurrentLine(0,xn),xn->end);
			}
			kobj->Setaction(kifIN);
		}
		else
			if (kt==kifFile)
				kobj->Setaction(kifFILEIN);
	}
	return ke;
}

KifElement* KifCode::KifParseFor(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseFor");
#endif
	KifElement* ke=new KifInstructionFOR(this,kf);
	ke->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
	//Initialisation
	KifBrowse(xn->nodes[0],ke);
	//Test
	KifBrowse(xn->nodes[1],ke);
	//Increment
	KifBrowse(xn->nodes[2],ke);
	KifDomain* kbloc=new KifInstructionSEQUENCE(this,ke,idsequence);
	kbloc->Setline(linereference+GetCurrentLine(0,xn->nodes[3]));
	//Instruction
	Push(kbloc);
	KifBrowse(xn->nodes[3],kbloc);
	Pop();

	return ke;
}

//The parameter list is a two nodes tree, where the second node is always a parameter
//hence a recursive analysis
void KifCode::ComputeParameters(x_node* xn,KifCallFunction* kcf) {
#ifdef PROFILING
	profilingcall("Code::ComputeParameters");
#endif
	KifElement* kbloc=new KifInstructionPARAMETER(this,kcf);
	kbloc->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
	KifBrowse(xn->nodes[0],kbloc);

	if (xn->nodes.size()==2)
		ComputeParameters(xn->nodes[1],kcf);
}

KifElement* KifCode::KifParseUniqueCall(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseUniqueCall");
#endif
	string& name=xn->value;
	//Looking if it is known as function
	KifElement* kcf;	

	if (name=="break")
		kcf=new KifCallFunctionBreakOuContinue(this,kf,kifBREAK);
	else {
		if (name=="continue")
			kcf=new KifCallFunctionBreakOuContinue(this,kf,kifCONTINUE);
		else
			if (name=="return")
				kcf=new KifReturn(this,kf);
			else
				if (name=="breakpoint")
					kcf=new KifCallFunctionBreakpoint(this,kf);
				else {				
					KifElement* kfunc=kifBaseFunctions[idkifmain];		
					kcf=new KifCallFunctionPredefined(this,kf,idkifmain,(KifFunction*)kfunc);
					((KifCallFunctionPredefined*)kcf)->add=0;
					kcf->Setline(linereference+GetCurrentLine(0,xn));
					kf->Initvalue(kcf);		

				}
	}
	return kcf;
}

Exported void KifFunction::Setlimited(bool l) {
	nonlimited=l;
	string s="_";
	s+=(*kifIdString)[name];
	int id=KifNewId(s);
	declarations[id]=kifNULL;
}

KifElement* KifCode::KifNonLimited(x_node* xn,KifElement* kf) {
	kf->Setlimited(true);
	return kf;
}

KifElement* KifCode::KifParseCall(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseCall");
#endif
	string name=xn->nodes[0]->value;
	short idframe=-1;
	string framename;
	if (xn->nodes[0]->nodes.size()!=1) {
		framename=xn->nodes[0]->nodes[0]->nodes[0]->value;
		name=xn->nodes[0]->nodes[1]->value;
		idframe=KifNewId(framename);
	}

	short id=KifNewId(name);
	bool basictype=false;
	bool getbasefunction=false;
	long line=GetCurrentLine(0,xn);

	if (name=="garbagesize") {
		//very specific case, to set the garbage size from within
		if (xn->nodes.size()==2) {
			KifElement kxf(NULL,NULL);
			KifElement* res=KifBrowse(xn->nodes[1],&kxf);
			res=res->Execute(kifNULL,kstart);
			long sz=res->Integer();
			if (sz>kif_declencheur) {
				trigger=sz;
				garbage.ajuste(sz);
			}
		}
		else {
			string message="Missing parameter in 'garbagesize'";
			throw new KifRaiseError(message,current->name,line,xn->end);
		}
		return kf;
	}

	if (name=="garbagefunction") {
		if (xn->nodes.size()==2) {
			KifElement* kfunc=NULL;
			name=xn->nodes[1]->value;
			id=KifNewId(name);
			kfunc=Getbasic(id,kf);
			//We have a WITH description
			if (kfunc==NULL || kfunc->type!=kifFunction) {
				string message=kifErrorStrings[178]+name;
				long line=GetCurrentLine(0,xn);
				throw new KifRaiseError(message,current->name,line,xn->end);
			}
			garbagefunction=(KifFunction*)kfunc;
		}
		else {
			string message="Missing parameter in 'garbagefunction'";
			throw new KifRaiseError(message,current->name,line,xn->end);
		}
		return kf;
	}

	if (name=="use") {
		//very specific case, where we load our lib on the fly
		if (xn->nodes.size()==2) {
			KifElement kxf(NULL,NULL);
			KifElement* res=KifBrowse(xn->nodes[1],&kxf);
			res=res->Execute(kifNULL,kstart);
			KifLoadModule(xn,res->String());
		}
		else {
			string message="Missing parameter in 'use'";
			throw new KifRaiseError(message,current->name,line,xn->end);
		}
		return kf;
	}

	if (name=="loadin") {
		//very specific case, where we load a KiF program on the fly
		if (xn->nodes.size()==2) {
			KifElement kxf(NULL,NULL);
			KifElement* res=KifBrowse(xn->nodes[1],&kxf);
			res=res->Execute(kifNULL,kstart);
			KifLoadin(this,res->String());
		}
		else {
			string message="Missing parameter in 'loadin'";
			throw new KifRaiseError(message,current->name,line,xn->end);
		}
		return kf;
	}

	//Particular case, where the function is a predefined function linked to an instance
	if (KifBaseFunctionTest(id)!=NULL) {
		if(kf->type==kifInstanceFunction)
			basictype=true;
		else
			if (kf->type==kifIndex || CALLFUNCTION(kf)) {
				basictype=true;
				getbasefunction=true;
			}
			else
				getbasefunction=true;
	}
	
	//Particular case, where a different frame was provided through a frame::function call
	KifElement* kframe=kf;
	if (idframe!=-1)
		kframe=Getbasic(idframe,kf);

	//Looking if it is known as a function
	KifElement* kfunc=Getbasic(id,kframe);
	if (kifAllTypes[id]==true && kfunc!=NULL && kfunc->type==kifFrame) {
		//This is a very specific case, where we create a new instance
		//for a frame. kfunc is the frame definition, which will be used
		//to create a new instance in Setvalue.
		KifSelf* ke=new KifSelf(this,kframe,kfunc);
		ke->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
		KifInstruction* ki=new KifInstruction(this,ke,kifINITIALISATION);
		ki->Setline(ke->Line());
		KifBrowse(xn->nodes[1],ki);
		ke->parameter=ki;
		return ke;
	}

	if (kfunc==NULL && getbasefunction==true) {
		if (kifMethods.find(id)!=kifMethods.end()) {
			string message="Unknown function: '"+name+"'";
			throw new KifRaiseError(message,current->name,line,xn->end);
		}

		kfunc=KifBaseFunctionTest(id);
	}
	
	if (name=="return")
		kfunc=new KifCallReturn(this,kf,id);

	if (kfunc==NULL) {
		string message="Unknown function: '"+name+"'";
		throw new KifRaiseError(message,current->name,line,xn->end);
	}

	if (kfunc==kifTRUE)
		kfunc=NULL;
	
	if (idframe!=-1) {
		framename+="::";
		framename+=name;
		id=KifNewId(framename);
	}

	KifCallFunction* kcf=NULL;
	if (kfunc!=NULL) {
		if (name=="return")
			kcf=(KifCallFunction*)kfunc;
		else
			if (kfunc->Linkedvalue()!=NULL && kfunc->Linkedvalue()->type==kifCall)
				kcf=new KifCallFunctionCall(this,kf,id,kfunc);
			else {
				kfunc->Setused();
				if (kfunc->type==kifPredefined)
					kcf=new KifCallFunctionPredefined(this,kf,id,(KifFunction*)kfunc);
				else
					if (kfunc->type==kifCallMethod)
						kcf=new KifCallFunctionExternal(this,kf,id,(KifFunction*)kfunc);
					else
						if (kfunc->type==kifThread)
							kcf=new KifCallFunctionThread(this,kf,id,(KifFunction*)kfunc);
			}
	}

	if (kcf==NULL)
		kcf=new KifCallFunctionGeneral(this,kf,id,(KifFunction*)kfunc);

	kcf->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
	
	//We check again to see if a specific function name was not overloaded
	if (basictype==true && kfunc!=NULL && kfunc->type==kifPredefined) {
		kcf->Setselfinsert(true);
		kcf->parameters.push_back(kifNULL);
	}
	else
		if (kfunc!=NULL && kfunc->type==kifCallMethod)
			kcf->Setselfinsert(true);

	kf->Initvalue(kcf);	
	if (xn->nodes.size()>=2) {
		int last=1;
		if (xn->nodes[last]->token=="parameters") {
			ComputeParameters(xn->nodes[last],kcf);
			last++;
		}
		if (xn->nodes.size()>last) {
			if (TestKifFunctions(xn->nodes[last]->token,false)) {
				kcf->add=2;
				KifBrowse(xn->nodes[last],kcf);
			}
		}
	}

	if (kfunc!=NULL && kfunc->isFunction()) {
		char ret=KifCheckParameters((KifFunction*)kfunc,kcf,true,NULL);
		if (ret==1) {
			string message=kifErrorStrings[158];
			message+=name;
			throw new KifRaiseError(message,current->name,line,xn->end);
		}
		else
			if (ret==2) {
				string message="No compatible function found for:";
				message+=name;
				throw new KifRaiseError(message,current->name,line,xn->end);
			}
	}
	kcf->add=0;
	return kcf;
}

KifElement* KifCode::KifParseIndexes(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseIndexes");
#endif
	KifElement* ki=new KifIndex(this,kf,false);
	ki->Setline(linereference+GetCurrentLine(0,xn));
	kf->Initvalue(ki);
	//KifInstruction* kidx=new KifInstruction(this,ki,kifBLOC);
	KifInstruction kidx(NULL,NULL,kifBLOC);
	//kidx->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
	KifBrowse(xn->nodes[0],&kidx);
	ki->Add(kidx.instructions[0]);
	if (xn->nodes.size()==2)
		KifBrowse(xn->nodes[1],ki);
	return ki;
}

KifElement* KifCode::KifParseInterval(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseInterval");
#endif
	string ty=kf->Type();
	long line=GetCurrentLine(0,xn);
	//if (ty!="vector" && ty!="string") {
	//	string message="Wrong interval for this variable:"+kf->Name()+" type is="+ty;
	//	throw new KifRaiseError(message,current->name,line,xn->end);
	//}

	int xsz=xn->nodes.size();

	if (xsz==1) {
		string message="Wrong interval";
		throw new KifRaiseError(message,current->name,line,xn->end);
	}


	KifIndex* ki=new KifIndex(this,kf,true);
	ki->Setline(linereference+GetCurrentLine(0,xn));
	kf->Initvalue(ki);

	if (TestKifFunctions(xn->nodes[xsz-1]->token,false))
		xsz--;
	
	KifInstruction kidx(NULL,NULL,kifBLOC);
	//Three cases
	if (xsz==3) {
		//We have the first value, then the separator then the other value
		KifBrowse(xn->nodes[0],&kidx);
		ki->Add(kidx.instructions[0]);
		KifInstruction kidxx(NULL,NULL,kifBLOC);
		KifBrowse(xn->nodes[2],&kidxx);
		ki->Add(kidxx.instructions[0]);
	}
	else
		if (xn->nodes[0]->token=="sep") {
			//then the first parameter is not known
			ki->key=kifNULL;
			KifBrowse(xn->nodes[1],&kidx);
			ki->Add(kidx.instructions[0]);
		}
		else {//The last parameter is not known
			KifBrowse(xn->nodes[0],&kidx);
			ki->Add(kidx.instructions[0]);
			ki->right=kifNULL;
		}
	
	//If we have a call
	if (xsz!=xn->nodes.size()) {
		ki->interval=false;
		KifBrowse(xn->nodes[xsz],ki);
		ki->interval=true;
	}

	return ki;
}

KifElement* KifCode::KifParseOperator(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseOperator");
#endif
	short op= kifOperators[xn->value];
	kf->Set(op,kf,NULL);
	return kf;
}

KifElement* KifCode::KifParseBloc(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseBloc");
#endif
	KifInstruction* ki=(KifInstruction*)kf;
	if (kf->Action()!=kifBLOCBOOLEAN) {
		ki=new KifInstruction(this,kf,kifBLOC);
		ki->Setline(linereference+GetCurrentLine(0,xn));
	}
	operations.push_back(true);
	for (size_t i=0;i<xn->nodes.size();i++)
		KifBrowse(xn->nodes[i],ki);
	operations.pop_back();
	if (operations.size()==0)
		kf->BuildNumericalExpression(0);
	return ki;	
}

KifElement* KifCode::KifParseComparison(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseComparison");
#endif
	//The first parameter is the operator
	KifElement* ki=kf;
	KifOperator op=kifOperators[xn->nodes[0]->value];
	if (kf->Action()==kifBLOCBOOLEAN || kf->Action()==kifBLOC)
		ki->Setaction(op);
	else
		ki=new KifInstruction(this,kf,op);		
	//ki->Setline(linereference+GetCurrentLine(0,xn));
	for (size_t i=0;i<xn->nodes.size();i++)
		KifBrowse(xn->nodes[i],ki);
	return ki;
}

KifElement* KifCode::KifParsePlusPlus(x_node* xn,KifElement* kf) {
	KifOperator op=kifOperators[xn->value];
	kf->Setaction(op);
	return kf;
}


KifElement* KifCode::KifParseOperation(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseOperation");
#endif
		
	//The first parameter is the operator	
	KifOperator op=kifOperators[xn->nodes[0]->value];
	//The second parameter is the rest of the operation
	//kf is the TOP instruction
	KifInstruction* ki;
	if (kf->Action()==kifBLOC) {
		//We are in a new bloc, which is our current element
		//In this case, we create a new level
		ki=new KifInstruction(this,NULL);
		ki->Setline(linereference+GetCurrentLine(0,xn));
		//It becomes the new element
		ki->Setaction(op);
		ki->Add(kf->Instruction(0));
		kf->Addinstruction(0,ki);
		ki->Addparent(kf);
		operations.push_back(true);
		KifBrowse(xn->nodes[1],ki);
		operations.pop_back();
		if (operations.size()==0)
			kf->BuildNumericalExpression(0);
		return ki;
	}

	if (kf->Action()==op) {
		KifBrowse(xn->nodes[1],kf);
		if (operations.size()==0)
			kf->BuildNumericalExpression(0);
		return kf;
	}

	//In this case, the operator is not the same
	//we still have two cases: if it is
	//if it is a PLUS or a MINUS, we reset the top node with the new information
	ki=new KifInstruction(this,NULL);
	ki->Setline(linereference+GetCurrentLine(0,xn));
	//It has to be in the middle of an operation
	if (kifOperatorMath[kf->Action()]==true) {
		if (op==kifPLUS || op==kifMINUS) {
			ki->Setaction(kf->Action());
			for (int i=0;i<kf->InstructionSize();i++)
				ki->instructions.push_back(kf->Instruction(i));
			kf->Setaction(op);
			kf->InstructionClear();
			kf->Addinstruction(0,ki);
			ki->Addparent(kf);
			operations.push_back(true);
			KifBrowse(xn->nodes[1],kf);
			operations.pop_back();
			if (operations.size()==0)
				kf->BuildNumericalExpression(0);
			return kf;
		}
	}

	//we create a new level
	ki->Setaction(op);
	ki->Add(kf->Lastinstruction());
	kf->Addinstruction(kf->InstructionSize()-1,ki);
	ki->Addparent(kf);
	operations.push_back(true);
	KifBrowse(xn->nodes[1],ki);
	operations.pop_back();
	if (operations.size()==0)
		kf->BuildNumericalExpression(0);
	return kf;
}

KifElement* KifCode::KifParseOperationIn(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseOperationIn");
#endif
	//The first parameter is the operator
	KifInstruction* ki;
	if (kf->Action()==kifBLOCBOOLEAN)
		ki=(KifInstruction*)kf;
	else {
		//In this case, we replace the previous last element in kf with this one
		KifElement* last=kf->InstructionRemoveLast();
		ki=new KifInstruction(this,kf);
		ki->instructions.push_back(last);
		ki->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
	}
	ki->action=kifOperators[xn->nodes[0]->value];
	if (ki->action==kifNOTIN) {
		ki->action=kifIN;
		ki->negation=true;
	}

	KifBrowse(xn->nodes[1],ki);
	if (xn->nodes.size()==3) {
		KifElement* kfunc=NULL;
		string name=xn->nodes[2]->value;
		short id=KifNewId(name);
		kfunc=Getbasic(id,kf);
		//We have a WITH description
		if (kfunc==NULL) {
			string message=kifErrorStrings[178]+name;
			long line=GetCurrentLine(0,xn);
			throw new KifRaiseError(message,current->name,line,xn->end);
		}
		if (kfunc->type==kifFunction)
			ki->Add(kfunc);
		else {
			KifElement* decl=kifNULL;
			if (kfunc->type>=kifVariableDeclaration && kfunc->type<=kifFunctionDeclaration)
				decl=((KifVariableDeclaration*)kfunc)->value;							
			if (decl->type!=kifCall) {
				string message="Unknown function: '"+(*kifIdString)[kfunc->Name()]+"'";
				throw new KifRaiseError(message,current->name,current_start,current_end);
			}
			ki->Add(new KifInstance(this,NULL,kfunc->Name(),(KifVariableDeclaration*)kfunc));
		}
	}
	return ki;
}

KifElement* KifCode::KifParseSubFunc(x_node* xn,KifElement* kf) {
	string& name=xn->nodes[0]->nodes[0]->value;
	if (xn->nodes[0]->nodes[0]->nodes.size()!=1)
		name=xn->nodes[0]->nodes[0]->nodes[1]->value;
	short id=KifNewId(name);
	KifElement* declaration=kf->Declaration(id);
	if (declaration==NULL || declaration->Private()) {
		string message="Unknown function: '"+name+"'";
		throw new KifRaiseError(message,current->name,current_start,current_end);
	}

	return KifBrowse(xn->nodes[0],kf);
}

KifElement* KifCode::KifParseSubVar(x_node* xn,KifElement* kf) {
	string& name=xn->nodes[0]->nodes[0]->value;
	short id=KifNewId(name);
	KifElement* declaration=kf->Declaration(id);
	if (declaration==NULL || declaration->Private()) {
		string message="Unknown variable: '"+name+"'";
		throw new KifRaiseError(message,current->name,current_start,current_end);
	}

	return KifBrowse(xn->nodes[0],kf);
}

//A variable is a complex structure involving: expression, crochets
KifElement* KifCode::KifParseVariable(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVariable");
#endif
	string& name=xn->nodes[0]->value;
	short id=KifNewId(name);
	KifElement* declaration=NULL;
	long line=GetCurrentLine(0,xn);
	//specific case, this is itself...
	if (name=="this") {
		if (xn->nodes.size()!=1) {
			string message="Wrong call with 'this'";
			throw new KifRaiseError(message,current->name,line,xn->end);
		}
		kf->Add(new KifThis(this,NULL));
		return kf;
	}

	declaration=Getbasic(id,kf);
	
	
	if (declaration==NULL) {
		string lname=c_Tolower(name,utf8);
		short idlname=KifNewId(lname);
		declaration=Getbasic(idlname,kf);
		if (declaration==NULL || declaration->XIP()==false) {
			string message="Unknown variable: '"+name+"'";
			throw new KifRaiseError(message,current->name,line,xn->end);
		}
	}

	if (!declaration->Variable()) {
		if (xn->nodes.size()==1 && (kifAllTypes[id]==true || declaration->type==kifFunction)) {
			KifElement* ke=new KifSelf(this,kf,declaration);
			ke->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
			return ke;
		}
		if (declaration->type!=kifVariable) {
			string message="Unknown variable: '"+name+"'";
			throw new KifRaiseError(message,current->name,line,xn->end);
		}
	}

	KifInstanceCommon* ki;
	if (xn->nodes.size()>1 && TestKifFunctions(xn->nodes[1]->token,true)) 
		ki=new KifInstanceFunction(this,kf,id,(KifVariableDeclaration*)declaration);
	else {
		ki=new KifInstance(this,kf,id,(KifVariableDeclaration*)declaration);
		if (declaration->type==kifFunctionDeclaration)
			((KifInstance*)ki)->newinstance=kinFunction;
		else
			if (declaration->type==kifFrameDeclaration) {
				KifElement* currentdeclaration=FindFrameForSequence(declaration,xn,-1);
				if (currentdeclaration==kstart)
					((KifInstance*)ki)->newinstance=kinGlobal;
				else
					((KifInstance*)ki)->newinstance=kinFrame;
			}
	}

	ki->Setstringvalue(xn->value);
	ki->Setline(linereference+GetCurrentLine(0,xn->nodes[0]));
	kf->Initvalue(ki);
	KifElement* ret=NULL;
	for (size_t i=1;i<xn->nodes.size();i++) {
		KifElement* retloc=KifBrowse(xn->nodes[i],ki);
		if (retloc!=NULL)
			ret=retloc;
	}
	if (ret==NULL)
		ki->Setself();
	return ki;
}

KifElement* KifCode::KifParseIncrement(x_node* xn,KifElement* kf) {
	KifInstruction* ki=new KifInstruction(this,kf,kifNONE);
	ki->Setline(linereference+GetCurrentLine(0,xn));
	for (size_t i=0;i<xn->nodes.size();i++)
		KifBrowse(xn->nodes[i],ki);	
	return ki;	
}

KifElement* KifCode::KifParseAffectation(x_node* xn,KifElement* kf) {
	KifInstruction* ki=new KifInstruction(this,kf,kifAFFECTATION);
	ki->Setline(linereference+GetCurrentLine(0,xn));
	for (size_t i=0;i<xn->nodes.size();i++)
		KifBrowse(xn->nodes[i],ki);
	
	return ki;
}



KifElement* KifCode::KifParseANumber(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseANumber");
#endif
	string name=xn->value;
	KifElement* kv;
	if (name.find(".")==-1)
		kv=new KifInteger(this,kf,atoi(STR(name)));	
	else
		kv=new KifFloat(this,kf,atof(STR(name)));
	kv->Setline(linereference+GetCurrentLine(0,xn));
	return kv;
}

KifElement* KifCode::KifParseABoolean(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseABoolean");
#endif
	if (xn->value=="true") {
		kf->Add(kifTRUE);
		return kifTRUE;
	}
	kf->Add(kifFALSE);
	return kifFALSE;
}

KifElement* KifCode::KifParseAString(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseAString");
#endif
	string name="";
	size_t i;
	//if (xn->token=="astringdouble") {
	//	for (i=0;i<xn->nodes.size();i++) {
	//		if (xn->nodes[i]->value[0]=='\\')
	//			name+=KifMetaCharacters(xn->nodes[i]->value);
	//		else
	//			name+=xn->nodes[i]->value;
	//	}
	//}
	//else {
	//	for (i=0;i<xn->nodes.size();i++)
	//			name+=xn->nodes[i]->value;
	//}
	string s;
	if (xn->token=="astringdouble") {
		for (i=1;i<xn->value.size()-1;i++) {
			if (xn->value[i]=='\\' && i<xn->value.size()-2) {
				s=xn->value[i];
				char c=xn->value[i+1];								
				if (c>='0' && c<='9') {
					s=c;
					i++;
					if (i<xn->value.size()-2) {
						c=xn->value[i+1];
						if (c>='0' && c<='9') {
							s+=c;					
							i++;
							if (i<xn->value.size()-2) {
								c=xn->value[i+1];
								if (c>='0' && c<='9') {								
									s+=c;
									i++;
									char nbchar=atoi(STR(s));
									name+=nbchar;
									s="";
								}
							}
						}
					}
					i--;
					if (s!="")
						name+=s;
				}
				else {
					s+=c;
					name+=KifMetaCharacters(s);
				}
				i++;

			}
			else
				name+=xn->value[i];
		}
	}
	else {
		for (i=1;i<xn->value.size()-1;i++)
			name+=xn->value[i];
	}
	
	KifString* kv=new KifBaseString(this,kf,name);
	kv->Setline(linereference+GetCurrentLine(0,xn));
	return kv;
}

KifElement* KifCode::FindFrameForSequence(KifElement* ktop,x_node* xn,short id) {
	KifType currenttype=ktop->type;
	KifElement* kbefore=ktop;
	if (currenttype==kifFrameDeclaration) {
		kbefore=ktop->Frame();
		currenttype=kbefore->type;
	}
	if (currenttype==kifInstructionSEQUENCE) {
		//we check if a variable of the same name was not already declared at a previous level...		
		int i=stacking.size()-2;
		//We look for the first non SEQUENCE bloc, which might be embedded one into the others... 
		while (i>=0 && stacking[i]->type==kifInstructionSEQUENCE) 
			i--;
		if (i>=0)
			kbefore=stacking[i];
		if (kbefore!=NULL)  {
			//This level defines the type of this variable as a function or a domain related variable...
			if (id!=-1 && kbefore->Declaration(id)!=NULL) {
				long line=GetCurrentLine(0,xn);
				string message="Variable: '";
				message+=(*kifIdString)[id];
				message+="' has already been declared";
				throw new KifRaiseError(message,current->name,line,xn->end);
			}
		}
	}
	return kbefore;
}

KifElement* KifCode::CreateVariable(x_node* xn,short id,KifElement* kf,KifInstructionType instype) {
#ifdef PROFILING
	profilingcall("Code::CreateVariable");
#endif
	KifElement* ktop=Top();
	KifElement* var;
	long line=GetCurrentLine(0,xn);
	//If it is a global variable, instance is unique
	if (kf->Declaration(id)!=NULL) {
		string message="Variable: '";
		message+=(*kifIdString)[id];
		message+="' has already been declared";
		throw new KifRaiseError(message,current->name,line,xn->end);
	}

	KifType currenttype=kifVOID;
	if (ktop!=NULL) {
		KifElement* kbefore=FindFrameForSequence(ktop,xn,id);
		currenttype=kbefore->type;
	}
	
	if (common==true && currenttype!=kifFrame) {
		string message="Common variable can only be declared in a frame: ";
		message+=(*kifIdString)[id];
		throw new KifRaiseError(message,current->name,line,xn->end);
	}
	
	if (currenttype==kifVOID)
		var=new KifVariableDeclaration(this,kf,id);
	else
		//Otherwise, we keep a track of that specific frame
		if (currenttype==kifFrame) {
			if (common)
				var=new KifFrameDeclarationCommon(this,kf,id,ktop);
			else
				var=new KifFrameDeclaration(this,kf,id,ktop);
		}
		else
			var=new KifFunctionDeclaration(this,kf,id,ktop);
	
	var->Setprivate(prive);
	
	var->Setline(linereference+GetCurrentLine(0,xn));
	if (xn->nodes.size()>=3) {
		for (int nxt=2;nxt<xn->nodes.size();nxt++) {
			if (xn->nodes[nxt]->token=="depend") {
				string funcname=xn->nodes[nxt]->nodes[0]->value;
				short idf=KifNewId(funcname);
				KifElement* kfunc=NULL;
				kfunc=Getbasic(idf,kf);
				//We have a WITH description
				if (kfunc==NULL) {
					string message=kifErrorStrings[178]+funcname;				
					throw new KifRaiseError(message,current->name,line,xn->end);
				}
				if (kfunc->type==kifFunction)
					var->Setfunction(kfunc);
				else {
					KifElement* decl=kifNULL;
					if (kfunc->type>=kifVariableDeclaration && kfunc->type<=kifFunctionDeclaration)
						decl=((KifVariableDeclaration*)kfunc)->value;							
					if (decl->type!=kifCall) {
						string message="Unknown function: '"+(*kifIdString)[kfunc->Name()]+"'";
						throw new KifRaiseError(message,current->name,current_start,current_end);
					}
					var->Setfunction(new KifInstance(this,NULL,kfunc->Name(),(KifVariableDeclaration*)kfunc));
				}
			}
			else {
				if (xn->nodes[nxt]->token!="declarationlist") {
					KifInstruction* ki=new KifInstruction(this,var,kifINITIALISATION);
					ki->Setline(linereference+GetCurrentLine(0,xn->nodes[nxt]));
					var->Setinitialisation(ki);
					ki->instructiontype=instype;
					KifBrowse(xn->nodes[nxt],ki);		
					//we cannot keep it as a value...
					ki->instructiontype=kifNOTYPE;
				}
			}
		}
	}

	return var;
}

KifElement* KifCode::KifParseVarFrame(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarFrame");
#endif
	string& type=xn->nodes[0]->value;
	short id=KifNewId(type);
	string& name=xn->nodes[1]->value;
	short idname=KifNewId(name);
	KifElement* ke;
	ke=Getframe(id,kf);
	if (ke==NULL) {
		string message="Unknown type: '"+type+"'";
		long line=GetCurrentLine(0,xn);
		throw new KifRaiseError(message,current->name,line,xn->end);
	}
	KifElement* var=CreateVariable(xn,idname,kf,kifNOTYPE);
	((KifVariableDeclaration*)var)->value=ke;
	//In the case of a frame element defined within a frame, we add the postpone flag
	//which delays if necessary, the call to the _initial frame function for that variable frame...
	if (kf!=kstart && kf->type==kifFrame)
		var->Setpostpone(true);
	kf->Set(idname,var,NULL);

	return var;
}

KifElement* KifCode::KifParseVarSelf(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarSelf");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifSelf* kv=new KifSelf(this,var,kifNULL);	
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarCall(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarCall");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifCall* kv=new KifCall(this,var,NULL);	
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarDate(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarTime");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifDate* kv=new KifDate(this,var);	
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarTime(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarTime");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifTime* kv=new KifTime(this,var);	
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}



KifElement* KifCode::KifParseVarFraction(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarInt");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifFraction* kv=new KifFraction(this,var,0,1);	
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarKifKiF(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarKifKiF");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifKiF* kv=new KifKiF(this,var);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarInt(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarInt");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifFULLINTEGER);
	KifInteger* kv=new KifInteger(this,var);	
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarString(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarString");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifFULLSTRING);
	KifString* kv=new KifBaseString(this,var);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarFloat(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarFloat");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifFULLFLOAT);
	KifFloat* kv=new KifFloat(this,var);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarBoolean(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarBoolean");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifBoolean* kv=new KifBoolean(this,var);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}
KifElement* KifCode::KifParseVarFile(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarFile");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifFile* kv=new KifFile(this,var);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}
KifElement* KifCode::KifParseVarVector(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarVector");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifVector* kv=new KifVector(this,var);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarList(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarVector");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifList* kv=new KifList(this,var);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarMap(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarMap");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifMap* kv=new KifMap(this,var);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarMatrix(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarMatrix");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifMatrix* kv=new KifMatrix(this,var,id);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarTree(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarIterator");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifTree* kv=new KifTree(this,var,kifNULL);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}


KifElement* KifCode::KifParseVarIterator(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarIterator");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifIterator* kv=new KifIterator(this,var,false);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseVarRIterator(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseVarRIterator");
#endif
	short id=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,id,kf,kifNOTYPE);
	KifIterator* kv=new KifIterator(this,var,true);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(id,var,NULL);
	return var;
}

KifElement* KifCode::KifParseMultiDeclaration(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseDeclaration");
#endif
	string& type=xn->nodes[0]->value;
	bool oldprive=prive;
	bool oldcommon=common;
	if (xn->nodes[0]->nodes.size() && xn->nodes[0]->nodes[0]->token=="feature") {
		string& s=xn->nodes[0]->nodes[0]->nodes[0]->token;
		if (s=="private") {
			prive=true;
			if (xn->nodes[0]->nodes[0]->nodes.size()!=1)
				common=true;
		}
		else
			if (s=="common")
				common=true;
		type=xn->nodes[0]->nodes[1]->value;
	}
	
	KifElement* element=NULL;
	int last=xn->nodes.size()-1;
	bool recall=false;
	
	if (xn->nodes[last]->token=="declarationlist") {
		x_node* xnew=new x_node();
		xnew->token=xn->nodes[0]->token;
		xnew->value=type;
		xn->nodes[last]->nodes.insert(xn->nodes[last]->nodes.begin(),xnew);
		recall=true;
	}

	if (kifTypes.find(type)!=kifTypes.end()) {
		KifParseElement kpe=kifTypes[type];
		element=(this->*kpe)(xn,kf);
	}
	else
		if (kifExternalTypes.find(type)!=kifExternalTypes.end()) {
			KifExternalParse kext=kifExternalTypes[type];
			element=(*kext)(this,xn,kf);
		}
		else
			KifParseVarFrame(xn,kf);
	
	if (recall)
		KifParseMultiDeclaration(xn->nodes[last],kf);
	prive=oldprive;
	common=oldcommon;
	return element;
}


KifElement* KifCode::KifParseDeclaration(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseDeclaration");
#endif
	string& type=xn->nodes[0]->value;
	bool oldprive=prive;
	if (xn->nodes[0]->nodes[0]->token=="private") {
		prive=true;
		type=xn->nodes[0]->nodes[1]->value;
	}
	KifElement* element=NULL;
	if (kifTypes.find(type)!=kifTypes.end()) {
		KifParseElement kpe=kifTypes[type];
		element=(this->*kpe)(xn,kf);
	}
	else
		if (kifExternalTypes.find(type)!=kifExternalTypes.end()) {
			KifExternalParse kext=kifExternalTypes[type];
			element=(*kext)(this,xn,kf);
		}
		else
			KifParseVarFrame(xn,kf);
	prive=oldprive;
	return element;
}

KifElement* KifCode::KifParseList(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseList");
#endif
	//KifInstruction* kbloc=new KifInstruction(this,kf,kifBLOC);
	KifInstruction kbloc(NULL,NULL,kifBLOC);
	KifBrowse(xn->nodes[0],&kbloc);
	KifElement* ke=kbloc.instructions[0];
	kf->Push(ke);
	if (xn->nodes.size()==2)
		KifBrowse(xn->nodes[1],kf);
	return ke;
}


KifElement* KifCode::KifParseValVector(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseValVector");
#endif
	KifVector* kvect=new KifVector(this,kf);
	int i;
	for (i=0;i<xn->nodes.size();i++)
		KifBrowse(xn->nodes[i],kvect);
	kvect->evaluate=false;
	for (i=0;i<kvect->values.size();i++) {
		if (kvect->values[i]->type<kifString || kvect->values[i]->type>kifBoolean) {
			kvect->evaluate=true;
			break;
		}
	}
	return kvect;
}

KifElement* KifCode::KifParseDico(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseDico");
#endif
	KifElement* key=KifBrowse(xn->nodes[0],kf);
	//KifInstruction* kbloc=new KifInstruction(this,kf,kifBLOC);
	KifInstruction kbloc(NULL,NULL,kifBLOC);
	KifBrowse(xn->nodes[1],&kbloc);
	KifElement* val=kbloc.instructions[0];

	KifMap* kmap=(KifMap*)kf;
	string ky=key->String();
	kmap->Push(ky,val);
	if (xn->nodes.size()==3)
		KifBrowse(xn->nodes[2],kf);
	return kf;
}


KifElement* KifCode::KifParseValMap(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseValMap");
#endif
	KifMap* kmap=new KifMap(this,kf);
	for (int i=0;i<xn->nodes.size();i++)
		KifBrowse(xn->nodes[i],kmap);
	hmap<string,KifElement*>::iterator it;
	for (it=kmap->values.begin();it!=kmap->values.end();it++) {
		if (it->second->type<kifString || it->second->type>kifBoolean) {
			kmap->evaluate=true;
			break;
		}
	}
	return kmap;	
}


//Function creation
KifElement* KifCode::KifParseFunction(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseFunction");
#endif
	string name=xn->nodes[1]->value;
	short idname=KifNewId(name);
	long line=GetCurrentLine(0,xn);
	if (KifBaseFunctionTest(idname)!=NULL && KifConversion(name)==false) {		
		if (kifMethods.find(idname)==kifMethods.end()) {
			string message="Error: Predefined function, consider choosing another name: '"+name+"'";
			throw new KifRaiseError(message,current->name,line,xn->end);
		}
	}

	if (kf!=kstart) 
		kifDeclaredFunction[idname]=true;
	KifFunction* kfunc=NULL;
	KifElement* kprevious=kf->Declaration(idname);
	bool autorun=false;
	bool privatefunction=false;
	bool strictfunction=false;

	//Two cases:
	//If this is the first implementation of that function OR NO predeclaration had been issued OR it is not a function, then we create a new function
	if (kprevious==NULL || kprevious->Predeclared()==false || kprevious->isFunction()==false) {
		string typefunction;
		if (xn->nodes[0]->nodes.size()==3) {
			strictfunction=true;
			privatefunction=true;
			typefunction=xn->nodes[0]->nodes[2]->value;
		}
		else
			if (xn->nodes[0]->nodes.size()==2) {
				if (xn->nodes[0]->nodes[0]->value=="strict")
					strictfunction=true;					
				else
					privatefunction=true;
				typefunction=xn->nodes[0]->nodes[1]->value;
			}
			else
				typefunction=xn->nodes[0]->nodes[0]->value;

		if (typefunction=="polynomial")
			kfunc=new KifPolynomial(this,kf,idname);			
		else
			if (typefunction=="thread")
				kfunc=new KifThread(this,kf,idname);			
			else
				if (typefunction=="protected")
					kfunc=new KifThread(this,kf,idname,true);	
				else {
					kfunc=new KifFunction(this,kf,idname);
					if (typefunction=="autorun")
						autorun=true;
				}
	}

	//If we already have an implementation for that function, either it is a predeclaration, then we simply use it
	//Or this predeclaration is NOT a function
	if (kprevious!=NULL) {
		if (kprevious->isFunction()) {
			if (kprevious->Predeclared()) {
				kfunc=(KifFunction*)kprevious; //we use it
				kprevious=NULL;
				//We clear our argument list and declaration list
				kfunc->declarations.clear();
				kfunc->arguments.clear();
			}//else, we will add this new function to a previous declaration...
			else
				if (kprevious->isUsed()==true)
					kprevious=NULL;
				else //if it has been implemented in the mother frame already, then it should not be attached to that set of functions
					if (kf!=kprevious->Frame())
						kprevious=NULL;
		}
		else
			kprevious=NULL;
	}

	if (kfunc==NULL) {
		string message="Error: This function has already been used in a call: '"+name+"'";
		throw new KifRaiseError(message,current->name,line,xn->end);
	}

	kfunc->privatefunction=privatefunction;
	kfunc->strict=strictfunction;
	Push(kfunc);
	kfunc->Setline(linereference+GetCurrentLine(1,xn));
	int last=xn->nodes.size()-1;
	if (xn->nodes[last]->token=="declarationending") {
		kfunc->choice=0;
		//we process the arguments
		KifBrowse(xn->nodes[2],kfunc);
		kfunc->choice=2;
	}
	else {
		if (xn->nodes[2]->token=="instruction") {
			kfunc->choice=1;
			KifBrowse(xn->nodes[2],kfunc);
		}
		else {
			kfunc->choice=0;
			KifBrowse(xn->nodes[2],kfunc);
			kfunc->choice=1;
			KifBrowse(xn->nodes[3],kfunc);
		}
	}
	
	if (kprevious!=NULL)
		kprevious->Addfunction(kfunc);
	else
		kf->Set(idname,kfunc,NULL);

	Pop();
	if (autorun) {
		if (kfunc->arguments.size()!=0) {
			string message="Error: An AUTORUN cannot have parameters: '"+name+"'";
			throw new KifRaiseError(message,current->name,line,xn->end);
		}
		if (kf==kstart || kf->type!=kifFrame)
			new KifCallFunctionGeneral(this,kf,idname,kfunc);
		kfunc->autorun=true;
	}
	return kfunc;
}


KifElement* KifCode::KifParseFrame(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifParseFrame");
#endif
	//We create a frame
	//The name is the next parameter
	string name=xn->nodes[0]->value;
	short idname=KifNewId(name);
	KifFrame* kframe=NULL;
	KifElement* ke;
	ke=kf->Declaration(idname);

	if (ke==NULL)
		kframe=new KifFrame(this,kf,idname);
	else {
		if (ke->type==kifFrame) {
			kframe=(KifFrame*)ke;
			//if (kframe->declared==false)
			//	kframe=NULL;
		}
	}
	if (kframe==NULL) {
		long line=GetCurrentLine(0,xn);
		string message="Error: This frame has already been declared:"+name;
		throw new KifRaiseError(message,current->name,line,xn->end);
	}

	if (xn->nodes[1]->token=="declarationending") {
		kframe->declared=true;
		kf->Set(kframe->name,kframe,NULL);
		return kframe;
	}


	Push(kframe);
	kframe->Setline(linereference+GetCurrentLine(0,xn));

	//If it is a sub-frame definition
	if (kf->type==kifFrame && kstart!=kf)
		//We copy all our declarations in it
		//These declarations, will be replaced by local ones if necessary
		kf->Sharedeclaration(kframe);
	//We then record this new Frame in our instructions list
	kifAllTypes[kframe->name]=true;
	//We also store it at the TOP level, so that others can have access to it...
	kstart->Set(kframe->name,kframe,NULL);
	if (xn->nodes[1]->token=="depend") {
		string funcname=xn->nodes[1]->nodes[0]->value;			
		short idf=KifNewId(funcname);
		KifElement* kfunc=NULL;
		kfunc=Getbasic(idf,kf);
		//We have a WITH description
		if (kfunc==NULL) {
			long line=GetCurrentLine(0,xn);
			string message=kifErrorStrings[178]+funcname;				
			throw new KifRaiseError(message,current->name,line,xn->end);
		}
		if (kfunc->type==kifFunction)
			kframe->Setfunction(kfunc);
		else {
			KifElement* decl=kifNULL;
			if (kfunc->type>=kifVariableDeclaration && kfunc->type<=kifFunctionDeclaration)
				decl=((KifVariableDeclaration*)kfunc)->value;							
			if (decl->type!=kifCall) {
				string message="Unknown function: '"+(*kifIdString)[kfunc->Name()]+"'";
				throw new KifRaiseError(message,current->name,current_start,current_end);
			}
			kframe->Setfunction(new KifInstance(this,NULL,kfunc->Name(),(KifVariableDeclaration*)kfunc));
		}

		KifBrowse(xn->nodes[2],kframe);
	}
	else
		KifBrowse(xn->nodes[1],kframe);
	Pop();
	return kframe;
}


KifElement* KifCode::KifBrowse(x_node* xn,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifBrowse");
#endif
    if (xn==NULL)
        return NULL;

	KifElement* ke=NULL;

	if (kifFunctions.find(xn->token)!=kifFunctions.end())
		ke=(this->*kifFunctions[xn->token])(xn,kf);
	else {
		for (size_t i=0;i<xn->nodes.size();i++) {
			KifElement* s=KifBrowse(xn->nodes[i],kf);
			if (s!=NULL)
				ke=s;
		}
	}
	return ke;
}

void KifCode::Loadfile(string filename,KifCode* loader) {
#ifdef PROFILING
	profilingcall("Code::Loadfile");
#endif
	x_readfile xf(STR(filename));
	Load(&xf);
	Setloader(loader);
}

void KifCode::Loadfile(ifstream* f,string filename,long pos,KifCode* loader) {
#ifdef PROFILING
	profilingcall("Code::Loadfile");
#endif
	
	bool onlycomp=false;
	if (f->fail() ) {
		delete f;
		string compiled=filename+".kif";
		f=new ifstream(STR(compiled),modeOuverture);		
		if (f->fail()) {
			delete f;
			string message="Cannot open kif file: ";
			message+=filename;		
			throw new KifRaiseError(message,filename,-1,-1);
		}
		delete f;
		f=NULL;
		onlycomp=true;
	}

	x_readfile xf(f,STR(filename),pos);
	Load(&xf);
	Setloader(loader);
	string s;
	tabledebugfilename[linereference]=filename;
	long l=1;
	delete f;
	if (onlycomp==false) {
		f=new ifstream(STR(filename),modeOuverture);
		while (!f->eof()) {
			getline(*f,s);
			if (s!="") {
				string strim=s;
				Trim(strim);
				if (strim!="") {
					if (debugging==true)
						tabledebug[linereference+1]=s;
					tabledebugline[linereference+1]=l;
				}
			}
			linereference+=1;
			l+=1;
		}		
		delete f;
	}
}

KifElement* KifCode::EvaluateVector(KifElement* dom,string s) {
	
	x_readstring xr(s);
	current=&xr;	
	
	bnfkif->baseline=0;
	bnfkif->loadtoken(&xr);
    bnfkif->fx=&xr;	
	bnfkif->x_recordcr.clear();
    
	string lret;
    x_node* xn=new x_node;
    bnfkif->gFail=0;
    char res=bnfkif->m_valvector(lret,&xn);
	string message;
	if (res!=1)
		return Returnerror("KIF(230): Unknown expression");
	
	KifElement* kret=kifNULL;
	if (dom==NULL)
		dom=kstart;
	try {
		kret=KifBrowse(xn,dom);
	}
	catch(KifRaiseError* m) {
		delete xn;
		string message=m->message;
		delete m;
		return Returnerror(message);
	}
	return kret;
}

KifElement* KifCode::EvaluateMap(KifElement* dom,string s) {
	
	x_readstring xr(s);
	current=&xr;	
	
	bnfkif->baseline=0;
	bnfkif->loadtoken(&xr);
    bnfkif->fx=&xr;	
	bnfkif->x_recordcr.clear();
    
	string lret;
    x_node* xn=new x_node;
    bnfkif->gFail=0;
    char res=bnfkif->m_valmap(lret,&xn);
	string message;
	if (res!=1)
		return Returnerror("KIF(230): Unknown expression");
	
	KifElement* kret=kifNULL;
	if (dom==NULL)
		dom=kstart;
	try {
		kret=KifBrowse(xn,dom);
	}
	catch(KifRaiseError* m) {
		delete xn;
		string message=m->message;
		delete m;
		return Returnerror(message);
	}
	return kret;
}

KifElement* KifCode::Evaluate(KifElement* kf,string sbase,bool commandline) {
#ifdef PROFILING
	profilingcall("Code::Evaluate");
#endif
	string s;
	if (commandline==true)
		s="float f,g,h; int i,j,k; string s,t,u; vector v; map m;\n";
	s+=sbase;

	x_readstring xr(s);
	current=&xr;	
	bnfkif->baseline=0;
	bnfkif->loadtoken(&xr);
	x_node* xn=bnfkif->x_parsing(&xr,PARTIAL);
	string message;
	if (xn==NULL)
		return Returnerror("KIF(230): Unknown expression");

	KifElement* kret=kifNULL;
	try {
		kret=KifBrowse(xn,kf);
	}
	catch(KifRaiseError* m) {
		delete xn;
		string message=m->message;
		delete m;
		return Returnerror(message);
	}
	return kret;
}

Exported void KifCode::Setbaseline(int i) {
	bnfkif->baseline=i;
}

void GetXNKeys(map<string,unsigned short>& keys, x_node* xn) {
	if (keys.find(xn->token)==keys.end())
		keys[xn->token]=keys.size();
	
	if (xn->value!="" && keys.find(xn->value)==keys.end())
		keys[xn->value]=keys.size();
	
	for (int i=0;i<xn->nodes.size();i++)
		GetXNKeys(keys,xn->nodes[i]);
}				  

void AfficheXN(x_node* xn) {
		cout<<STR(xn->token)<<" --> "<<STR(xn->value)<<endl;
	
	for (int i=0;i<xn->nodes.size();i++)
		AfficheXN(xn->nodes[i]);
}				  

void SaveXNKeys(ofstream& f,map<string,unsigned short>& keys, x_node* xn) {
	if (xn->nodes.size()==0)
		f<<"@"<<keys[xn->token]<<"$";
	else
		f<<"@"<<keys[xn->token]<<"#";
	if (xn->value=="")
		f<<0;
	else
		f<<keys[xn->value];
	
	if (xn->nodes.size()==0)
		return;
	
	f<<"{";
	for (int i=0;i<xn->nodes.size();i++)
		SaveXNKeys(f,keys,xn->nodes[i]);
	f<<"}";
}		  
	
void SaveXN(string filename,x_node* xn) {
	map<string,unsigned short> keys;
	filename+=".kif";
	ofstream f(STR(filename),ios::binary);
	f<<"kif:\r";
	f<<"@JekiffeKiFcommeunouf@\r";
	keys[filename]=1;
	GetXNKeys(keys,xn);
	map<string,unsigned short>::iterator it;
	for (it=keys.begin();it!=keys.end();it++)
		f<<it->second<<" "<<STR(it->first)<<"\r";
	f<<"*\r";
	SaveXNKeys(f,keys, xn);
}

x_node* ReadXN(ifstream& f,map<unsigned short,string>& keys,bool error) {
	if (f.eof()) {
		error=true;
		return NULL;
	}
	char c=f.get();
	if (f.eof() || error==true || c=='}')
		return NULL;
	if (c!='@') {
		error=true;
		return NULL;
	}
	string k;
	short key,val;
	x_node* xn;

	f>>key;
	f>>c;
	f>>val;
	if (c=='$') {
		xn=new x_node();
		xn->set(keys[key],keys[val]);
		return xn;
	}
	else
		if (c!='#') {
			error=true;
			return NULL;
		}
	f>>c;	
	if (f.eof() || c!='{') {
		error=true;
		return NULL;
	}
	
	xn=new x_node();
	xn->set(keys[key],keys[val]);
	
	x_node* xsub=xn;
	while (xsub!=NULL) {
		xsub=ReadXN(f,keys,error);
		if (xsub!=NULL)
			xn->nodes.push_back(xsub);
	}
	
	if (error) {
		delete xn;
		return NULL;
	}
	
	return xn;
}
	
x_node* LoadXN(string filename) { 
	map<unsigned short,string> keys;
	keys[0]="";
	filename+=".kif";
	ifstream f(STR(filename),ios::binary);
	char buff[1000];
	f.getline(buff,1000,'\r');
	if (!strcmp(buff,"kif:"))
		f.getline(buff,1000,'\r');
	if (strcmp(buff,"@JekiffeKiFcommeunouf@"))
		return NULL;
	
	char* pos;
	short key;
	f.getline(buff,1000,'\r');
	while (!f.eof() && buff[0]!='*') {
		pos=strchr(buff,' ');
		if (pos!=NULL) {
			*pos=0;
			key=atoi(buff);
			keys[key]=pos+1;
		}
		f.getline(buff,1000,'\r');
	}

	if (f.eof())
		return NULL;
	bool error=false; 
	return ReadXN(f,keys,error);
}
	
bool Compiled(string base) {
	string compiled=base+".kif";
	int stinit=-1;
	int stcible=-1;
	struct stat scible;
	struct stat sinit;
	FILE* init=fopen((char*)base.c_str(),"r");
	FILE* cible=fopen((char*)compiled.c_str(),"r");
	if (init!=NULL) {
		if (cible!=NULL) {
#if  defined(WIN32) | defined(APPLE) | defined(XIPFSTAT64)
			stinit=fstat(init->_file,&sinit);
			stcible=fstat(cible->_file,&scible);
#else
			stinit=fstat(init->_fileno,&sinit);
			stcible=fstat(cible->_fileno,&scible);
#endif
			fclose(cible);
		}
		fclose(init);
	}
	else
		if (cible!=NULL) {
			fclose(cible);
			return true;
		}
	if (stinit!=-1 && stcible!=-1 && scible.st_mtime > sinit.st_mtime)
		return true;
	return false;
}
	
void KifCode::Load(x_reading* xr) {
#ifdef PROFILING
	profilingcall("Code::Load");
#endif 
	current=xr;
	short n=KifNewId("_paths");
	KifConst* var=(KifConst*)kstart->Declaration(n);
	KifVector* vargs=(KifVector*)var->value;
	vargs->Push(new KifBaseString(this,NULL,xr->name));
	bnfkif->loadtoken(xr);
	x_node* xn=NULL;
	
	bool comp=compile;
	if (Compiled(xr->name)) {
		xn=LoadXN(xr->name);
		if (xn!=NULL)
			comp=false;
	}
	
	if (xn==NULL)
		xn=bnfkif->x_parsing(xr,PARTIAL);
	if (xn==NULL) {
		long line=bnfkif->x_linenumber(xr->lastposerror);
		string message="Error while reading KIF file: ";
		if (xr->error()) {
			message="Unknown file: ";
			message+=xr->name;
		}
		else
			if (xr->errornumber!=-1)
				message+=bnfkif->x_errormsg(xr->errornumber);
			else
				message+=xr->labelerror;
		throw new KifRaiseError(message,current->name,line,xr->lastposerror);
	}
	//AfficheXN(xn);
	if (comp)
		SaveXN(xr->name,xn);
	try {
		Push(kstart);
		KifBrowse(xn,kstart);
		Pop();
	}
	catch(KifRaiseError* m) {
		delete xn;
		throw m;
	}		

	delete xn;
}

void KifCode::Run(int from) {
	kstart->Run(from);
}

KifElement* KifCode::Search(string name) {
#ifdef PROFILING
	profilingcall("Code::Search");
#endif
	hmap<short,KifElement*>::iterator iter=kstart->declarations.begin();
	for (;iter!=kstart->declarations.end();iter++) {
		string val=(*kifIdString)[iter->first];
		val=c_Tolower(val,utf8);
		if (val==name)
			return iter->second;
	}
	return NULL;
}

KifElement* KifCode::Searchraw(string name) {
#ifdef PROFILING
	profilingcall("Code::Searchraw");
#endif
	hmap<short,KifElement*>::iterator iter=kstart->declarations.begin();
	for (;iter!=kstart->declarations.end();iter++) {
		string val=(*kifIdString)[iter->first];
		if (val==name)
			return iter->second;
	}
	return NULL;
}


void DisplayClean(string& s, char* buffer, int& compte) {
	string blanc;
	compte+=strlen(buffer);
	while(compte>0) {
		cout<<(char)8;
		compte--;
		blanc+=" ";
	}	
	cout<<buffer<<s<<blanc;
	for (int i=0;i<blanc.size();i++)
		cout<<(char)8;
	compte=s.size();
}

bool KifCode::Debugging(KifObject* func,KifElement* ke,KifDomain* dom,KifCallFunction* callfunc) {
#ifdef PROFILING
	profilingcall("Code::Debugging");
#endif
	
	if (debugging==false)
		return true;

	if (gotoline==-10) {
		cout<<"h for help"<<Endl;
		gotoline=-1;
	}

	long cline=tabledebugline[ke->Line()];

	if (breakpoint==cline)
		debug=true;
	else
		if (gotoline==cline) {
			debug=true;
			gotoline=-1;
		}


	if (debug==false)
		return true;

	infunction=false;


	string s;
	if (tabledebug.find(ke->Line())!=tabledebug.end()) {
		s=tabledebug[ke->Line()];
		s=Trim(s);
	}

	if (func->Name()!=-1 && func->Name()!=idsequence)
		cout<<"["<<STR((*kifIdString)[func->Name()])<<"]"<<cline<<"> "<<STR(s)<<Endl;
	else
		cout<<cline<<"> "<<STR(s)<<Endl;

	s="x";
	int compte;
	KifElement* v;
	int j;
	short id;
	while (s!="") {

		if (watches.size()) {
			for (j=0;j<watches.size();j++) {
				id=KifNewId(watches[j]);
				v=Get(id,dom);
				if (v==NULL || v==kifNULL)
					continue;
				v=v->Returnvalue();
				cout<<STR(watches[j])<<": "<<STR(v->String())<<Endl;
			}
		}

		sprintf_s(buffer,20,"%d> ",cline);
		cout<<buffer;		
		compte=strlen(buffer);
		int c;
		s="";
		int hist=history.size()-1;
		do {
			c=GETCH(false);
#ifdef WIN32
			if (c==224) {
				c=GETCH(false);
				s="";
				DisplayClean(s, buffer, compte);
				compte=0;

				if (hist<0) {
					hist=0;
					continue;
				}
				if (hist>=history.size()) {
					hist=history.size()-1;
					continue;
				}
				if (c==72) {//up
					s=history[hist];
					hist--;
					cout<<s;
					compte=s.size();
					continue;
				}
				if (c==80) {//down
					s=history[hist];
					hist++;
					cout<<s;
					compte=s.size();
					continue;
				}
				continue;
			}
#endif
			if (c==',' || c=='.') {
				if (s=="" || s[0]!='$') {
					s="";
					DisplayClean(s, buffer, compte);
					compte=0;

					if (hist<0) {
						hist=0;
						continue;
					}
					if (hist>=history.size()) {
						hist=history.size()-1;
						continue;
					}
					if (c==',') {//up
						s=history[hist];
						hist--;
					}
					if (c=='.') {//down
						s=history[hist];
						hist++;
					}
					cout<<s;
					compte=s.size();
					continue;
				}
			}

			if (c>=32) {
				s+=(char)c;
				cout<<(char)c;
				compte++;
			}
			else
				if (c==8) {
					if (s!="") {
						cout<<(char)c<<" "<<(char)c;				
						s=s.substr(0,s.length()-1);
					}
					c=33;
				}
		}
		while (c>=32);

		if (s=="$") {
			cout<<Endl<<"End"<<Endl;
			debugging=false;
			return false;
		}

		if (s=="$$") {
			cout<<Endl<<"End"<<Endl;
			exit(-1);
		}

		if (s=="H") {
			cout<<Endl;
			for (j=0;j<history.size();j++)
				cout<<j<<":"<<STR(history[j])<<Endl;
			continue;
		}

		if (s!="" && s[0]=='!') {
			j=atoi(STR(s)+1);
			if (j<0 || j>=history.size()) {
				s="";
				DisplayClean(s, buffer, compte);
				compte=0;
				continue;
			}
			s=history[j];
			compte=s.size();
			DisplayClean(s, buffer, compte);
		}

		if (s!="")
			history.push_back(s);

		if (s=="h") {
			cout<<Endl<<Endl<<"$: stop debugging"<<Endl;
			cout<<"$$: termination"<<Endl;
			cout<<"o: leave current function"<<Endl;
			cout<<"i: inside function"<<Endl;
			cout<<"g line: goto line"<<Endl;
			cout<<"b line: breakpoint line"<<Endl;
			cout<<"s: stack"<<Endl;
			cout<<"n (nb lines): list following instructions"<<Endl;
			cout<<"l f t: list line from f to t"<<Endl;
			cout<<"w variable: add a watch on a variable"<<Endl;
			cout<<"r variable: remove a watch on a variable"<<Endl;
			cout<<"H: command history"<<Endl;
			cout<<"!nb: command renacted"<<Endl;
			cout<<"<: down in history"<<Endl;
			cout<<">: up in history"<<Endl;
			cout<<"$variable"<<Endl;
			cout<<"$expression;"<<Endl<<Endl;
			continue;
		}


		if (s=="i") {
			cout<<Endl;
			infunction=true;
			return true;
		}


		if (s=="o") {
			cout<<Endl;
			return false;
		}

		if (s!="" && s[0]=='w') {
			cout<<Endl;
			string var;
			if (s=="w" || s.size()<3) {
				for (j=0;j<watches.size();j++)
					cout<<STR(watches[j])<<Endl;
				continue;
			}
			var=s.substr(2,s.length()-2);
			bool found=false;
			for (j=0;j<watches.size();j++) {
				if (watches[j]==var) {
					found=true;
					break;
				}
			}
			if (!found)
				watches.push_back(var);
			continue;
		}

		if (s!="" && s[0]=='r') {
			cout<<Endl;
			string var;
			if (s=="r" || s.size()<3) {
				for (j=0;j<watches.size();j++)
					cout<<watches[j]<<Endl;
				continue;
			}
			var=s.substr(2,s.length()-2);
			for (j=0;j<watches.size();j++) {
				if (watches[j]==var) {
					watches.erase(watches.begin()+j);
					break;
				}
			}
			continue;
		}

		if (s!="" && (s[0]=='g' || s[0]=='b')) {
			cout<<Endl;
			j=atoi(STR(s)+2);
			if (s[0]=='b') {
				debug=true;
				infunction=true;
				if (s=="b")
					breakpoint=-1;
				else
					breakpoint=j;
				continue;
			}
			else {
				if (s=="g") 
					gotoline=-1;
				else
					gotoline=j;
				infunction=true;
				debug=false;
				return true;
			}
		}

		int mxj,ln;
		map<long,string>::iterator mx=--tabledebug.end();
		long maxline=mx->first;
		if (s=="s") {
			cout<<Endl;
			for (j=1;j<stacking.size();j+=2)
				cout<<"s"<<j<<"> "<<stacking[j]->Name()<<Endl;
		}
		else
			if (s!="" && s[0]=='l') {
				cout<<Endl;
				vector<string> positions;
				mxj=Stringsplit(s," ",positions);
				
				switch(mxj) {
				case 1:
					ln=0;					
					mxj=maxline;
					break;
				case 2:
					ln=atoi(STR(positions[1]));
					mxj=maxline;
					break;
				default:
					ln=atoi(STR(positions[1]));
					mxj=atoi(STR(positions[2]));
				}
				if (mxj>maxline)
					mxj=maxline;
				while (ln<=mxj) {				
					if (tabledebug.find(ln)==tabledebug.end()) {
						ln++;
						continue;
					}
					s=tabledebug[ln];
					cout<<ln<<"> "<<tabledebug[ln]<<Endl;
					ln++;
				}
			}
			else
				if (s!="" && s[0]=='n') {
					cout<<Endl;
					mxj=1;
					if (s!="n")
						mxj=atoi(STR(s)+2);
					ln=cline;
					j=0;
					if ((cline+mxj)>maxline)
						mxj=maxline-cline;

					while (j<=mxj) {				
						if (tabledebug.find(ln)==tabledebug.end()) {
							ln++;
							j++;
							continue;
						}
						s=tabledebug[ln];
						cout<<ln<<"> "<<tabledebug[ln]<<Endl;
						ln++;
						j++;
					}
				}
				else
					if (s!="" && s[0]=='$') {
						cout<<Endl;
						s=s.substr(1,s.size()-1);
						if (s[s.size()-1]!=';') {							
							if (kifStringId->find(s)==kifStringId->end()) {
								cout<<"Unknown variable"<<Endl;
								continue;
							}
							v=Get((*kifStringId)[s],dom);
							if (v==NULL || v==kifNULL) {
								cout<<"Unknown variable"<<Endl;
								continue;
							}
							v=v->Returnvalue();
							cout<<STR(v->String())<<Endl;
						}
						else {
							KifElement* kres;
							kres=PostEval(this,s,kifTypeSTRING,dom);
							if (kres==NULL || kres==kifNULL)
								cout<<"null"<<Endl;
							else 
								cout<<STR(kres->String())<<Endl;
						}
					}
	}
	char car=8;
	while(compte>0) {
		cout<<car;
		compte--;
	}
	s="                   ";
	cout<<STR(s);
	compte=s.size();
	while(compte>=0) {
		cout<<car;
		compte--;
	}
	return true;
}


KifElement* KifCode::Execute(KifFunction* func,vector<KifElement*>& parameters) {
#ifdef PROFILING
	profilingcall("Code::Execute");
#endif
	string met="__"+func->name;
	short idmet=KifNewId(met);
	KifCallFunctionGeneral kfunc(NULL,kstart,idmet,(KifFunction*)func);
	kfunc.kifcode=this;
	hmap<short,KifElement*> stacks;
	kfunc.SetParameters(parameters,&stacks);
	Push(kstart);
	Push(&kfunc);
	KifElement* ret=kfunc.Execute(kifNULL,kstart);
	Pop();
	Pop();
	kfunc.Resetdeclaration(stacks);
	return ret;
}

void KifCode::Clean() {
	garbage_collector(false,basegarbage);
}

void KifCode::FinalGarbage() {
	garbage_collector(true,0);
	kstart=NULL;
}

void KifCode::Garbage() {
	if (Trigger()==true)
		garbage_collector(false,basegarbage);
}

KifKiF::~KifKiF() {
	if (type==kifKiF)
		KifDelete(id);
}

KifCode::~KifCode() {
	kifThreadControl.WaitForTheEnd();

	ThreadLock::Clean();
	kifCodeVector.affecte(idkifmain,NULL);
	FinalGarbage();

	hmap<string,KifThreadLock*>::iterator itlock;
	for (itlock=locktables.begin();itlock!=locktables.end();itlock++)
		delete itlock->second;

	hmap<string,int>::iterator it;
	for (it=kifCodePaths.begin();it!=kifCodePaths.end();it++) {
		if (it->second==idkifmain)
			it->second=-1;
	}
	delete bnfkif;
	if (idkifmain==0) {
		//If it is the first module, then we clean also our libraries...
		hmap<string,KifExternalModule>::iterator term;
		for (term=kifTerminateLibraries.begin();term!=kifTerminateLibraries.end();term++)
			(*term->second)(this,KIFVERSION);
	}
	hmap<short,KifPredefined*>::iterator ifunc;
	for (ifunc=kifBaseFunctions.begin();ifunc!=kifBaseFunctions.end();ifunc++)
		delete ifunc->second;

	for (ifunc=kifBaseTreeFunctions.begin();ifunc!=kifBaseTreeFunctions.end();ifunc++)
		delete ifunc->second;
}

//Generic GARBAGE: clean all instances
void KifCode::garbage_collector(bool force,int from) {
#ifdef PROFILING
	profilingcall("Code::garbage_collector");
#endif
	ThreadLock _lock(kifGarbage);

	if (insidecall>0)
		return;

	if (garbagefunction!=NULL)
		garbagefunction->Execute(kifNULL,NULL);

	KifElement* ke;
	size_t it;

	if (force==true) {
		for (cursorstring=0;cursorstring<stringlist.size();cursorstring++)
			delete stringlist[cursorstring];

		for (cursorinteger=0;cursorinteger<integerlist.size();cursorinteger++)
			delete integerlist[cursorinteger];

		for (cursorfloat=0;cursorfloat<floatlist.size();cursorfloat++)
			delete floatlist[cursorfloat];
		
		for (cursorvector=0;cursorvector<vectorlist.size();cursorvector++)
			delete vectorlist[cursorvector];

		for (cursormap=0;cursormap<maplist.size();cursormap++)
			delete maplist[cursormap];

		for (cursorlist=0;cursorlist<listlist.size();cursorlist++)
			delete listlist[cursorlist];

		for (it=0;it<garbage.size();it++) {
			ke=garbage[it];
			if (ke!=NULL)
				delete ke;
		}
		return;
	}

	//We only free elements from that specific thread, to avoid weird issues
	for (it=from;it<garbage.size();it++) {
		ke=garbage[it];
		if (ke==NULL)
			continue;
		if (ke->popped) {
			ke->popped=false;
			continue;
		}
		if (ke->reference==0 && (ke->threadowner==kifNoOwner || ke->threadowner==idkifmain))
			ke->Clean();
	}

	cursormax=from;
	cursor=-1;
	cursorvector=-1;
	//We need first to avoid problems with vectors
	for (it=0;it<vectorlist.size();it++) {
		//we clear all unused vectors of each possible value that might be stored in
		ke=vectorlist[it];
		if (ke->popped) {
			ke->popped=false;
			continue;
		}
		if (ke->reference==0 && (ke->threadowner==kifNoOwner || ke->threadowner==idkifmain)) {
			if (cursorvector==-1)
				cursorvector=it;
			vectorlist[it]->Clear();
		}
	}

	cursormap=-1;
	for (it=0;it<maplist.size();it++) {
		ke=maplist[it];
		//we clear all unused maps of each possible value that might be stored in
		if (ke->popped) {
			ke->popped=false;
			continue;
		}
		if (ke->reference==0 && (ke->threadowner==kifNoOwner || ke->threadowner==idkifmain)) {
			if (cursormap==-1)
				cursormap=it;
			ke->Clear();
		}
	}

	cursorlist=-1;
	//We need first to avoid problems with lists
	for (it=0;it<listlist.size();it++) {
		//we clear all unused lists of each possible value that might be stored in
		ke=listlist[it];
		if (ke->popped) {
			ke->popped=false;
			continue;
		}
		if (ke->reference==0  && (ke->threadowner==kifNoOwner || ke->threadowner==idkifmain)) {
			if (cursorlist==-1)
				cursorlist=it;
			ke->Clear();
		}
	}

	int nbfree=garbage.taille-garbage.dernier-1;
	for (it=from;it<garbage.size();it++) {
		ke=garbage[it];
		if (ke==NULL) {
			nbfree++;
			if (cursor==-1)
				cursor=it;
			cursormax=it;
			continue;
		}
		if (ke->popped) {
			ke->popped=false;
			continue;
		}
		
		if (ke->reference<=0 && (ke->threadowner==kifNoOwner || ke->threadowner==idkifmain)) {
			nbfree++;
			delete ke;
			if (cursor==-1)
				cursor=it;
			cursormax=it;
			garbage.affecte(it,NULL);
		}
	}
	//if nbfree is less than 12 percent of the garbage, we need to increase it
	nbfree<<=3;
	if (nbfree<garbage.taille) {
		garbage.ajuste(garbage.taille*2);
		cursormax=garbage.taille-10;
	}
}

void KifCode::garbage_initialisation() {	
	if (basegarbage==0) {
		basegarbage=garbage.size();
		if (trigger!=-1)
			trigger+=basegarbage;
	}
	for (int it=0;it<basegarbage;it++) 
		garbage[it]->reference++;
	int sizevect=basegarbage;
	garbage.ajuste(sizevect);
	//We then create some elements in advance
	cursor=0;
	for (int i=0;i<sizevect;i++)
		garbage.push_back(NULL,100);
}


int KifCode::Add(KifElement* ke) {
#ifdef PROFILING
	profilingcall("Code::Add");
#endif
	ThreadLock _lock(kifGarbage);
	
	ke->threadowner=GetThreadid();
	Used(ke->threadowner,kifGarbageOwner);
	int current;
	if (cursor<=cursormax) {
		garbage.affecte(cursor,ke);
		current=cursor;
		cursor++;
		while (cursor<=cursormax && garbage[cursor]!=NULL) cursor++;
	}
	else {
		cursor=garbage.size();
		current=cursor;
		//if we are going to have an extension of the garbage
		//then we can delay the next garbage collecting
		if (current>=garbage.taille)
			cursormax=(garbage.taille*2)-1;
		garbage.push_back(ke,garbage.taille);
	}
	return current;		
}

bool KifCode::Trigger() {
    ThreadLock _lock(kifGarbage);
	if (!nogarbage && cursor>=cursormax)
		return true;
	return false;
}
	

//Specific GARBAGE: we clean all KifElement elements pointing to a XIP temporary information
void KifCode::garbage_xip() {
	for (size_t it=0;it<garbage.size();it++) {
		KifElement* ke=garbage[it];
		if (ke!=NULL)
			ke->CleanXIP();
	}
}

void KifCode::garbage_xml() {
	for (size_t it=0;it<garbage.size();it++) {
		KifElement* ke=garbage[it];
		if (ke!=NULL)
			ke->CleanXML();
	}
}


void KifFinalClean() {
	if (kifNULL!=NULL) {
		delete kifStringId;
		delete kifIdString;
		delete kifNULL;
		delete kifMINUSONE;
		delete kifDEFAULT;
		delete kifTRUE;
		delete kifFALSE;
		delete kifBREAK;
		delete kifBREAKPOINT;
		delete kifCONTINUE;
		delete kifNEG;
	}
}




void KifCode::SetArguments(vector<string>& args) {
#ifdef PROFILING
	profilingcall("Code::SetArguments");
#endif
	for (int i=0;i<args.size();i++) 
		arguments.push_back(args[i]);
	short n=KifNewId("_args");
	KifConst* var=(KifConst*)kstart->Declaration(n);
	KifVector* vargs=(KifVector*)var->value;
	for (int i=0;i<arguments.size();i++)
		vargs->Push(new KifBaseString(this,NULL,arguments[i]));
}



bool KifCode::KifConversion(string n) {
#ifdef PROFILING
	profilingcall("Code::KifConversion");
#endif
	if (kifConversionNames.find(n)!=kifConversionNames.end())
		return true;
	return false;
}

int KifTestPath(string path) {
	if (kifCodePaths.find(path)==kifCodePaths.end() || kifCodePaths[path]==-1)
		return -1;
	return kifCodePaths[path];
}

void SetKifPath(string path,int id) {
	char localpath[1024];
#ifdef WIN32
	_fullpath(localpath,STR(path),1024);
#else
	realpath(STR(path),localpath);
#endif
	kifCodePaths[localpath]=id;
}

int KifLoadPath(KifCode* kifcode,string& path,vector<string>& arguments,bool debugkif) {
	char localpath[1024];
#ifdef WIN32
	_fullpath(localpath,STR(path),1024);
#else
	realpath(STR(path),localpath);
#endif

	int ikif=KifTestPath(localpath);
	if (ikif==-1) {
		vector<string> paths;
		paths.push_back(localpath);
		ikif=KifLoad(kifcode,paths,arguments,debugkif);		
	}
	return ikif;
}

int KifLoadin(KifCode* kifcode,string path) {
	//On initialise une valeur par defaut du declencheur 
	//de garbage, pour que celui-ci puisse s'effectuer
	//a chaque fin d'execution

	x_reading* precurrent=kifcode->current;
	int from=kifcode->kstart->InstructionSize();
	ifstream* fkif=new ifstream(STR(path),modeOuverture);
	try {
		kifcode->bnfkif->baseline=1;
		cerr<<"Loading kif file: "<<STR(path)<<Endl;
		kifcode->Loadfile(fkif,path,0,NULL);
		SetKifPath(path,kifcode->idkifmain);
	}
	catch(KifRaiseError* m) {
		cerr<<STR(m->message)<<" at "<<m->left<<Endl;
		delete m;
		return -1;
	}	
	for (int i=from;i<kifcode->kstart->instructions.size();i++)
		kifcode->kstart->instructions[i]->reference=30000;
	if (kifcode->error==true) {
		cerr<<STR(kifcode->errorptr->String())<<Endl;
		return -1;
	}
	kifcode->current=precurrent;
	return kifcode->idkifmain;
}


Exported int KifLoad(KifCode* loader,vector<string>& paths,vector<string>& arguments,bool debugkif) {
	//On initialise une valeur par defaut du declencheur 
	//de garbage, pour que celui-ci puisse s'effectuer
	//a chaque fin d'execution
	KifCode* kifcode;
	if (loader!=NULL)
		kifcode=new KifCode(loader->trigger,loader->utf8,loader->data,loader->os);
	else
		kifcode=new KifCode(kif_declencheur);

	kifcode->SetArguments(arguments);
	int i;
	for (i=0;i<paths.size();i++) {
		ifstream* fkif=new ifstream(STR(paths[i]),modeOuverture);
		try {
			kifcode->bnfkif->baseline=1;
			cerr<<"Loading kif file: "<<STR(paths[i])<<Endl;
			kifcode->Loadfile(fkif,paths[i],0,loader);
			SetKifPath(paths[i],kifcode->idkifmain);
		}
		catch(KifRaiseError* m) {
			cerr<<STR(m->message)<<" at "<<m->left<<Endl;
			delete m;
			return -1;
		}	
	}
	kifcode->Setdebug(debugkif);
	kifcode->Run(7);
	if (kifcode->error==true) {
		cerr<<STR(kifcode->errorptr->String())<<Endl;
		return -1;
	}
	return kifcode->idkifmain;
}


Exported string KifExecute(int ikif,string name,vector<string>& parameters,ostringstream* os,bool debugkif) {
	KifCode* kifcode=kifCodeVector[ikif];
	if (kifcode==NULL)
		return "";

	ostream* old_os=kifcode->os;
	if (os!=NULL)
		kifcode->os=os;
	kifcode->Setdebug(debugkif);

	vector<KifElement*> params;
	char buf[10];
	for (int i=0;i<parameters.size();i++) {
		KifElement* ke=kifcode->Providestring(parameters[i]);
		string varname="^i_";
		sprintf_s(buf,100,"%d",i);
		varname+=buf;
		short idvarname=KifNewId(varname);
		KifVariableDeclaration* kvar=new KifVariableDeclaration(kifcode,NULL,idvarname);
		kvar->value=ke;
		KifInstance* ki=new KifInstance(kifcode,NULL,idvarname,kvar);
		ki->Setstringvalue(varname);
		ki->value=ke;
		params.push_back(ki);
	}

	string valeur;

	KifElement* proc_ke=kifcode->Searchraw(name);
	if (proc_ke==NULL || proc_ke->type!=kifFunction) {
		valeur=kifErrorStrings[178];
		valeur+=name;
		return valeur;
	}

	KifFunction* proc=(KifFunction*)proc_ke;
	KifElement* resultat=kifcode->Execute(proc,params);

	if (kifcode->error==true) {
		valeur=resultat->String();
		return valeur;
	}

	valeur=resultat->String();
	kifcode->Clean();
	kifcode->os=old_os;
	return valeur;	
}

Exported void KifDelete(int ipar) {
	KifCode* kifcode=kifCodeVector[ipar];
	if (kifcode==NULL)
		return;
	delete kifcode;
}

Exported void KifSetSize(int threshold) {
	kif_declencheur=threshold;
	for (int i=0;i<kifCodeVector.size();i++) 
		kifCodeVector[i]->trigger=kif_declencheur;
}

KifType KifCode::KifAddNewType(string name,KifExternalParse func) {
#ifdef PROFILING
	profilingcall("Code::KifAddNewType");
#endif
	if (kifExternalTypes.find(name)==kifExternalTypes.end()) {
		++*kkifLastType;
		(*kkifStringType)[(KifType)*kkifLastType]=name;
		kifStringType[(KifType)*kkifLastType]=name;
		kifExternalTypes[name]=func;
		return (KifType)*kkifLastType;
	}
	return kifVOID;
}

KifType KifCode::KifNewType() {
	++*kkifLastType;
	return (KifType)*kkifLastType;
}


KifElement* KifCode::KifInitVariable(x_node* xn ,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifInitVariable");
#endif
	short name=KifNewId(xn->nodes[1]->value);
	KifElement* var=CreateVariable(xn,name,kf,kifNOTYPE);
	return var;
}


KifVariableDeclaration* KifCode::Createvariable(string name) {
	short idname=KifNewId(name);
	KifVariableDeclaration* var=new KifVariableDeclaration(this,NULL,idname);
	kstart->Set(idname,var,NULL);
	return var;
}

KifElement* KifCode::KifTerminateVariable(x_node* xn,KifElement* kv,KifElement* var,KifElement* kf) {
#ifdef PROFILING
	profilingcall("Code::KifTerminateVariable");
#endif
	short name=KifNewId(xn->nodes[1]->value);
	kv->Setline(linereference+GetCurrentLine(0,xn->nodes[1]));
	kf->Set(name,var,NULL);
	return var;
}

KifCode* KifElement::KifCurrent() {
	return kifcode;
}

Exported KifFraction* KifElement::Fraction() {
	KifFloat f(NULL,NULL,Float());
	f.kifcode=kifcode;
	return f.Fraction();
}
	
Exported KifFraction* KifInteger::Fraction() {
	return new KifFraction(kifcode,NULL,value,1);
}

Exported KifFraction* KifFloat::Fraction() {
	KIFLONG vl=(long)value; 
	if (vl==value)
		return new KifFraction(kifcode,NULL,vl,1);
	double mantissa=value;
	short nb=1;
	KIFLONG d=1;
	//We limit the calculus to 15 digits after the point.
	//The mantissa of a double is encoded on 52 bits, which is roughly 15 digits...
	while (nb <=15 && mantissa!=(long)mantissa)  {
		mantissa*=10;
		nb++;
		d*=10;
	}
	vl=mantissa;
	//In the case of a full mantissa, we use another version of the transformation
	//namely we divide by d-1, if our number is odd. Thus: 33333333333/99999999999999999 will yield 1/3
	if (nb==16) {
		if (((vl>>1)<<1)!=vl)
			d--;
	}
	KifFraction* f=new KifFraction(kifcode,NULL,vl,d);
	f->FractionSimplify(true);
	return f;
}
	

Exported void KifCode::Setloader(KifCode* k) {
	if (k==NULL)
		return;
	short name=KifNewId("_loader");
	KifElement* kifvar=kstart->Declaration(name);
	KifKiF* kifkif=(KifKiF*)kifvar->Returnvalue();
	kifkif->id=k->idkifmain;
}


Exported void KifCode::ObjectInitialisation(int trig) {
	kcallsyncronous=NULL;
	sizestring=trig>>4;
	compile=false;
	prive=false;
	common=false;
	stringlist.reserve(sizestring);
	KifString* kstr;
	for (cursorstring=0;cursorstring<sizestring;cursorstring++) {
		kstr=new KifString(NULL,NULL,"");
		kstr->kifcode=this;
		kstr->idgarbage=cursorstring;
		stringlist.push_back(kstr);
	}
	cursorstring=0;

	sizeinteger=sizestring;
	integerlist.reserve(sizeinteger);
	KifInteger* kint;
	for (cursorinteger=0;cursorinteger<sizeinteger;cursorinteger++) {
		kint=new KifInteger(NULL,NULL,0);
		kint->kifcode=this;
		kint->idgarbage=cursorinteger;
		integerlist.push_back(kint);
	}
	cursorinteger=0;

	sizefloat=sizestring;
	floatlist.reserve(sizefloat);
	KifFloat* kfloat;
	for (cursorfloat=0;cursorfloat<sizefloat;cursorfloat++) {
		kfloat=new KifFloat(NULL,NULL,0);
		kfloat->kifcode=this;
		kfloat->idgarbage=cursorfloat;
		floatlist.push_back(kfloat);
	}
	cursorfloat=0;
	
	sizevector=sizestring>>2;
	vectorlist.reserve(sizevector);
	KifVector* kvect;
	for (cursorvector=0;cursorvector<sizevector;cursorvector++) {
		kvect=new KifVector(NULL,NULL);
		kvect->kifcode=this;
		kvect->idgarbage=cursorvector;
		vectorlist.push_back(kvect);
	}
	cursorvector=0;

	sizelist=sizevector>>1;
	listlist.reserve(sizelist);
	KifList* klist;
	for (cursorlist=0;cursorlist<sizelist;cursorlist++) {
		klist=new KifList(NULL,NULL);
		klist->kifcode=this;
		klist->idgarbage=cursorlist;
		listlist.push_back(klist);
	}
	cursorlist=0;

	sizemap=sizevector;
	maplist.reserve(sizemap);
	KifMap* kmap;
	for (cursormap=0;cursormap<sizemap;cursormap++) {
		kmap=new KifMap(NULL,NULL);
		kmap->kifcode=this;
		kmap->idgarbage=cursormap;
		maplist.push_back(kmap);
	}
	cursormap=0;

	if (kifStringId==NULL) {
		kifStringId=new hmap<string,short>;
		kifIdString=new hmap<short,string>;
	}
	nogarbage=false;
	utf8=false;
	threadalloc=0;
	current_wait=NULL;
#ifdef _DEBUG
	currentkifcode=this;
#endif
#ifdef WIN32
	_fullpath(buffer,".",1024);
#else
	realpath(".",buffer);
#endif
	kifsvector=&kifCodeVector;
	trigger=trig;
	garbage.ajuste(trigger);
	inittableutf8();
	idkifmain=kifCodeVector.size();
	kifCodeVector.ajoute(this);
	bnfkif=new bnf_kif;
	linereference=0;
	gotoline=-10;
	garbagefunction=NULL;
	debug=false;	
	debugging=false;
	infunction=false;
	breakpoint=-1;
	currentline=0;
	current=NULL;
	basegarbage=0;
	errorptr=NULL;
	error=false;
	cursor=0;
	cursormax=trigger;
	os=&cout;
	insidecall=0;
	int idstart=KifNewId("_KIFMAIN");
	kstart=new KifFrame(this,NULL,idstart);
	short n=KifNewId("_args");
	KifConst* args=new KifConst(this,NULL,n);
	KifVector* vargs=new KifVector(this,args);
	kstart->Set(n,args,NULL);
	n=KifNewId("_paths");
	args=new KifConst(this,NULL,n);
	vargs=new KifVector(this,args);
	kstart->Set(n,args,NULL);
	vargs->Push(new KifBaseString(this,NULL,buffer));
	buffer[0]=0;
	n=KifNewId("_sep");
	args=new KifConst(this,NULL,n);
	string sn;
	sn=SEP;
	KifString* sep=new KifBaseString(this,args,sn);
	n=KifNewId("_sep");
	kstart->Set(n,args,NULL);
	n=KifNewId("_loader");
	KifVariableDeclaration* var=new KifVariableDeclaration(this,NULL,n);
	KifKiF* kifkif=new KifKiF(this,var);
	kstart->Set(n,var,NULL);
	KifInitFunctions(this,kstart);
	var=new KifVariableDeclaration(this,NULL,idstart);
	var->value=kstart;
	kstart->Set(idstart,var,NULL);
	kcallsyncronous=new KifFunctionSynchronous(this,NULL,idsynchronous);
	kstart->declarations[idsynchronous]=kcallsyncronous;
}


Exported long KifCode::GetCurrentLine(int i,x_node* xn) {
	current_start=bnfkif->x_linenumber(xn->start+i);
	current_end=xn->end;
	return current_start;
}


#ifdef WIN32
bool KifCode::KifLoadModule(x_node* xn,string name) {
#ifdef PROFILING
	profilingcall("Code::KifLoadModule");
#endif
	if (name=="")
		return false;

	HINSTANCE LoadMe;
	long line=GetCurrentLine(0,xn);
	string lname=name;
	cerr<<"Loading: "<<STR(lname)<<Endl;
	char chemin[1024];
	NormalisationNomFichier(chemin,STR(lname));
	lname=chemin;
	int pos=lname.find_last_of(SEP);
	string subname=lname;
	if (pos!=-1) {
		subname=lname.substr(pos+1,lname.size()-pos-1);
		pos=subname.find(".");
		if (pos!=-1)
			subname=subname.substr(0,pos);
	}
	
	string initname="Init_";
	initname+=subname;
	string terminatename=subname;
	terminatename+="_Terminate";
	subname+="_KifInitialisationModule";
	KifExternalModule LibInitEntryPoint;
	//If it has already been loaded, we return...
	if (KifRecordLibraries(initname,NULL)==false) {
		LibInitEntryPoint=kifLibraries[initname];
		(*LibInitEntryPoint)(this,KIF_VERSION);
		return true;
	}

	LoadMe = LoadLibrary(STR(lname));

	// Check to see if the library was loaded successfully 

	if (LoadMe == 0) {
		DWORD err=GetLastError();
		lname=kifErrorStrings[189];
		lname+=name;
		throw new KifRaiseError(lname,current->name,line,xn->end);
	}

	KifExternalModule LibMainEntryPoint;            
	KifExternalModule LibTerminateEntryPoint;

	LibMainEntryPoint = (KifExternalModule)GetProcAddress(LoadMe,STR(subname));
	LibInitEntryPoint = (KifExternalModule)GetProcAddress(LoadMe,STR(initname));
	LibTerminateEntryPoint = (KifExternalModule)GetProcAddress(LoadMe,STR(terminatename));

	if (LibMainEntryPoint==NULL || LibInitEntryPoint==NULL) {
		lname=kifErrorStrings[190];
		lname+=name;
		throw new KifRaiseError(lname,current->name,line,xn->end);	
	}

	KifRecordLibraries(initname,LibInitEntryPoint);
	kifTerminateLibraries[terminatename]=LibTerminateEntryPoint;

	if ((*LibMainEntryPoint)(this,KIF_VERSION)==false) {
		FreeLibrary(LoadMe);
		return false;
	}
	return true;
}
#else
bool KifCode::KifLoadModule(x_node* xn,string name) {
#ifdef PROFILING
	profilingcall("Code::KifLoadModule");
#endif
	void* LoadMe;
	long line=GetCurrentLine(0,xn);
	char lname[1024];
	strcpy(lname,STR(name));
	char* error;
	char* pt=strrchr(lname,'/');
	char buff[1024];
	bool addso=true;
	if (strstr(lname+strlen(lname)-3,".so"))
		addso=false;
	if (pt!=NULL) {
		if (addso)
			sprintf(buff,"lib%s.so",pt+1);
		else
			sprintf(buff,"lib%s",pt+1);
		strcpy(pt+1,buff);
	}
	else {
		if (addso)
			sprintf(buff,"lib%s.so",lname);
		else
			sprintf(buff,"lib%s",lname);
		strcpy(lname,buff);
	}

	NormalisationNomFichier(buff,lname);
	strcpy(lname,buff);
	int pos=name.find_last_of('/');

	string subname=name;
	if (pos!=-1) {
		subname=name.substr(pos+1,name.size()-pos-1);
		pos=subname.find(".");
		if (pos!=-1)
			subname=subname.substr(0,pos);
	}
	string initname="Init_";
	initname+=subname;
	string terminatename=subname;
	terminatename+="_Terminate";
	subname+="_KifInitialisationModule";
	cerr<<"Loading: "<<lname<<Endl;
	KifExternalModule LibInitEntryPoint;
	//If it has already been loaded, we return...
	if (KifRecordLibraries(initname,NULL)==false) {
		LibInitEntryPoint=kifLibraries[initname];
		(*LibInitEntryPoint)(this,KIF_VERSION);
		return true;
	}

	LoadMe = dlopen(lname,RTLD_LAZY);

	// Check to see if the library was loaded successfully 

	if (LoadMe == NULL) {
		error=dlerror();
		string message=error;
		message+=": ";
		message+=lname;
		cerr<<STR(message)<<Endl;
		throw new KifRaiseError(message,current->name,line,xn->end);
	}


	KifExternalModule LibMainEntryPoint;
	KifExternalModule LibTerminateEntryPoint;

	LibMainEntryPoint = (KifExternalModule)dlsym(LoadMe,STR(subname));
	LibInitEntryPoint = (KifExternalModule)dlsym(LoadMe,STR(initname));
	LibTerminateEntryPoint = (KifExternalModule)dlsym(LoadMe,STR(terminatename));

	if ((error = dlerror()) != NULL) {
		string message=error;
		message+=": ";
		message+=name;
		cerr<<STR(message)<<Endl;
		throw new KifRaiseError(message,current->name,line,xn->end);
	}

	KifRecordLibraries(initname,LibInitEntryPoint);
	kifTerminateLibraries[terminatename]=LibTerminateEntryPoint;

	if ((*LibMainEntryPoint)(this,KIF_VERSION)==false) {
		dlclose(LoadMe);
		return false;
	}
	return true;
}
#endif

KifCode::KifCode(int trig,bool encoding,void* d,ostream* o) {	
	ObjectInitialisation(trig);
	data=d;		
	if (o==NULL)
		os=&cout;
	else
		os=o;
	utf8=encoding;
}

void KifCode::Setutf8(bool encoding) {
	utf8=encoding;
}


KifString* KifCode::Providestring(string& str) {
	ThreadLock _lock(kifString);	
	int id=GetThreadid();
	Used(id,kifStringOwner);
	int i=cursorstring;
	KifString* ke;
	for (;cursorstring<stringlist.size();cursorstring++) {
		ke=stringlist[cursorstring];
		if (ke->popped)
			continue;
		if (ke->reference<=0 && (ke->threadowner==id || ke->threadowner==kifNoOwner)) {
			ke->reference=0;
			ke->value=str;
			ke->threadowner=id;
			return stringlist[cursorstring++];
		}
	}
	
	for (cursorstring=0;cursorstring<i;cursorstring++) {
		ke=stringlist[cursorstring];
		if (ke->popped) {
			ke->popped=false;
			continue;
		}
		if (ke->reference<=0 &&  (ke->threadowner==id || ke->threadowner==kifNoOwner)) {
			ke->reference=0;
			ke->value=str;
			ke->threadowner=id;
			return stringlist[cursorstring++];
		}
	}		

	sizestring<<=1;
	stringlist.resize(sizestring);
	for (i=cursorstring;i<sizestring;i++) {
		ke=new KifString(NULL,NULL,"");
		ke->kifcode=this;
		ke->idgarbage=i;
		stringlist[i]=ke;
	}
	ke=stringlist[cursorstring];
	ke->value=str;
	ke->threadowner=id;
	cursorstring++;
	return ke;
}

KifString* KifCode::Providestringraw(string str) {
	ThreadLock _lock(kifString);
	int id=GetThreadid();
	Used(id,kifStringOwner);
	int i=cursorstring;
	KifString* ke;
	for (;cursorstring<stringlist.size();cursorstring++) {
		ke=stringlist[cursorstring];
		if (ke->popped)
			continue;
		if (ke->reference<=0 && (ke->threadowner==id || ke->threadowner==kifNoOwner)) {
			ke->reference=0;
			ke->value=str;
			ke->threadowner=id;
			return stringlist[cursorstring++];
		}
	}
	
	for (cursorstring=0;cursorstring<i;cursorstring++) {
		ke=stringlist[cursorstring];
		if (ke->popped) {
			ke->popped=false;
			continue;
		}
		if (ke->reference<=0 &&  (ke->threadowner==id || ke->threadowner==kifNoOwner)) {
			ke->reference=0;
			ke->value=str;
			ke->threadowner=id;
			return stringlist[cursorstring++];
		}
	}		
	
	sizestring<<=1;
	stringlist.resize(sizestring);
	for (i=cursorstring;i<sizestring;i++) {
		ke=new KifString(NULL,NULL,"");
		ke->kifcode=this;
		ke->idgarbage=i;
		stringlist[i]=ke;
	}
	ke=stringlist[cursorstring];
	ke->value=str;
	ke->threadowner=id;
	cursorstring++;
	return ke;
}

KifInteger* KifCode::Provideinteger(long val) {
	ThreadLock _lock(kifInteger);
	int id=GetThreadid();
	Used(id,kifIntegerOwner);
	int i=cursorinteger;
	KifInteger* ke;
	for (;cursorinteger<integerlist.size();cursorinteger++) {
		ke=integerlist[cursorinteger];
		if (ke->popped)
			continue;
			
		if (ke->reference<=0  && (ke->threadowner==id || ke->threadowner==kifNoOwner)) {
			ke->reference=0;
			ke->value=val;
			ke->threadowner=id;
			return integerlist[cursorinteger++];
		}
	}

	for (cursorinteger=0;cursorinteger<i;cursorinteger++) {
		ke=integerlist[cursorinteger];
		if (ke->popped) {
			ke->popped=false;
			continue;
		}
		
		if (ke->reference<=0 &&  (ke->threadowner==id || ke->threadowner==kifNoOwner)) {
			ke->reference=0;
			ke->value=val;
			ke->threadowner=id;
			return integerlist[cursorinteger++];
		}
	}		
	sizeinteger<<=1;
	integerlist.resize(sizeinteger);
	for (i=cursorinteger;i<sizeinteger;i++) {
		ke=new KifInteger(NULL,NULL,0);
		ke->kifcode=this;
		ke->idgarbage=i;
		integerlist[i]=ke;
	}
	ke=integerlist[cursorinteger];
	ke->value=val;
	ke->threadowner=id;
	cursorinteger++;
	return ke;
}

KifFloat* KifCode::Providefloat(double val) {
	ThreadLock _lock(kifFloat);
	int id=GetThreadid();
	Used(id,kifFloatOwner);
	int i=cursorfloat;
	KifFloat* kfloat;
	for (;cursorfloat<floatlist.size();cursorfloat++) {
		kfloat=floatlist[cursorfloat];
		if (kfloat->popped)
			continue;
		if (kfloat->reference<=0 && (kfloat->threadowner==id || kfloat->threadowner==kifNoOwner)) {
			kfloat->reference=0;
			kfloat->value=val;
			kfloat->threadowner=id;
			return floatlist[cursorfloat++];
		}
	}
	for (cursorfloat=0;cursorfloat<i;cursorfloat++) {
		kfloat=floatlist[cursorfloat];
		if (kfloat->popped) {
			kfloat->popped=false;
			continue;
		}
		if (kfloat->reference<=0 && (kfloat->threadowner==id || kfloat->threadowner==kifNoOwner)) {
			kfloat->reference=0;
			kfloat->value=val;
			kfloat->threadowner=id;
			return floatlist[cursorfloat++];
		}
	}		
	sizefloat<<=1;
	floatlist.resize(sizefloat);
	for (i=cursorfloat;i<sizefloat;i++) {
		kfloat=new KifFloat(NULL,NULL,0);
		kfloat->kifcode=this;
		kfloat->idgarbage=i;
		floatlist[i]=kfloat;
	}
	kfloat=floatlist[cursorfloat];
	kfloat->value=val;
	kfloat->threadowner=id;
	cursorfloat++;
	return kfloat;
}

KifVector* KifCode::Providevector() {
	ThreadLock _lock(kifVector);
	int id=GetThreadid();
	Used(id,kifVectorOwner);
	int i=cursorvector;
	KifVector* kvect;

	for (;cursorvector<vectorlist.size();cursorvector++) {
		kvect=vectorlist[cursorvector];
		if (kvect->popped)
			continue;
		if (kvect->reference<=0 && (kvect->threadowner==id || kvect->threadowner==kifNoOwner)) {
			kvect->reference=0;
			kvect->threadowner=id;
			kvect->Clear();
			return vectorlist[cursorvector++];
		}
	}
	for (cursorvector=0;cursorvector<i;cursorvector++) {
		kvect=vectorlist[cursorvector];
		if (kvect->popped) {
			kvect->popped=false;
			continue;
		}
		if (kvect->reference<=0 && (kvect->threadowner==id || kvect->threadowner==kifNoOwner)) {
			kvect->reference=0;
			kvect->threadowner=id;
			kvect->Clear();
			cursorvector++;
			return vectorlist[cursorvector-1];
		}
	}		
	sizevector<<=1;
	vectorlist.resize(sizevector);
	for (i=cursorvector;i<sizevector;i++) {
		kvect=new KifVector(NULL,NULL);
		kvect->kifcode=this;
		kvect->idgarbage=i;
		vectorlist[i]=kvect;
	}
	kvect=vectorlist[cursorvector];
	kvect->threadowner=id;
	cursorvector++;
	return kvect;
}

KifList* KifCode::Providelist() {
	ThreadLock _lock(kifList);
	int id=GetThreadid();
	Used(id,kifListOwner);
	int i=cursorlist;
	KifList* klist;

	for (;cursorlist<listlist.size();cursorlist++) {
		klist=listlist[cursorlist];
		if (klist->popped)
			continue;
		
		if (klist->reference<=0  && (klist->threadowner==id || klist->threadowner==kifNoOwner)) {
			klist->reference=0;
			klist->threadowner=id;
			klist->Clear();
			return listlist[cursorlist++];
		}
	}
	for (cursorlist=0;cursorlist<i;cursorlist++) {
		klist=listlist[cursorlist];
		if (klist->popped) {
			klist->popped=false;
			continue;
		}
		if (klist->reference<=0 && (klist->threadowner==id || klist->threadowner==kifNoOwner)) {
			klist->reference=0;
			klist->threadowner=id;
			klist->Clear();
			cursorlist++;
			return listlist[cursorlist-1];
		}
	}		
	sizelist<<=1;
	listlist.resize(sizelist);
	for (i=cursorlist;i<sizelist;i++) {
		klist=new KifList(NULL,NULL);
		klist->kifcode=this;
		klist->idgarbage=i;
		listlist[i]=klist;
	}
	klist=listlist[cursorlist];
	klist->threadowner=id;
	cursorlist++;
	return klist;
}

KifMap* KifCode::Providemap() {
	ThreadLock _lock(kifMap);
	int id=GetThreadid();
	Used(id,kifMapOwner);
	int i=cursormap;
	KifMap* kmap;

	for (;cursormap<maplist.size();cursormap++) {
		kmap=maplist[cursormap];
		if (kmap->popped)
			continue;
		if (kmap->reference<=0 && !kmap->popped && (kmap->threadowner==id || kmap->threadowner==kifNoOwner)) {
			kmap->reference=0;
			kmap->threadowner=id;
			kmap->Clear();
			return maplist[cursormap++];
		}
	}
	for (cursormap=0;cursormap<i;cursormap++) {
		kmap=maplist[cursormap];
		if (kmap->popped) {
			kmap->popped=false;
			continue;
		}
		if (kmap->reference<=0 && !kmap->popped && (kmap->threadowner==id || kmap->threadowner==kifNoOwner)) {
			kmap->reference=0;
			kmap->threadowner=id;
			kmap->Clear();
			return maplist[cursormap++];
		}
	}		
	sizemap<<=1;
	maplist.resize(sizemap);
	for (i=cursormap;i<sizemap;i++) {
		kmap=new KifMap(NULL,NULL);
		kmap->kifcode=this;
		kmap->idgarbage=i;
		maplist[i]=kmap;
	}
	kmap=maplist[cursormap];
	kmap->threadowner=id;
	kmap->Clear();
	cursormap++;
	return kmap;
}
