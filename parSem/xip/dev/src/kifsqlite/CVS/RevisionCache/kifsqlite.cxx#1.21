/*
 * Xerox Research Centre Europe - Grenoble Laboratory
 *
 * Copyright (C) 2003 - 2010 Xerox Corporation, XRCE-Grenoble, All Rights Reserved.
 * This file can only be used with the KiF library, 
 * it should not and cannot be used otherwise.
 */
/* --- CONTENTS ---
   Project    : KiF
   Version    : 1.00
   filename   : kifsqlite.cxx
   Date       : 09/09/2010
   Purpose    : Implementation of the KiF language: SQLite implementation
   Programmer : Claude ROUX
   Reviewer   : 
*/

#ifdef WIN32
#define KIF_DLL
#endif
#include "kif.h"
#include "sqlite3.h"
#include "conversion.h"

short KifNewId(string n);
string KifIdString(short n);

//Declarations
//Each kifobject has a specific type identifier, which in this case is dynamically generated
static KifType sqlite_type;

//We create a map between our methods, which have been declared in our class below with their names.
class KifSQLite;
//This typedef defines a type "SQLiteMethod", which expose the typical parameters of a new KiF method implementation
typedef KifElement* (KifSQLite::*SQLiteMethod)(KifElement*,KifDomain*,KifCallFunction*);

static int callback(void *kifsql, int argc, char **argv, char **azColName);

string Quotting(string& si) {
	string s="'";
	for (int i=0;i<si.size();i++) {
		if (si[i]=='\'')
			s+="'";
		s+=si[i];
	}
	s+="'";
	s=conversionLatinVersUTF8(s);
	return s;
}

class KifIteratorSQLite: public KifIteration {
public:
	KifSQLite* value;
	sqlite3_stmt *stmt;
	int returncode;
	vector<string> columnnames;
	int columnCount;
	KifMap* currentrow;
	int nb;
	int garbage_i;

	KifIteratorSQLite(KifCode* klc,KifElement* kp) : KifIteration(klc,kp) {
		currentrow=NULL;
		columnCount=0;
		nb=-1;
		garbage_i=-1;
	}

	//This method stores as a map a row of results
	void Storevalue();

	//The next methods are the one that should be derived to add iterator capacities to KifSQLite

	Exported KifElement* IteratorKey() {
		return kifcode->Provideinteger(nb);
	}

	KifElement* IteratorValue();
	KifElement* Next();
	KifElement* End();
	KifElement* Begin();
};


class KifSQLite : public KifBasic {
public:
	//We export the methods that will be exposed for our new object
	//this is a static object, which common to everyone
	static map<short,KifCallMethod> kifexportedmethods;
	//We associate the method pointers with their names in the linkedmethods map
	static map<short,SQLiteMethod> linkedmethods;
	static map<string,string> infomethods;


	string dbname;
	sqlite3 *db;
	KifVector* results;
	string sqlcommand;

	KifSQLite(KifCode* kifcode,KifElement* base) : KifBasic(kifcode,base,sqlite_type) {
		dbname="";
		db=NULL;
		sqlcommand="";
		results=kifcode->Providevector();
	}

	//Duplication of an element
	KifElement* Copy(KifDomain* kp,KifElement* dom=kifNULL) {
		KifSQLite* kperso=new KifSQLite(KifCurrent(),NULL);
		kperso->dbname=dbname;
		kperso->db=db;
		return kperso;
	}


	//How to set the inner value
	bool Setvalue(KifElement* kval,KifElement* kindex,KifElement* domain) {
		return true;
	}

	//We create our iterator element. This method is called when an iterator is initialised with our local object
	//iterator it=mydb;
	KifElement* Newiterator(bool rev) {
		KifIteratorSQLite* iter=new KifIteratorSQLite(kifcode,NULL);
		iter->reverse=rev;
		//we set the value with the right one
		iter->value=this;
		return iter;
	}


	//Declaration
	//All our methods must have been declared in our kifsqlitemethod variable (which might take any name you want)
	KifElement* Declaration(short n) {
		if (kifexportedmethods.find(n)!=kifexportedmethods.end())
			return &kifexportedmethods[n];
		//It might be a predefined function: list, type or isa
		return Kifpredefined(n);
	}

	//List of accessible functions
	//we iterate among the functions we have declared
	void Methods(KifVector* fcts) {
		map<short,KifCallMethod>::iterator it;
		for (it=kifexportedmethods.begin();it!=kifexportedmethods.end();it++)
			fcts->Push(kifcode->Providestringraw(KifIdString(it->first)));
	}

	KifElement* Information(KifElement* kstr) {
		string s=kstr->String();
		if (infomethods.find(s)==infomethods.end())
			return kifNULL;
		return kifcode->Providestring(infomethods[s]);
	}

//----------------------------------------------------------

	KifElement* MethodOpen(KifElement* contextualpattern,KifDomain* domain,KifCallFunction* callfunc) {
		if (db!=NULL)
			return kifcode->Returnerror("SQLite(800): A database has already been opened with this object");

		//callfunc contains the list of our parameters. 
		if (callfunc->Size()!=1)
			return kifNULL;
		//the first parameter is the dbname
		KifElement* kelement=callfunc->Evaluate(0,domain);
		dbname=kelement->String();
		int rc=sqlite3_open(dbname.c_str(), &db);
		if (rc) {
			string message="SQLite(801): Error opening database='";
			message+=dbname;
			message+="' --> ";
			message+=sqlite3_errmsg(db);
			return kifcode->Returnerror(message);
		}
		return kifTRUE;
	}

	KifElement* MethodClose(KifElement* contextualpattern,KifDomain* domain,KifCallFunction* callfunc) {
		if (db==NULL)
			return kifcode->Returnerror("SQLite(802): Cannot close this database");
		sqlite3_close(db);
		return kifTRUE;
	}

	KifElement* MethodExecute(KifElement* contextualpattern,KifDomain* domain,KifCallFunction* callfunc) {
		if (db==NULL)
			return kifcode->Returnerror("SQLite(803): Cannot use this database");
		if (callfunc->Size()==0)
			return kifcode->Returnerror("SQLite(810): Missing parameters in 'Execute'");
		KifElement* kcommand=callfunc->Evaluate(0,domain);
		sqlcommand=kcommand->String();

		//If we are dealing with an iterator, then we simply return our local object, in order
		//to build an iterator. sqlcommand will keep the sql command to pass to the iterator.
		if (contextualpattern!=NULL && contextualpattern->type==kifIterator) 
			return this;

		char* errmsg;
		results->Clear();
		int rc=sqlite3_exec(db, sqlcommand.c_str(), callback, this, &errmsg);
		if (rc!=SQLITE_OK) {
			sqlcommand+="SQLite(811): Execute error=";
			sqlcommand+=errmsg;
			return kifcode->Returnerror(sqlcommand);
		}
		return results;
	}

	KifElement* MethodCreate(KifElement* contextualpattern,KifDomain* domain,KifCallFunction* callfunc) {
		if (db==NULL)
			return kifcode->Returnerror("SQLite(803): Cannot use this database");
		if (callfunc->Size()==0)
			return kifcode->Returnerror("SQLite(804): Missing parameters in 'CREATE'");
		//A typical call would be:
		// mydb.create("table1","name TEXT","age INTEGER",12);
		string command="create table ";
		//The first parameter is the table name
		KifElement* table=callfunc->Evaluate(0,domain);
		command+=table->String();
		command+=" (";
		//The next parameters are the rest of the table description
		for (int i=1;i<callfunc->Size();i++) {
			table=callfunc->Evaluate(i,domain);
			if (i!=1)
				command+=",";
			command+=table->String();		
		}
		command+=");";
		char *zErrMsg=NULL;
		int rc=sqlite3_exec(db, command.c_str(), NULL, 0, &zErrMsg);
		if (rc!=SQLITE_OK) {
			command+="SQLite(805): Create error=";
			command+=zErrMsg;
			return kifcode->Returnerror(command);
		}
		return kifTRUE;
	}

	KifElement* MethodBegin(KifElement* contextualpattern,KifDomain* domain,KifCallFunction* callfunc) {
		if (db==NULL)
			return kifcode->Returnerror("SQLite(803): Cannot use this database");
		if (callfunc->Size()!=0)
			return kifcode->Returnerror("SQLite(804): No parameter needed in 'BEGIN'");
		//A typical call would be:
		// mydb.create("table1","name TEXT","age INTEGER",12);
		string command="BEGIN TRANSACTION;";
		char *zErrMsg=NULL;
		int rc=sqlite3_exec(db, command.c_str(), NULL, 0, &zErrMsg);
		if (rc!=SQLITE_OK) {
			command+="SQLite(805): 'BEGIN' error=";
			command+=zErrMsg;
			return kifcode->Returnerror(command);
		}
		return kifTRUE;
	}


	KifElement* MethodCommit(KifElement* contextualpattern,KifDomain* domain,KifCallFunction* callfunc) {
		if (db==NULL)
			return kifcode->Returnerror("SQLite(803): Cannot use this database");
		if (callfunc->Size()!=0)
			return kifcode->Returnerror("SQLite(806): No parameter needed in 'COMMIT'");
		//A typical call would be:
		// mydb.create("table1","name TEXT","age INTEGER",12);
		string command="COMMIT;";
		char *zErrMsg=NULL;
		int rc=sqlite3_exec(db, command.c_str(), NULL, 0, &zErrMsg);
		if (rc!=SQLITE_OK) {
			command+="SQLite(807): 'COMMIT' error=";
			command+=zErrMsg;
			return kifcode->Returnerror(command);
		}
		return kifTRUE;
	}

	KifElement* MethodInsert(KifElement* contextualpattern,KifDomain* domain,KifCallFunction* callfunc) {
		if (db==NULL)
			return kifcode->Returnerror("SQLite(803): Cannot use this database");
		if (callfunc->Size()==0 || (callfunc->Size()%2)==0)
			return kifcode->Returnerror("SQLite(808): Missing parameters in 'INSERT'");

		string command="insert into ";
		//A typical call would be:
		// mydb.insert("table1","name","toto","age",12);
		//The first parameter is the table name
		KifElement* table=callfunc->Evaluate(0,domain);
		command+=table->String();
		command+=" (";
		//One parameter our of two is column name
		for (int i=1;i<callfunc->Size();i+=2) {
			table=callfunc->Evaluate(i,domain);
			if (i!=1)
				command+=",";
			command+=table->String();		
		}
		command+=") values (";
		//One parameter out of two is a value associated to a column name
		for (int i=2;i<callfunc->Size();i+=2) {
			table=callfunc->Evaluate(i,domain);
			if (i!=2)
				command+=",";
			string s=table->String();
			s=Quotting(s);
			command+=s;
		}
		command+=");";
		char *zErrMsg=NULL;
		int rc=sqlite3_exec(db, command.c_str(), NULL, 0, &zErrMsg);
		if (rc!=SQLITE_OK) {
			command+="SQLite(809): Create error=";
			command+=zErrMsg;
			return kifcode->Returnerror(command);
		}
		return kifTRUE;
	}

	//ExecuteMethod must be implemented in order to execute our new KiF methods. 
	KifElement* ExecuteMethod(short name,KifElement* contextualpattern,KifDomain* domain,KifCallFunction* callfunc) {
		//This call is a bit cryptic. It takes the method (function) pointer that has been associated in our map with "name"
		//and run it with the proper parameters. This is the right call which should be invoked from within a class definition
		return (this->*linkedmethods[name])(contextualpattern,domain,callfunc);
	}

	//In this case, the current element will be destroyed
	void Clean() {
		reference--;
		//Your cleaning here
		if (db!=NULL)
			sqlite3_close(db);
	}

	void Clear() {
		//Your reset code here
		if (db!=NULL)
			sqlite3_close(db);
	}

	//How to interprete your class according to the basic following types:
	string String() {
		return dbname;
	}
	long Integer() {return 0;}
	double Float() {return 0;}
	bool Boolean() {
		if (db==NULL)
			return false;
		return true;
	}

};
//We need to declare once again our local definitions.
map<short,KifCallMethod> KifSQLite::kifexportedmethods;
map<short,SQLiteMethod>  KifSQLite::linkedmethods;
map<string,string> KifSQLite::infomethods;

static int callback(void *kifsql, int argc, char **argv, char **azColName){
	int i;
	//We use our first parameter as the place where to store our stuff
	KifSQLite* ksql=(KifSQLite*)kifsql;	
	KifMap* kmap=ksql->kifcode->Providemap();
	KifString* kstr;
	for (i=0; i<argc; i++) {
		if (argv[i]==NULL)
			kmap->Push(azColName[i],kifNULL);
		else {
			kstr=ksql->kifcode->Providestringraw(argv[i]);
			kmap->Push(azColName[i],kstr);
		}
	}
	ksql->results->Push(kmap);
	return 0;
}


void KifIteratorSQLite::Storevalue() {
	//We can then relieve the previous element	
	returncode=sqlite3_step(stmt);
	if (currentrow!=NULL) {
		currentrow->Resetreference();
		kifcode->Garbage();
		currentrow=NULL;
	}
	
	if (returncode!=SQLITE_ROW)
		return;

	currentrow=kifcode->Providemap();
	currentrow->Setreference();
	KifInteger* kint;
	KifFloat* kfloat;
	KifString* ktext;
	string txt;

	for (int i = 0; i < columnCount; i++) {

		switch (sqlite3_column_type(stmt, i)) {
		case SQLITE_INTEGER:
			kint=kifcode->Provideinteger(sqlite3_column_int(stmt, i));
			currentrow->Push(columnnames[i],kint);
			break;
		case SQLITE_BLOB:
		case SQLITE_TEXT:
			txt=(char*)sqlite3_column_text(stmt, i);
			ktext=kifcode->Providestring(txt);
			currentrow->Push(columnnames[i],ktext);
			break;
		case SQLITE_FLOAT:
			kfloat=kifcode->Providefloat(sqlite3_column_double(stmt, i));
			currentrow->Push(columnnames[i],kfloat);
			break;
		default:
			currentrow->Push(columnnames[i],kifNULL);
		}
	}	
	nb++;
}

KifElement* KifIteratorSQLite::IteratorValue() {
	if (currentrow==NULL)
		return kifNULL;
	return currentrow;
}

KifElement* KifIteratorSQLite::Next() {
	Storevalue();
	return IteratorValue();
}

KifElement* KifIteratorSQLite::End() {
	if (returncode!=SQLITE_ROW) {
		sqlite3_finalize(stmt);
		if (currentrow!=NULL)
			currentrow->Resetreference();
		return kifTRUE;
	}
	return kifFALSE;
}

KifElement* KifIteratorSQLite::Begin() {
	nb=-1;
	int rc=sqlite3_prepare_v2(value->db, value->sqlcommand.c_str(),-1,&stmt,0);
	if (rc!= SQLITE_OK) {
		string message="Wrong statement: ";
		message+=value->sqlcommand;
		return kifcode->Returnerror(message);
	}
	//we get the number of columns matching the sql command
	columnCount = sqlite3_column_count(stmt);

	//we then store their names
	for (int i = 0; i < columnCount; i++)
		columnnames.push_back(sqlite3_column_origin_name(stmt, i));
	
	Storevalue();
	return IteratorValue();
}

//Browsing function to associate a variable declaration with an object of our new type
//Thanks to this method, this new type is now known to the KiF compiler.
static KifElement* CreatekifsqliteElement(KifCode* kifcode,x_node* xn,KifElement* base) {
	//Mandatory call to initialise our variable
	KifElement* variable=kifcode->KifInitVariable(xn ,base);
	//which we associate with our object
	KifSQLite* local=new KifSQLite(kifcode,variable);
	//We then set the whole stuff right
	return kifcode->KifTerminateVariable(xn,local,variable,base);
}

//MethodInitialization will add the right references to "name", which is always a new method associated to the object we are creating
static void MethodInitialization(string name,SQLiteMethod func,string infos) {
	//A KifCallMethod object is used by KiF to call the ExecuteMethod on our object
	short idname=KifNewId(name);
	KifCallMethod kcm(idname);
	KifSQLite::kifexportedmethods[idname]=kcm;
	KifSQLite::linkedmethods[idname]=func;
	KifSQLite::infomethods[name]=infos;
}

//we export this function as a C one to avoid fumbling with C++ mangling
extern "C" {
	Exported bool Init_kifsqlite(KifCode* kifcode,string version) {
		if (version!=KIFVERSION) {
			cerr<<"Incompatible version of KiF"<<endl;
			return false;
		}
#ifndef KIF_RAW
		cerr<<"SQLite is a trademark of Hipp, Wyrick & Company, Inc."<<endl;
#endif
		kifcode->KifInitLib();
		///The new type will be: sqlite. You will be able to declare any variable with that type, once this library has been loaded...
		//CreatekifsqliteElement will be invoked by the KiF compiler to create the right sort of object for this type (in our example: KifSQLite)
		//Whenever the keyword testage will be found by KiF it will then call CreatekifsqliteElement, thanks to this association.
		//If the function returns kifVOID, it is an error. This type has already been declared.
		sqlite_type=kifcode->KifAddNewType("sqlite",CreatekifsqliteElement);
		if (sqlite_type==kifVOID)
			return false;
		return true;
	}


	Exported bool kifsqlite_KifInitialisationModule(KifCode* kifcode,string version) {
		if (Init_kifsqlite(kifcode,version)==false)
			return false;

		//We need to create specific objects in order to have our right class method called
		//MethodInitialization, which is declared in this file (see above), implements a specific object that will be returned
		//by the Declaration method above. When a KifCallMethod object is detected during execution, then KiF calls
		//ExecuteMethod, which must have been implemented for our new object (see above again). We also link this new name with a specific method from
		//our new class.
		MethodInitialization("open",&KifSQLite::MethodOpen,"open(string pathname): open a database");
		MethodInitialization("close",&KifSQLite::MethodClose,"close(): close a database");
		MethodInitialization("create",&KifSQLite::MethodCreate,"create(x1,x2,x3): create a table in a database, with the arguments x1,x2,x3.\rEx. mydb.create(\"table1\",\"nom TEXT PRIMARY KEY\",\"age INTEGER\");");
		MethodInitialization("insert",&KifSQLite::MethodInsert,"insert(string table,string column,int value,...): insert a line in a table.\rEx. mydb.insert(\"table1\",\"nom\",nm,\"age\",i);");
		MethodInitialization("execute",&KifSQLite::MethodExecute,"execute(string sqlcommand): execute a sql command. If the input variable is a vector, then all possible values will be stored in it. It the input variable is an iterator, then it is possible to iterate on the results of the sql command. Each result is a map, where each key is a column name.");
		MethodInitialization("begin",&KifSQLite::MethodBegin,"begin(): to enter the commit mode");
		MethodInitialization("commit",&KifSQLite::MethodCommit,"commit(): the SQL command are then processed. It should finish a series of commands initiated with a begin");

		return true;
	}
	Exported bool kifsqlite_Terminate(KifCode* kifcode,string version) {
		return true;
	}
}
